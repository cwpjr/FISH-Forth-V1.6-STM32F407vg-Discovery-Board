###################################################################################################
#                                                                                                 #
#     IAR Assembler V8.22.1.15669/W32 for ARM 26/Oct/2023  18:18:55                               #
#     Copyright 1999-2018 IAR Systems AB.                                                         #
#                                                                                                 #
#           Source file   =  C:\Users\owner\Desktop\FISH-Forth-V1.6-STM32F407vg-Discovery-Board\FISH_STM32F4_IAR.s#
#           List file     =  C:\Users\owner\Desktop\FISH-Forth-V1.6-STM32F407vg-Discovery-Board\STM32F4_Debug\List\FISH_STM32F4_IAR.lst#
#           Object file   =  C:\Users\owner\Desktop\FISH-Forth-V1.6-STM32F407vg-Discovery-Board\STM32F4_Debug\Obj\FISH_STM32F4_IAR.o#
#           Command line  =  -f C:\Users\owner\AppData\Local\Temp\EWEDE7.tmp                      #
#                            (C:\Users\owner\Desktop\FISH-Forth-V1.6-STM32F407vg-Discovery-Board\FISH_STM32F4_IAR.s #
#                            -OC:\Users\owner\Desktop\FISH-Forth-V1.6-STM32F407vg-Discovery-Board\STM32F4_Debug\Obj #
#                            -s+ -M<> -w+ -r -j -DFISH_PubRel_WORDSET -DFISH_Debug_WORDSET        #
#                            -DSTM32F4_XRC08_168MHZ                                               #
#                            -LC:\Users\owner\Desktop\FISH-Forth-V1.6-STM32F407vg-Discovery-Board\STM32F4_Debug\List #
#                            -t8 --cpu Cortex-M4 --fpu None)                                      #
#                                                                                                 #
###################################################################################################

    1                           // FISH_STM32F4_IAR.s
    2                           
    3                             //FISH NX816. NXP2xx MO+ use NNP
    4                             // Code is common, seperate linker files used for memory map differences.
    5                           $FISH_STM32F4_MAIN_INCLUDES.h
    6                           //------------------------------------------------------------------------------
    7                           // V1.8: 
    8                           // Fix backspace issue.
    9                           // V1.7:
   10                           //
   11                           // V1.6:
   12                           // Release to be base for 4e4th base port.
   13                           // Added STMF205RC for STM RPM Board with 118mhz sysclock from XRC10mhz
   14                           // Any key exit from DUMP
   15                           
   16                           // V1.5.4:
   17                           // CONSTANT, VARIABLE and EXECUTE fit in SRM.
   18                           
   19                           // V1.5.3:
   20                           // CREATE for DOES>
   21                           // BASE in prompt restored to SRM.
   22                           
   23                           // BUG FIX v1.5.2 RM RELEASE:
   24                           // FIXED RWORD TOFA TO ADD ADDR OFFSET TO FPA BASE FLASH ADDR
   25                           // FIXED STACK UNDERFLOW ISSUE WITH CCM END CAUSING HARD FAULT
   26                           // FLASH_FORGET RESET OF FPCURR AND FPVAR
   27                           // FISH ARM DebugSrc V1.5.2:
   28                           // 
   29                           //------------------------------------------------------------------------------
   30                            SECTION .text : CONST (2)
   31                           msg_FISH:
   32                           // DC8 "?" IS A NULL TERMINATED STRING
   33                           // DC8 '?' IS NOT
   34                           //#if FISH_PubRel_WORDSET | FISH_DebugSrc_WORDSET
   35    00000000 4649534820415         DC8     'FISH ARM '
                  24D20        
   36                           //#endif
   37                           #ifdef  STM32F4_XRC08_168MHZ
   38    00000009 53544D3332463         DC8     'STM32F407VG DISCO '
                  4303756472044
                  4953434F20   
   39                           #endif
   40                           #ifdef STM32F205RC_XRC10_118MHZ
   42                           #endif
   43                           #ifdef FISH_Debug_WORDSET
   44    0000001B 4465627567537         DC8     'DebugSrc '
                  26320        
   45                           #endif
   46                           #ifdef FISH_PRO_WORDCAT
   48                           #endif
   49    00000024 524D2056312E3         DC8     'RM V1.6 atbest! <no pon etc>(C)2014-2018 A-TEAM FORTH : '
                  6206174626573
                  7421203C6E6F2
                  0706F6E206574
                  633E284329323
                  031342D323031
                  3820412D54454
                  14D20464F5254
                  48203A20     
   50    0000005C 4F63742032362         DC8     __DATE__        // Null string
                  03230323300  
   51                           msg_FISH_TIMESTAMP:
   52    00000068 20617420              DC8     ' at '
   53    0000006C 31383A31383A3         DC8     __TIME__        // Null string
                  53500        
   54                           msg_MY_OK:
   55    00000075 206F6B2C20676         DC8     " ok, go fish in BASE "
                  F206669736820
                  696E204241534
                  52000        
   56                           //-----------------START OF DICTIONARY = Last word in search--------------------
   57                           //      NOOP NOOP:      ( -- )
   58                            SECTION .text : CONST (2)
   59                           NOOP_NFA:
   60    00000000 84                    DC8     0x84
   61    00000001 4E4F4F                DC8     'NOO'
   62    00000004 D0                    DC8     'P'+0x80
   63    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
   64    00000008 00000000              DC32    0       // 0 START OF DICTIONARY = Last word in search
   65                           NOOP:
   66    0000000C ........              DC32    .+5
   67                            SECTION .text : CODE (2)
   68                                   NEXT
   68.1                         // ARMv7-M Thumb = .+5
   68.2  00000000 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
   68.3                         // ARMv6-M Thumb = .+4
   68.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
   68                                   NEXT1
   68.1  00000004 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
   68.2  00000008 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
   68.3  0000000C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
   68.4                         // ARMv6-M Thumb = .+4
   68.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
   68.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
   68.7                                 ENDM
   68.8                                 ENDM
   69                           
   70                           
   71                           //      EXECUTE EXEC:   ( cfa -- ) RENAMED: EXECUTE to EXEC
   72                           //      Execute a single word whose cfa is on the stack
   73                           
   74                            SECTION .text : CONST (2)
   75                           EXEC_NFA:
   76    00000000 87                    DC8     0x87
   77    00000001 455845435554          DC8     'EXECUT'
   78    00000007 C5                    DC8     'E'+0x80
   79                            ALIGNROM 2,0xFFFFFFFF
   80    00000008 ........              DC32    NOOP_NFA
   81                           EXEC:
   82    0000000C ........              DC32    .+5
   83                            SECTION .text : CODE (2)
   84                           #ifndef IO2TP
   85                           #ifdef XON_XOFF
   86    00000000 ........              BL      TXRDY_SUBR
   87    00000004 ........              BL      XOFF_SUBR
   88                           #endif
   89                           #endif
   90                           EXEC_ACTION:
   91                                   POPp2w // as in xeq token at ToS setup for exec LDM     p!, {w}
   91.1                                 // as in xeq token on ToS setup for exec
   91.2  00000008 57F8042B              LDR     w, [p], #4      ; xeq token at ToS
   91.3                         //      LDM     p!, {w} // fetch memory p points to into {w}, inc p
   91.4                                 ENDM
   92                                   NEXT1
   92.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
   92.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
   92.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
   92.4                         // ARMv6-M Thumb = .+4
   92.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
   92.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
   92.7                                 ENDM
   93                           
   94                           #ifndef IO2TP
   95                           // TXRDY_SUBR:
   96                            SECTION .text : CODE (2)
   97                           TXRDY_SUBR:
   98    00000000 7246                  MOV     w, lr           // Allow for interrupts to use LR
   99    00000002 024C                  LDR     y, = USART3_SR  // Line Status Register
  100                           txRDY?:
  101    00000004 2168                  LDR     n, [y]          // Get Line Status
  102                           // THIS IS TXE TEST AND FAILS IN TEXT DOWNLOAD
  103                           //        LSRS    n, n, #7      // 80h Bit 7 TXE: Transmit data register empty
  104                           // THIS IS ___ AND WORKS IN TEXT DOWNLOAD
  105    00000006 090A                  LSRS    n, n, #8        // 100h Bit 8 ORIG
  106    00000008 FCD3                  BCC     txRDY?          // Ready
  107    0000000A 1047                  BX      w               // lr  - SUBR RETURN
  108                           
  109                           // XOFF_SUBR:
  110                           #ifdef XON_XOFF
  110.1                                  TABLE
  110.2  0000000C 00480040              Reference on line 99
  111                            SECTION .text : CODE (2)
  112                           XOFF_SUBR:
  113    00000000 7246                  MOV     w, lr           // Allow for interrupts to use LR
  114    00000002 0249                  LDR     n,= USART3_DR
  115    00000004 1324                  LDR     y,  = XOFF_CHAR
  116    00000006 0C70                  STRB    y, [n]
  117    00000008 1047                  BX      w               // lr  - SUBR RETURN
  118                           #endif // XON_XOFF
  119                           
  120                           // XON_SUBR:
  121                           #ifdef XON_XOFF
  121.1                                  TABLE
  121.2  0000000C 04480040              Reference on line 114
  122                            SECTION .text : CODE (2)
  123                           XON_SUBR:
  124    00000000 7246                  MOV     w, lr           // Allow for interrupts to use LR
  125    00000002 0249                  LDR     n,= USART3_DR
  126    00000004 1124                  LDR     y, = XON_CHAR   // preserve TOS 11 24 01 49
  127    00000006 0C70                  STRB    y, [n]
  128    00000008 1047                  BX      w       //lr              // SUBR RETURN
  129                           #endif // XON_XOFF
  130                           #endif // IO2TP
  131    0000000A 0000           LTORG
  131.1                                  TABLE
  131.2  0000000C 04480040              Reference on line 125
  132                           
  133                           //      BL BLANK:       ( -- n )
  134                           //      Push ascii space character as n to TOS.
  135                           
  136                            SECTION .text : CONST (2)
  137                           BLANK_NFA:
  138    00000000 82                    DC8     0x82
  139    00000001 42                    DC8     'B'
  140    00000002 CC                    DC8     'L'+0x80
  141    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  142    00000004 ........              DC32    EXEC_NFA
  143                           BLANK:
  144    00000008 ........20000         DC32    DOCON, 0x20
                  000          
  145                           
  146                           
  147                           //========================= START SYSTEM VARIABLES ===========================//
  148                           // _SV IS cfa label of WORD's that return their address.
  149                           // MODIFIED ALL to be label based vs. offset based.
  150                           
  151                           
  152                           //      UP UP_SV:       ( -- addr of UP ) Value stored here is ALIGNED
  153                           //      A system variable, the RAM VAR pointer, which contains
  154                           //      the address of the next free memory above in the USERRAMSPACE.
  155                           //      The value may be read by .UV and altered by VAR.
  156                           
  157                            SECTION .text : CONST (2)
  158                           UP_NFA:
  159    00000000 82                    DC8     0x82
  160    00000001 55                    DC8     'U'
  161    00000002 D0                    DC8     'P'+0x80
  162    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  163    00000004 ........              DC32    BLANK_NFA
  164                           UP_SV:
  165    00000008 .............         DC32    DOCON, UP
                  ...          
  166                           
  167                           
  168                           //      FENCE FENCE_SV: ( -- addr of FENCE )
  169                           //      A system variable containing an address below which FORGET ting is
  170                           //      trapped. To forget below this point the system must alter the contents
  171                           //      of FENCE.
  172                           
  173                            SECTION .text : CONST (2)
  174                           FENCE_NFA:
  175    00000000 85                    DC8     0x85
  176    00000001 46454E43              DC8     'FENC'
  177    00000005 C5                    DC8     'E'+0x80
  178    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  179    00000008 ........              DC32    UP_NFA
  180                           FENCE_SV:
  181    0000000C .............         DC32    DOCON, FENCE
                  ...          
  182                           
  183                           
  184                           //      DP DP_SV:       ( -- addr of DP ) Value stored here is ALIGNED
  185                           //      A system variable, the dictionary pointer, which contains the address
  186                           //      of the next free memory above the dictionary. The value may be read
  187                           //      by HERE and altered by COMMA (ALIGNED) , ALLOT and CALLOT (UNALIGNED) .
  188                           
  189                            SECTION .text : CONST (2)
  190                           DP_NFA:
  191    00000000 82                    DC8     0x82
  192    00000001 44                    DC8     'D'
  193    00000002 D0                    DC8     'P'+0x80
  194    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  195    00000004 ........              DC32    FENCE_NFA
  196                           DP_SV:
  197    00000008 .............         DC32    DOCON, DP
                  ...          
  198                           
  199                           
  200                           //      BASE BASE_SV:   ( -- addr of NBASE )
  201                           //      A system variable containing the current number base used for input
  202                           //      and output conversion.
  203                           
  204                            SECTION .text : CONST (2)
  205                           BASE_NFA:
  206    00000000 84                    DC8     0x84
  207    00000001 424153                DC8     'BAS'
  208    00000004 C5                    DC8     'E'+0x80
  209    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  210    00000008 ........              DC32    DP_NFA
  211                           BASE_SV:
  212    0000000C .............         DC32    DOCON, NBASE
                  ...          
  213                           
  214                           
  215                           //      CURRENT CURRENT_SV:     ( -- addr of CURRENT )
  216                           //      CURRENT searched everytime. CONTEXT is not used
  217                           //      Used by Create, Definitions, etc and by Latest
  218                           //      to leave the nfa of the topmost word in the CURRENT
  219                           //      vocabulary.  See LATEST NOTE:(FIG) CURR @ @ this CURR @
  220                           
  221                            SECTION .text : CONST (2)
  222                           CURRENT_NFA:
  223    00000000 87                    DC8     0x87
  224    00000001 43555252454E          DC8     'CURREN'
  225    00000007 D4                    DC8     'T'+0x80
  226                            ALIGNROM 2,0xFFFFFFFF
  227    00000008 ........              DC32    BASE_NFA
  228                           CURRENT_SV:
  229    0000000C .............         DC32    DOCON, CURRENT  // LATEST = CURRENT_SV -> MOST RECENT DEF NFA
                  ...          
  230                           
  231                           
  232                           //      STATE STATE_SV: ( -- addr of CSTATE )
  233                           //      A system variable containing the compilation state. A non-zero value
  234                           //      indicates compilation. The value itself may be implementation
  235                           //      dependent. 0xC0 must be used for INTERPRET to execute IMMEDIATE words.
  236                           
  237                            SECTION .text : CONST (2)
  238                           STATE_NFA:
  239    00000000 85                    DC8     0x85
  240    00000001 53544154              DC8     'STAT'
  241    00000005 C5                    DC8     'E'+0x80
  242    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  243    00000008 ........              DC32    CURRENT_NFA
  244                           STATE_SV:
  245    0000000C .............         DC32    DOCON, CSTATE       //Compile STATE
                  ...          
  246                           
  247                           
  248                           //      OUT OUT_SV:     ( -- addr of OUT )
  249                           //      A system variable that contains a value incremented by EMIT. The system
  250                           //      may alter and examine OUT to control display formating.
  251                           
  252                            SECTION .text : CONST (2)
  253                           OUT_NFA:
  254    00000000 83                    DC8     0x83
  255    00000001 4F55                  DC8     'OU'
  256    00000003 D4                    DC8     'T'+0x80
  257                            ALIGNROM 2,0xFFFFFFFF
  258    00000004 ........              DC32    STATE_NFA
  259                           OUT_SV:
  260    00000008 .............         DC32    DOCON, OUT
                  ...          
  261                           
  262                           
  263                           //      IN IN_SV:       ( -- addr of IN )
  264                           //      A system variable containing the byte offset within the current input
  265                           //      text buffer (terminal or disc) from which the next text will be
  266                           //      accepted. WORD uses and moves the value of IN.
  267                           
  268                            SECTION .text : CONST (2)
  269                           IN_NFA:
  270    00000000 82                    DC8     0x82
  271    00000001 49                    DC8     'I'
  272    00000002 CE                    DC8     'N'+0x80
  273    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  274    00000004 ........              DC32    OUT_NFA
  275                           IN_SV:
  276    00000008 .............          DC32   DOCON, IN
                  ...          
  277                           
  278                           
  279                           //      PAD PAD_SV:     ( -- addr of PAD )
  280                           //      Leave the address of the text output buffer PAD on the stack.
  281                           //      Typically at least 82 bytes long.
  282                           
  283                            SECTION .text : CONST (2)
  284                           PAD_NFA:
  285    00000000 83                    DC8     0x83
  286    00000001 5041                  DC8     'PA'
  287    00000003 C4                    DC8     'D'+0x80
  288                            ALIGNROM 2,0xFFFFFFFF
  289    00000004 ........              DC32    IN_NFA
  290                           PAD_SV:
  291    00000008 .............         DC32    DOCON, PAD
                  ...          
  292                           
  293                           
  294                           //      TIB TIB_SV:     ( -- addr of INITTIB )
  295                           //      Leave the address of the text input buffer TIB on the stack.
  296                           //      Typically at least 82 bytes long.
  297                           
  298                            SECTION .text : CONST (2)
  299                           TIB_NFA:
  300    00000000 83                    DC8     0x83
  301    00000001 5449                  DC8     'TI'
  302    00000003 C2                    DC8     'B'+0x80
  303                            ALIGNROM 2,0xFFFFFFFF
  304    00000004 ........              DC32    PAD_NFA
  305                           TIB_SV:
  306    00000008 .............         DC32    DOCON, TIB
                  ...          
  307                           
  308                           
  309                           //======================== END SYSTEM VARIABLES ==============================//
  310                           
  311                           
  312                           //      HERE HERE:      ( -- addr ) Value stored here is ALIGNED
  313                           //      Leave the address of the next available dictionary location.
  314                           
  315                            SECTION .text : CONST (2)
  316                           HERE_NFA:
  317    00000000 84                    DC8     0x84
  318    00000001 484552                DC8     'HER'
  319    00000004 C5                    DC8     'E'+0x80
  320    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  321    00000008 ........              DC32    TIB_NFA
  322                           HERE:
  323    0000000C ........              DC32    DOCOL
  324    00000010 ........              DC32    DP_SV
  325    00000014 ........              DC32    AT
  326    00000018 ........              DC32    SEMIS
  327                           
  328                           
  329                           //      ALLOT ALLOT:    ( sn -- ) Warning: UNALIGNED:
  330                           //      IF DICTIONAIRY FULL PRINT error MESSAGE AND abort.
  331                           //      Add the signed number to the dictionary pointer DP. May be used to
  332                           //      reserve dictionary space or re-origin memory.
  333                           //      CAUTION!
  334                           //      ALLOT and C, (CCOMMA:) ARE THE ONLY WORDS THAT CAN ALLOT UNEVEN AMOUNTS
  335                           //      NOTE: USE ALIGN32_DP_FF_PAD after ALLOT or C, (CCOMMA) .
  336                           
  337                            SECTION .text : CONST (2)
  338                           ALLOT_NFA:
  339    00000000 85                    DC8     0x85
  340    00000001 414C4C4F              DC8     'ALLO'
  341    00000005 D4                    DC8     'T'+0x80
  342    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  343    00000008 ........              DC32    HERE_NFA
  344                           ALLOT:
  345    0000000C ........              DC32    DOCOL
  346    00000010 ........              DC32    DICTSPACE       // \ -- n
  347    00000014 .............         DC32    OVER, SUBB
                  ...          
  348    0000001C ........              DC32    ZLESS
  349    00000020 ........              DC32    ZBRAN
  350    00000024 08000000              DC32    ALLOTOK-.
  351                           
  352    00000028 ........              DC32    DICTFULL_ABORT
  353                           
  354                           ALLOTOK:
  355    0000002C ........              DC32    DP_SV
  356    00000030 ........              DC32    PSTORE
  357    00000034 ........              DC32    SEMIS
  358                           
  359                           
  360                           //      ALIGNED ALIGNED:        ( addr -- a-addr ) DPANS94
  361                           
  362                            SECTION .text : CONST (2)
  363                           ALIGNED_NFA:
  364    00000000 87                    DC8     0x87
  365    00000001 414C49474E45          DC8     'ALIGNE'
  366    00000007 C4                    DC8     'D'+0x80
  367                            ALIGNROM 2,0xFFFFFFFF
  368    00000008 ........              DC32    ALLOT_NFA
  369                           ALIGNED:
  370    0000000C ........              DC32    .+5
  371                            SECTION .text : CODE (2)
  372                                   POP2t
  372.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
  372.2                         //#ifndef TOSCT
  372.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  372.4                         //#endif
  372.5                         //      ADDS    p, p, #4
  372.6                                 ENDM
  373    00000004 C01C                  ADDS    t, t, #3
  374    00000006 0549                  LDR     n, =-4
  375    00000008 0840                  ANDS    t, t, n
  376                                   TPUSH
  376                                   PUSHt   // push t to p, pre decrement p
  376.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  376.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  376.3                         //      STR     t, [p]
  376.4                                 ENDM
  376                                   NEXT
  376.1                         // ARMv7-M Thumb = .+5
  376.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  376.3                         // ARMv6-M Thumb = .+4
  376.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  376                                   NEXT1
  376.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  376.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  376.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  376.4                         // ARMv6-M Thumb = .+4
  376.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  376.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  376.7                                 ENDM
  376.8                                 ENDM
  376.9                                 ENDM
  377                            LTORG
  377.1                                  TABLE
  377.2  0000001C FCFFFFFF              Reference on line 374
  378                           
  379                           
  380                           //      ALIGN32_DP_FF_PAD ALIGN:        ( -- ) DPANS94
  381                           //      Align DP_SV primitive. Pads current DP with 0xFF until aligned.
  382                           //      USED IN , (COMMA:) .  Reflected by HERE .
  383                           //      CAUTION! USE AFTER ALLOT or C, (CCOMMA:) .
  384                           //      See , (COMMA:) which is ALIGNED.
  385                           
  386                            SECTION .text : CONST (2)
  387                           ALIGN_NFA:
  388    00000000 85                    DC8     0x85
  389    00000001 414C4947              DC8     'ALIG'
  390    00000005 CE                    DC8     'N'+0x80
  391    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  392    00000008 ........              DC32    ALIGNED_NFA
  393                           ALIGN:
  394                           ALIGN32_DP_FF_PAD:
  395    0000000C ........              DC32    DOCOL
  396    00000010 ........              DC32    HERE
  397                                   // COULD ADD CODE TO SEE IF ALIGNED ALREADY
  398    00000014 .............         DC32    THREE, PLUS             // 3PLUS
                  ...          
  399    0000001C .............         DC32    DUP, TOR
                  ...          
  400    00000024 ........              DC32    HERE
  401    00000028 ........              DC32    XDO
  402                           ALIGN_PAD_DO:
  403    0000002C ........FF000         DC32    LIT, 0xFF, I, CSTORE
                  000..........
                  ......       
  404    0000003C ........              DC32    XLOOP
  405    00000040 ECFFFFFF              DC32    ALIGN_PAD_DO-.
  406                           
  407    00000044 ........              DC32    RFROM
  408    00000048 ........FCFFF         DC32    LIT, 0xFFFFFFFC // -4
                  FFF          
  409    00000050 ........              DC32    ANDD
  410    00000054 .............         DC32    DP_SV, STORE
                  ...          
  411    0000005C ........              DC32    SEMIS
  412                           
  413                           
  414                           //      , COMMA:        ( n -- ) ALIGNED
  415                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
  416                           //      Write n into next ALIGNED dictionary memory cell, DP reflected by HERE
  417                           
  418                            SECTION .text : CONST (2)
  419                           COMMA_NFA:
  420    00000000 81                    DC8     0x81
  421    00000001 AC                    DC8     ','+0x80
  422    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
  423    00000004 ........              DC32    ALIGN_NFA
  424                           COMMA:
  425    00000008 ........              DC32    DOCOL
  426    0000000C ........              DC32    DICTSPACE       // \ -- n
  427    00000010 ........              DC32    ZLESS
  428    00000014 ........              DC32    ZBRAN
  429    00000018 08000000              DC32    COMMA_OK-.
  430                           
  431    0000001C ........              DC32    DICTFULL_ABORT
  432                           
  433                           COMMA_OK:
  434    00000020 ........              DC32    COMMA_PRIM
  435    00000024 ........              DC32    SEMIS
  436                           
  437                           
  438                           //      C, CCOMMA:      ( n -- ) Warning: UNALIGNED:
  439                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
  440                           //      Store LS 8 bits of n into the next available dictionary byte, advancing
  441                           //      the dictionary pointer.
  442                           //      CAUTION!
  443                           //      ALLOT and C, (CCOMMA:) ARE THE ONLY WORDS THAT CAN ALLOT UNEVEN AMOUNTS
  444                           //      NOTE: USE ALIGN32_DP_FF_PAD after ALLOT or C, (CCOMMA) .
  445                           //      See , (COMMA:) which is ALIGNED.
  446                           
  447                            SECTION .text : CONST (2)
  448                           CCOMMA_NFA:
  449    00000000 82                    DC8     0x82
  450    00000001 43                    DC8     'C'
  451    00000002 AC                    DC8     ','+0x80
  452    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  453    00000004 ........              DC32    COMMA_NFA
  454                           CCOMMA:
  455    00000008 ........              DC32    DOCOL
  456    0000000C ........              DC32    DICTSPACE       // \ -- n
  457    00000010 ........              DC32    ZLESS
  458    00000014 ........              DC32    ZBRAN
  459    00000018 08000000              DC32    CCOMMA_OK-.
  460                           
  461    0000001C ........              DC32    DICTFULL_ABORT
  462                           
  463                           CCOMMA_OK:
  464    00000020 ........              DC32    HERE
  465    00000024 ........              DC32    CSTORE
  466    00000028 ........              DC32    ONE
  467    0000002C ........              DC32    ALLOT_PRIM
  468    00000030 ........              DC32    SEMIS
  469                           
  470                           
  471                           //      VARALLOT VARALLOT:      ( n -- addr ) Value stored here is ALIGNED
  472                           //      IF USERVAR SPACE FULL PRINT Error MESSAGE AND Abort.
  473                           //      Add n * 32 bits to the RAMVARSPACE pointer UP.
  474                           //      Used to allocate space in Ram for VAR's and other system data structures
  475                           
  476                            SECTION .text : CONST (2)
  477                           VARALLOT_NFA:
  478    00000000 88                    DC8     0x88
  479    00000001 564152414C4C4         DC8     'VARALLO'
                  F            
  480    00000008 D4                    DC8     'T'+0x80
  481    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  482    0000000C ........              DC32    CCOMMA_NFA
  483                           VARALLOT:
  484    00000010 ........              DC32    DOCOL
  485    00000014 ........              DC32    VARSPACE                // \ -- n
  486    00000018 .............         DC32    FOUR, SLASH, OVER, SUBB
                  .............
                  ......       
  487    00000028 ........              DC32    ZLESS
  488    0000002C ........              DC32    ZBRAN
  489    00000030 18000000              DC32    VALLOT_OK-.
  490                           
  491    00000034 .............         DC32    LIT, msg_uvfull
                  ...          
  492    0000003C .............         DC32    NULLSTRLEN, TYPE
                  ...          
  493                           #ifdef IO2TP
  497                           #endif
  498    00000044 ........              DC32    ABORT
  499                           
  500                           VALLOT_OK:
  501    00000048 .............         DC32    UP_SV, AT       // Address of this allotment
                  ...          
  502    00000050 ........              DC32    SWAP            // n
  503    00000054 .............         DC32    FOUR, STAR      // n = 4 bytes
                  ...          
  504    0000005C ........              DC32    UP_SV
  505    00000060 ........              DC32    PSTORE          // Address of next var available
  506    00000064 ........              DC32    SEMIS
  507                           
  508                           
  509                           //      LATEST LATEST: ( -- nfa )
  510                           //      Initially ADDR OF LAST WORD IN THE DICTIONARY
  511                           //      Leave the nfa of the topmost word in the dictionary.
  512                           
  513                            SECTION .text : CONST (2)
  514                           LATEST_NFA:
  515    00000000 86                    DC8     0x86
  516    00000001 4C41544553            DC8     'LATES'
  517    00000006 D4                    DC8     'T'+0x80
  518    00000007 FF             ALIGNROM 2,0xFFFFFFFF
  519    00000008 ........              DC32    VARALLOT_NFA
  520                           LATEST:
  521    0000000C ........              DC32    DOCOL
  522    00000010 ........              DC32    CURRENT_SV      // LATEST = CURRENT_SV
  523    00000014 ........              DC32    AT
  524    00000018 ........              DC32    SEMIS
  525                           
  526                           
  527                           //      LFA LFA:        ( pfa -- lfa )
  528                           //      Convert the parameter field address of a dictionary definition to
  529                           //      its link field address.
  530                           
  531                            SECTION .text : CONST (2)
  532                           LFA_NFA:
  533    00000000 83                    DC8     0x83
  534    00000001 4C46                  DC8     'LF'
  535    00000003 C1                    DC8     'A'+0x80
  536                            ALIGNROM 2,0xFFFFFFFF
  537    00000004 ........              DC32    LATEST_NFA
  538                           LFA:
  539    00000008 ........              DC32    .+5
  540                            SECTION .text : CODE (2)
  541                                   POP2t
  541.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
  541.2                         //#ifndef TOSCT
  541.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  541.4                         //#endif
  541.5                         //      ADDS    p, p, #4
  541.6                                 ENDM
  542    00000004 0838                  SUBS     t, t, #8
  543                                   TPUSH
  543                                   PUSHt   // push t to p, pre decrement p
  543.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  543.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  543.3                         //      STR     t, [p]
  543.4                                 ENDM
  543                                   NEXT
  543.1                         // ARMv7-M Thumb = .+5
  543.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  543.3                         // ARMv6-M Thumb = .+4
  543.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  543                                   NEXT1
  543.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  543.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  543.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  543.4                         // ARMv6-M Thumb = .+4
  543.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  543.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  543.7                                 ENDM
  543.8                                 ENDM
  543.9                                 ENDM
  544                           
  545                           
  546                           //      CFA CFA:        ( pfa -- cfa )
  547                           //      Convert the parameter field address of a dictionary definition to
  548                           //      its code field address. <if thumb2 execution addr smudged>
  549                           
  550                            SECTION .text : CONST (2)
  551                           CFA_NFA:
  552    00000000 83                    DC8     0x83
  553    00000001 4346                  DC8     'CF'
  554    00000003 C1                    DC8     'A'+0x80
  555                            ALIGNROM 2,0xFFFFFFFF
  556    00000004 ........              DC32    LFA_NFA
  557                           CFA:
  558    00000008 ........              DC32    .+5
  559                            SECTION .text : CODE (2)
  560                                   POP2t
  560.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
  560.2                         //#ifndef TOSCT
  560.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  560.4                         //#endif
  560.5                         //      ADDS    p, p, #4
  560.6                                 ENDM
  561    00000004 001F                  SUBS     t, t, #4
  562                                   TPUSH
  562                                   PUSHt   // push t to p, pre decrement p
  562.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  562.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  562.3                         //      STR     t, [p]
  562.4                                 ENDM
  562                                   NEXT
  562.1                         // ARMv7-M Thumb = .+5
  562.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  562.3                         // ARMv6-M Thumb = .+4
  562.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  562                                   NEXT1
  562.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  562.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  562.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  562.4                         // ARMv6-M Thumb = .+4
  562.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  562.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  562.7                                 ENDM
  562.8                                 ENDM
  562.9                                 ENDM
  563                           
  564                           
  565                           //      NFA NFA:        ( pfa -- nfa )
  566                           //      Convert the parameter field address of a definition to its name
  567                           //      field. Modified for nfa alighnment padding
  568                           
  569                            SECTION .text : CONST (2)
  570                           NFA_NFA:
  571    00000000 83                    DC8     0x83
  572    00000001 4E46                  DC8     'NF'
  573    00000003 C1                    DC8     'A'+0x80
  574                            ALIGNROM 2,0xFFFFFFFF
  575    00000004 ........              DC32    CFA_NFA
  576                           NFA:
  577    00000008 ........              DC32    DOCOL
  578    0000000C .............         DC32    EIGHT, SUBB     // Addr OF lfa, DUPED TO TRAVERSE Padding
                  ...          
  579                           
  580                           NFA_ALIGN_BEGIN:
  581    00000014 .............         DC32    ONE, SUBB       // ADDR 1 BEFORE lfa, eliminate padding
                  ...          
  582    0000001C .............         DC32    DUP, CAT        // ALIGNROM FF padded?
                  ...          
  583    00000024 ........FF000         DC32    LIT, 0xFF, SUBB
                  000........  
  584    00000030 ........              DC32    ZBRAN           // UNTIL
  585    00000034 E0FFFFFF              DC32    NFA_ALIGN_BEGIN-.
  586                                       
  587    00000038 ........FFFFF         DC32    LIT,-1          // DIRECTION FOR TRAVERSE = Toward nfa
                  FFF          
  588    00000040 ........              DC32    TRAVERSE                // \ -- addr2
  589    00000044 ........              DC32    SEMIS
  590                           
  591                           
  592                           //      PFA PFA:        ( nfa -- pfa )
  593                           //      Convert the name field address of a compiled definition to its
  594                           //      parameter field address.
  595                           
  596                            SECTION .text : CONST (2)
  597                           PFA_NFA:
  598    00000000 83                    DC8     0x83
  599    00000001 5046                  DC8     'PF'
  600    00000003 C1                    DC8     'A'+0x80
  601                            ALIGNROM 2,0xFFFFFFFF
  602    00000004 ........              DC32    NFA_NFA
  603                           PFA:
  604    00000008 ........              DC32    DOCOL           // \ NFA --
  605    0000000C ........              DC32    ONE             // DIRECTION FOR TRAVERSE = Toward CFA
  606    00000010 ........              DC32    TRAVERSE        // \ NFA 1 -- addr2
  607                           
  608                           PFA_ALIGN_BEGIN:
  609    00000014 ........              DC32    ONEP            // ADDR 1 BEFORE lfa, eliminate padding
  610    00000018 .............         DC32    DUP, CAT        // ALIGNROM FF padded?
                  ...          
  611    00000020 ........FF000         DC32    LIT, 0xFF, SUBB
                  000........  
  612    0000002C ........              DC32    ZBRAN           // UNTIL
  613    00000030 E4FFFFFF              DC32    PFA_ALIGN_BEGIN-.
  614                           
  615    00000034 ........              DC32    EIGHT
  616    00000038 ........              DC32    PLUS
  617    0000003C ........              DC32    SEMIS
  618                           
  619                           
  620                           //      ?ALIGNED QALIGNED: ( value -- )
  621                           //      If value not aligned by 4 issue message and ABORT.
  622                           
  623                            SECTION .text : CONST (2)
  624                           QALIGNED_NFA:
  625    00000000 88                    DC8     0x88
  626    00000001 3F414C49474E4         DC8     '?ALIGNE'
                  5            
  627    00000008 C4                    DC8     'D'+0x80
  628    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  629    0000000C ........              DC32    PFA_NFA
  630                           QALIGNED:
  631    00000010 ........              DC32    DOCOL
  632    00000014 ........03000         DC32    LIT, 3, ANDD
                  000........  
  633    00000020 ........              DC32    ZBRAN           //IF no err leave
  634    00000024 3C000000              DC32     QALIGN_OK-.
  635                           
  636    00000028 ........              DC32    PDOTQ
  637    0000002C 2E                    DC8     46
  638    0000002D 56414C5545204         DC8     'VALUE MUST BE EVEN NOT ODD AND MULTIPLE OF 4! '
                  D555354204245
                  204556454E204
                  E4F54204F4444
                  20414E44204D5
                  54C5449504C45
                  204F462034212
                  0            
  639    0000005B FF             ALIGNROM 2,0xFFFFFFFF
  640    0000005C ........              DC32    ABORT
  641                           
  642                           QALIGN_OK:
  643    00000060 ........              DC32    SEMIS
  644                           
  645                           
  646                           //      ?ERROR QERROR: ( f nullstr -- )
  647                           //      If f true type error message (nullstr) and ABORT.
  648                           
  649                            SECTION .text : CONST (2)
  650                           QERROR_NFA:
  651    00000000 86                    DC8     0x86
  652    00000001 3F4552524F            DC8     '?ERRO'
  653    00000006 D2                    DC8     'R'+0x80
  654    00000007 FF             ALIGNROM 2,0xFFFFFFFF
  655    00000008 ........              DC32    QALIGNED_NFA
  656                           QERROR:
  657    0000000C ........              DC32    DOCOL
  658    00000010 ........              DC32    SWAP
  659    00000014 ........              DC32    ZBRAN   //IF no err leave
  660    00000018 10000000              DC32     QERROR_FINISH-.
  661                           
  662    0000001C ........              DC32    ERROR // \ nullstr-addr ---  ABORT's
  663    00000020 ........              DC32    BRAN    //ELSE
  664    00000024 08000000              DC32     QERROR_DONE-.
  665                           
  666                           QERROR_FINISH:
  667    00000028 ........              DC32    DROP    //endif
  668                           
  669                           QERROR_DONE:
  670    0000002C ........              DC32    SEMIS
  671                           
  672                           
  673                           //      DIGIT DIGIT:    ( c base -- digit 1 ) (ok)
  674                           //                      ( c base -- 0 (bad)
  675                           //      Converts the ascii character c using base to its binary
  676                           //      equivalent digit, accompanied by a true flag. If the conversion is
  677                           //      invalid, leaves only a false flag.
  678                           
  679                            SECTION .text : CONST (2)
  680                           DIGIT_NFA:
  681    00000000 85                    DC8     0x85
  682    00000001 44494749              DC8     'DIGI'
  683    00000005 D4                    DC8     'T'+0x80
  684    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  685    00000008 ........              DC32    QERROR_NFA
  686                           DIGIT:
  687    0000000C ........              DC32    .+5
  688                            SECTION .text : CODE (2)
  689                                   POP2w                   // Number base
  689.1  00000000 57F8042B              LDR     w, [p],#4
  689.2                         //      LDR     w, [p]
  689.3                         //      ADDS    p, p, #4
  689.4                                 ENDM
  690                                   POP2t                   // ASCII DIGIT
  690.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
  690.2                         //#ifndef TOSCT
  690.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  690.4                         //#endif
  690.5                         //      ADDS    p, p, #4
  690.6                                 ENDM
  691    00000008 3038                  SUBS   t, t, #'0'
  692    0000000A 13D4                  BMI   DIGI2             // Number error
  693                           
  694    0000000C 0928                  CMP   t, #9
  695    0000000E 02DD                  BLE   DIGI1             // Number = 0 THRU 9
  696                           
  697                                   // Combine?
  698    00000010 C01F                  SUBS   t, t, #7
  699    00000012 0A28                  CMP   t, #10            // Number 'A' THRU 'Z'?
  700    00000014 0EDB                  BLT   DIGI2             // NO
  701                           
  702                           DIGI1:
  703    00000016 9042                  CMP     t, w            // COMPARE Number TO base
  704    00000018 0CDA                  BGE     DIGI2
  705                           
  706    0000001A 0246                  MOV     w, t            // NEW BINARY Number
  707    0000001C 0120                  MOVS    t, #1           // TRUE FLAG
  708                                   DPUSH
  708                                   PUSHw   // push w to p, post decrement p
  708.1  0000001E 47F8042D              STR     w, [p, #-4]!
  708.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
  708.3                         //      STR     w, [p]
  708.4                                 ENDM
  708                                   TPUSH
  708                                   PUSHt   // push t to p, pre decrement p
  708.1  00000022 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  708.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  708.3                         //      STR     t, [p]
  708.4                                 ENDM
  708                                   NEXT
  708.1                         // ARMv7-M Thumb = .+5
  708.2  00000026 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  708.3                         // ARMv6-M Thumb = .+4
  708.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  708                                   NEXT1
  708.1  0000002A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  708.2  0000002E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  708.3  00000032 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  708.4                         // ARMv6-M Thumb = .+4
  708.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  708.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  708.7                                 ENDM
  708.8                                 ENDM
  708.9                                 ENDM
  708.10                                ENDM
  709                           
  710                                   // Number error
  711                           DIGI2:
  712    00000034 0020                  MOVS   t, #0            // FALSE FLAG
  713                                   TPUSH
  713                                   PUSHt   // push t to p, pre decrement p
  713.1  00000036 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  713.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  713.3                         //      STR     t, [p]
  713.4                                 ENDM
  713                                   NEXT
  713.1                         // ARMv7-M Thumb = .+5
  713.2  0000003A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  713.3                         // ARMv6-M Thumb = .+4
  713.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  713                                   NEXT1
  713.1  0000003E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  713.2  00000042 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  713.3  00000046 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  713.4                         // ARMv6-M Thumb = .+4
  713.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  713.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  713.7                                 ENDM
  713.8                                 ENDM
  713.9                                 ENDM
  714                           
  715                           
  716                           //      ENCLOSE ENCL:   ( addr1 c -- addr1 n1 n2 n3 )
  717                           //      A text scanning iterative primitive used only in WORD.
  718                           //      IN is used before and after callS for the iteration
  719                           //      Typically TIB + IN = addr1
  720                           //      noop EX: \ TIB   32 -- TIB   0 4 5
  721                           //      NULL EX: \ TIB   32 -- ADDR-B4-NULL 0 1 1 So DFIND CAN FIND IT!
  722                           //      NULL EX: \ WORD/ENCL -> TIB 1, 0, 20'S
  723                           //      From the text address addr1 and an ascii delimiting character c,
  724                           //      is determined the byte offset to the first non-delimiter character n1,
  725                           //      the offset to the first delimiter after the text n2,
  726                           //      and the offset to the first character not included.
  727                           //      This procedure will not process past an ASCII 'null', treating it
  728                           //      as an unconditional delimiter. NULL termination by EXPECT in QUERY.
  729                           
  730                            SECTION .text : CONST (2)
  731                           ENCL_NFA:
  732    00000000 87                    DC8     0x87
  733    00000001 454E434C4F53          DC8     'ENCLOS'
  734    00000007 C5                    DC8     'E'+0x80
  735                            ALIGNROM 2,0xFFFFFFFF
  736    00000008 ........              DC32    DIGIT_NFA
  737                           ENCL:
  738    0000000C ........              DC32    .+5
  739                            SECTION .text : CODE (2)
  740                                   POP2t                   // TERMINATOR CHAR
  740.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
  740.2                         //#ifndef TOSCT
  740.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  740.4                         //#endif
  740.5                         //      ADDS    p, p, #4
  740.6                                 ENDM
  741    00000004 3968                  LDR     n, [p]          // get text address but leave on stack
  742    00000006 0022                  MOVS    w, #0
  743    00000008 521E                  SUBS    w, w, #1        // CHAR  COUNTER
  744    0000000A 491E                  SUBS    n, n, #1        // ADDR -1
  745                           
  746                           //  SCAN TO FIRST NON-TERMINATOR CHARACTER
  747                           //      and PUSH count to stack leaving last 2 params to compute
  748                           ENCL1:
  749    0000000C 491C                  ADDS    n, n, #1        // ADDR+1
  750    0000000E 521C                  ADDS    w, w, #1        // COUNT+1
  751    00000010 0B78                  LDRB    x, [n]
  752    00000012 9842                  CMP     t, x            //CMP   AL,[BX]
  753    00000014 FAD0                  BEQ     ENCL1           //JZ    ENCL1   // WAIT FOR NON-TERMINATOR
  754                                   PUSHw                   //offset to the first non-delimiter character
  754.1  00000016 47F8042D              STR     w, [p, #-4]!
  754.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
  754.3                         //      STR     w, [p]
  754.4                                 ENDM
  755                                                           //EXiT is now only DPUSH
  756    0000001A 002B                  CMP     x, #0           //CMP   AH,[BX] // null CHAR?
  757    0000001C 0CD1                  BNE     ENCL2           //JNZ   ENCL2   // NO
  758                           
  759                           // FOUND null BEFORE 1ST NON-TERM CHAR
  760                           // RETURN ok args = NULL EX//
  761                           // \ TIB   32 -- ADDR-B4-NULL 0 1 1 So DFIND CAN FIND IT!
  762                           //
  763    0000001E 1846                  MOV     t, x
  764    00000020 521C                  ADDS    w, w, #1        // w = offset to the delimiter after the text
  765                                   DPUSH
  765                                   PUSHw   // push w to p, post decrement p
  765.1  00000022 47F8042D              STR     w, [p, #-4]!
  765.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
  765.3                         //      STR     w, [p]
  765.4                                 ENDM
  765                                   TPUSH
  765                                   PUSHt   // push t to p, pre decrement p
  765.1  00000026 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  765.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  765.3                         //      STR     t, [p]
  765.4                                 ENDM
  765                                   NEXT
  765.1                         // ARMv7-M Thumb = .+5
  765.2  0000002A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  765.3                         // ARMv6-M Thumb = .+4
  765.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  765                                   NEXT1
  765.1  0000002E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  765.2  00000032 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  765.3  00000036 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  765.4                         // ARMv6-M Thumb = .+4
  765.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  765.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  765.7                                 ENDM
  765.8                                 ENDM
  765.9                                 ENDM
  765.10                                ENDM
  766                           
  767                           //   FOUND FIRST TEXT CHAR - COUNT THE CHARS
  768                           ENCL2:
  769    00000038 491C                  ADDS    n, n, #1        // ADDR+1
  770    0000003A 521C                  ADDS    w, w, #1        //COUNT+1
  771    0000003C 0B78                  LDRB    x, [n]
  772    0000003E 9842                  CMP     t, x            //TERMINATOR CHAR?
  773    00000040 01D0                  BEQ     ENCL4           //YES
  774                           
  775    00000042 002B                  CMP     x, #0           //null CHAR?
  776    00000044 F8D1                  BNE     ENCL2           //NO, LOOP AGAIN
  777                           
  778                           ENCL3:  //   FOUND null AT END OF TEXT
  779                           ENCL4:  //   FOUND TERMINATOR CHARACTER
  780    00000046 1046                  MOV     t, w            // COUNT+1 =
  781    00000048 401C                  ADDS    t, t, #1        // offset to the first character not included
  782                                   DPUSH
  782                                   PUSHw   // push w to p, post decrement p
  782.1  0000004A 47F8042D              STR     w, [p, #-4]!
  782.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
  782.3                         //      STR     w, [p]
  782.4                                 ENDM
  782                                   TPUSH
  782                                   PUSHt   // push t to p, pre decrement p
  782.1  0000004E 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  782.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  782.3                         //      STR     t, [p]
  782.4                                 ENDM
  782                                   NEXT
  782.1                         // ARMv7-M Thumb = .+5
  782.2  00000052 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  782.3                         // ARMv6-M Thumb = .+4
  782.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  782                                   NEXT1
  782.1  00000056 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  782.2  0000005A 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  782.3  0000005E 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  782.4                         // ARMv6-M Thumb = .+4
  782.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  782.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  782.7                                 ENDM
  782.8                                 ENDM
  782.9                                 ENDM
  782.10                                ENDM
  783                           
  784                           
  785                           //      0 NULL: ( -- ) IMMEDIATE
  786                           //      Don't return to Interpret, return to Quit at end of a line of input.
  787                           //      Executed at end of TIB when QUERY lenght or CR entered.
  788                           
  789                            SECTION .text : CONST (2)
  790                           NULL_NFA:
  791    00000000 C1                    DC8     0x0C1                   // A BINARY ZER
  792    00000001 80                    DC8     0x80
  793    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
  794    00000004 ........              DC32    ENCL_NFA
  795                           NULL:
  796                           //      DC32    SEMIS                   // Actual Semis code below
  797    00000008 ........              DC32    .+5
  798                            SECTION .text : CODE (2)
  799                                   POPr2i  // pop docol saved IP from Rstack
  799.1  00000000 56F8045B              LDR     i, [r],#4       ; pop DOCOL'd IP from Rstack
  799.2                         //      LDR i, [r]              //  pop r to i, post increment r
  799.3                         //      ADDS    r, r, #4
  799.4                                 ENDM
  800                                   NEXT
  800.1                         // ARMv7-M Thumb = .+5
  800.2  00000004 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  800.3                         // ARMv6-M Thumb = .+4
  800.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  800                                   NEXT1
  800.1  00000008 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  800.2  0000000C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  800.3  00000010 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  800.4                         // ARMv6-M Thumb = .+4
  800.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  800.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  800.7                                 ENDM
  800.8                                 ENDM
  801                           
  802                           
  803                           //      WORD WORD:      ( c -- )
  804                           //      Parse the text in TIB , until a delimiter c is found, tokenizing input.
  805                           //      Move the token to HERE, with a count byte and 2 nulls at the end.
  806                           //      Leading occurrences of c are ignored. IN is incremented.
  807                           //      See IN. Usually used inside a definition.
  808                           
  809                            SECTION .text : CONST (2)
  810                           WORD_NFA:
  811    00000000 84                    DC8     0x84
  812    00000001 574F52                DC8     'WOR'
  813    00000004 C4                    DC8     'D'+0x80
  814    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  815    00000008 ........              DC32    NULL_NFA
  816                           WORD:
  817    0000000C ........              DC32    DOCOL
  818                           WORD1:
  819                           //      This is required for number suffix's at least ???
  820    00000010 .............         DC32    HERE, LIT, MAXWORDLEN+2, BLANKS
                  ...21000000..
                  ......       
  821    00000020 ........              DC32    TIB_SV
  822                           WORD2:
  823    00000024 ........              DC32    IN_SV
  824    00000028 ........              DC32    AT
  825    0000002C ........              DC32    PLUS
  826    00000030 ........              DC32    SWAP    // \ TIB+IN CH-DELIM --
  827    00000034 ........              DC32    ENCL    // \ TIB+IN 32 -- TIB+IN   0 4 5
  828                           WENCL:
  829    00000038 ........              DC32    IN_SV   // encl TOS = end of word offset to be added to IN
  830    0000003C ........              DC32    PSTORE  // TIB+IN   0 4
  831    00000040 ........              DC32    OVER    // 
  832    00000044 ........              DC32    SUBB    // Char cnt going to R and HERE
  833    00000048 ........              DC32    TOR
  834    0000004C ........              DC32    R
  835    00000050 ........              DC32    HERE
  836    00000054 ........              DC32    CSTORE   // CHAR CNT OF word
  837    00000058 ........              DC32    PLUS
  838    0000005C ........              DC32    HERE
  839    00000060 ........              DC32    ONEP
  840    00000064 ........              DC32    RFROM
  841                           // MOVE word TO DICT FOR finding ENDING WITH NULLS
  842    00000068 ........              DC32    CMOVE   // \ from to count --
  843    0000006C ........              DC32    SEMIS
  844                           
  845                           
  846                           //      NUMBER NUMBER:  ( addr -- sd )
  847                           //      If error print message and ABORT.
  848                           //      Convert a character string left at addr with a preceeding count, to
  849                           //      a signed number, using the current numeric base. If a
  850                           //      decimal point is encountered in the text, its position will be
  851                           //      given in DPL, but no other effect occurs. If numeric conversion is
  852                           //      not possible, an error message will be given.
  853                           
  854                            SECTION .text : CONST (2)
  855                           NUMBER_NFA:
  856    00000000 86                    DC8     0x86
  857    00000001 4E554D4245            DC8     'NUMBE'
  858    00000006 D2                    DC8     'R'+0x80
  859    00000007 FF             ALIGNROM 2,0xFFFFFFFF
  860    00000008 ........              DC32    WORD_NFA
  861                           NUMBER:
  862    0000000C ........              DC32    DOCOL
  863    00000010 ........              DC32    BASE_TO_R12     // Save current BASE
  864    00000014 ........              DC32    NUMBERSUFFIX
  865    00000018 .............         DC32    ZERO, ZERO
                  ...          
  866    00000020 ........              DC32    ROT             // \ 0 0 addr --
  867                           
  868    00000024 .............         DC32    DUP, ONEP       // \ 0 0 addr addr+1 --
                  ...          
  869    0000002C ........              DC32    CAT             // \ 0 0 addr 1rstchar --
  870    00000030 ........2D000         DC32    LIT, '-'        // Minus sign = 0x2D
                  000          
  871                                                           // \ 0 0 addr 1rstchar 0x2D ---
  872    00000038 ........              DC32    EQUAL           // \ 0 0 addr f --
  873    0000003C .............         DC32    DUP, TOR        // \ 0 0 addr f -- copy of f >R
                  ...          
  874    00000044 ........              DC32    PLUS            // ASSUMPTION FLAG WILL BE 1 or 0
  875                           
  876    00000048 ........FFFFF         DC32   LIT, -1
                  FFF          
  877                           
  878                           NUMB1:                          // Begin
  879    00000050 .............         DC32    DPL_SV, STORE
                  ...          
  880    00000058 ........              DC32    PNUMBER         // \ 0 0 addr -- ud
  881                           
  882    0000005C ........              DC32    DUP
  883    00000060 ........              DC32    CAT
  884    00000064 ........              DC32    BLANK           //20h
  885    00000068 ........              DC32    SUBB
  886                                                           // while
  887    0000006C ........              DC32    ZBRAN           // IF SPACE
  888    00000070 40000000              DC32    NUMB2-.         // DONE UNLESS IT NEEDS TO BE NEGATED
  889                           
  890    00000074 ........              DC32    DUP
  891    00000078 ........              DC32    CAT
  892    0000007C ........2E000         DC32    LIT, '.'        // 2EH period
                  000          
  893    00000084 ........              DC32    SUBB
  894                           
  895                           NUMERRTEST:
  896                           // IF zero (NOT GOING TO ERROR) LEAVE BASE ALONE FOR LOOP!
  897                           // consumed flag here so provide true flag if you don't
  898                           //        DC32    DUP
  899    00000088 ........              DC32    ZBRAN
  900    0000008C 18000000              DC32      NOBRESTOR-.
  901                           
  902                           // GOING TO ERROR SO RESTORE BASE!
  903    00000090 ........              DC32    BASE_FROM_R12   // Restore BASE
  904                           //NOBRESTOR:
  905    00000094 ........              DC32    ONE     // provide true flag for error
  906    00000098 .............         DC32    LIT, msg_number_error
                  ...          
  907    000000A0 ........              DC32    QERROR // \ f nullstr-addr -- IF f TRUE EXECUTE ERROR!
  908                           
  909                           NOBRESTOR:
  910    000000A4 ........              DC32    ZERO
  911    000000A8 ........              DC32    BRAN
  912    000000AC A4FFFFFF              DC32    NUMB1-.
  913                           
  914                           NUMB2:
  915    000000B0 ........              DC32    DROP
  916    000000B4 ........              DC32    RFROM           // FLAG OF "-" TEST
  917                                                           // IF
  918    000000B8 ........              DC32    ZBRAN
  919    000000BC 08000000              DC32    NUMB3-.
  920                           
  921    000000C0 ........              DC32    DNEGATE
  922                           
  923                           NUMB3:                          // endif
  924    000000C4 ........              DC32    BASE_FROM_R12   // Restore BASE
  925    000000C8 ........              DC32    SEMIS
  926                           
  927                           
  928                           //      ERROR ERROR:    ( nullstr --- )
  929                           //      Execute error notification and restart of system.
  930                           //      IN_SV is saved to assist in determining the location of the error.
  931                           
  932                            SECTION .text : CONST (2)
  933                           ERROR_NFA:
  934    00000000 85                    DC8     0x85
  935    00000001 4552524F              DC8     'ERRO'
  936    00000005 D2                    DC8     'R'+0x80
  937    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  938                           //      DC32    DFIND_NFA
  939    00000008 ........              DC32    NUMBER_NFA
  940                           ERROR:
  941    0000000C ........              DC32    DOCOL
  942    00000010 .............         DC32    HERE, COUNT, TYPE       // Offending item
                  ...........  
  943    0000001C .............         DC32    NULLSTRLEN, TYPE        // Passed in null string
                  ...          
  944                           #ifdef IO2TP
  948                           #endif
  949                           #ifdef XON_XOFF
  950    00000024 ........              DC32    XOFF    // TEMP TEST THRE
  951                           #endif
  952                                   
  953                           //      DO THIS WHERE STATE IS SET BACK TO ZERO
  954    00000028 .............         DC32    STATE_SV, AT
                  ...          
  955    00000030 ........              DC32    ZBRAN
  956    00000034 40000000              DC32     CREATED_OK-.
  957                           
  958                           //      NON-ZERO CSDP = RESTORE DP TO forget DAMAGED WORDS
  959    00000038 .............         DC32    CSDP_SV, AT   // Create saves dp here for if word exists err
                  ...          
  960    00000040 ........              DC32    ZBRAN
  961    00000044 30000000              DC32     CREATED_OK-.
  962                           
  963                           // assume ITS A CREATE'd WORD!!!!
  964                           ERROR_FIXUP:     // CSDP_SV contains NFA of definition that has error.
  965    00000048 .............         DC32    CSDP_SV, AT     // SHOULD BE AT NFA!!
                  ...          
  966    00000050 ........              DC32    PFA     // \ nfa -- pfa
  967    00000054 .............         DC32    LFA, AT // \ pfa --- lfa
                  ...          
  968    0000005C .............         DC32    CURRENT_SV, STORE       // Has to be NFA of last good word
                  ...          
  969                           // RESET DP!
  970    00000064 .............         DC32    CSDP_SV, AT
                  ...          
  971    0000006C .............         DC32    DP_SV, STORE
                  ...          
  972                           
  973                           CREATED_OK:
  974    00000074 ........              DC32    SEMIC_CREATE            // RESET CSDP FOR AUTO FORGET
  975                           
  976    00000078 ........              DC32    QUIT    // FROM Error
  977                           
  978                           
  979                           //      ' TICK: ( -- pfa ) IMMEDIATE
  980                           //      Used in the form: .
  981                           //      ' CCcc
  982                           //      Leaves the parameter field address of dictionary word CCcc.
  983                           //      If the word is not found after a search of CURRENT,
  984                           //      an appropriate error message is given.
  985                           //      As a compiler directive, executed in a colon-definition to compile
  986                           //      the address as a literal.
  987                           //      Pronounced "TICK".
  988                           
  989                            SECTION .text : CONST (2)
  990                           TICK_NFA:
  991    00000000 C1                    DC8     0x0C1
  992    00000001 A7                    DC8     ''''+0x80
  993    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
  994    00000004 ........              DC32    ERROR_NFA
  995                           TICK:
  996    00000008 ........              DC32    DOCOL
  997    0000000C ........              DC32    DFIND   // noop there for TIB entry
  998    00000010 ........              DC32    ZEQU
  999    00000014 .............         DC32    LIT, msg_word_error
                  ...          
 1000    0000001C ........              DC32    QERROR    // \ f nullstr-addr --
 1001    00000020 ........              DC32    DROP
 1002    00000024 ........              DC32    LITERAL
 1003    00000028 ........              DC32    SEMIS
 1004                           
 1005                           
 1006                           //      EXPECT EXPECT:  ( addr count -- )
 1007                           //      Transfer characters from the terminal to the buffer at addr,
 1008                           //      until a "return" or  the count of characters have been received.
 1009                           //      One or more nulls are added at the end creating a null-terminated string.
 1010                           //      Use $LEN with TYPE for strings saved this way.
 1011                           
 1012                            SECTION .text : CONST (2)
 1013                           EXPECT_NFA:
 1014    00000000 86                    DC8     0x86
 1015    00000001 4558504543            DC8     'EXPEC'
 1016    00000006 D4                    DC8     'T'+0x80
 1017    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 1018    00000008 ........              DC32    TICK_NFA
 1019                           EXPECT:                 //       \ NOS TOS -- NOS TOS
 1020    0000000C ........              DC32    DOCOL   //TYP.   \ TIB LEN --
 1021    00000010 ........              DC32    OVER    //       \ TIB LEN TIB --
 1022    00000014 ........              DC32    PLUS    //       \ TIB TIB+LEN --
 1023    00000018 ........              DC32    OVER    //       \ TIB TIB+LEN TIB --
 1024                           #ifdef XON_XOFF
 1025    0000001C ........              DC32    XON
 1026                           #endif
 1027    00000020 ........              DC32    XDO     // DO   Index = addr, Limit = addr+cnt
 1028                           EXPE1:
 1029    00000024 ........              DC32    KEY     // CAN BREAKPOINT OR CHANGE TO BE 0x0D ONLY
 1030                           #ifdef XON_XOFF
 1031    00000028 ........              DC32    IF_EOL_SEND_XOFF        // IF CR QUICK XOFF!
 1032                           #endif
 1033    0000002C .............         DC32    DUP, LIT, 9, EQUAL              // ? TAB
                  ...09000000..
                  ......       
 1034                                   // REPLACE TAB WITH SPACE               // -- ch f
 1035    0000003C ........              DC32    ZBRAN                           // Not tab
 1036    00000040 0C000000              DC32     EL1-.                          // Goto MAIN LOOP
 1037    00000044 .............         DC32    DROP, BLANK                     // Convert tab to space
                  ...          
 1038                           EL1:
 1039                                   // MAIN LOOP ENTERED WITH CHAR ON TOS
 1040    0000004C ........              DC32    DUP             // \ key key --
 1041                           // FALL THRU IF BACKSPACE OR DELETE KEY
 1042    00000050 ........              DC32    BACKSPACE_CHAR
 1043    00000054 ........              DC32    EQUAL
 1044    00000058 ........              DC32    OVER
 1045    0000005C ........7F000         DC32    LIT, 07Fh       // DEL KEY
                  000          
 1046    00000064 ........              DC32    EQUAL
 1047    00000068 ........              DC32    OR
 1048                           // BRANCH HERE IF NOT BACKSPACE OR DELETE KEY
 1049    0000006C ........              DC32    ZBRAN           // If not backspace or DEL key
 1050    00000070 4C000000              DC32     EXPE2-.        // go here
 1051                           
 1052    00000074 ........              DC32    DROP            // Drop Backspace on stack
 1053    00000078 ........              DC32    DUP             // Current TIB addr
 1054    0000007C ........              DC32    I               // 
 1055    00000080 ........              DC32    EQUAL           //
 1056    00000084 ........              DC32    DUP
 1057    00000088 ........              DC32    RFROM
 1058    0000008C ........              DC32    TWO
 1059    00000090 ........              DC32    SUBB
 1060    00000094 ........              DC32    PLUS
 1061    00000098 ........              DC32    TOR
 1062    0000009C ........              DC32    ZBRAN           // If not at beginning of line
 1063    000000A0 10000000              DC32     EXPE6-.        // Goto bsout
 1064                           
 1065    000000A4 ........              DC32    BELL            // At beginning of TIB issue bell
 1066    000000A8 ........              DC32    BRAN            // Goto end of loop
 1067    000000AC 60000000              DC32     EXPE33-.
 1068                           
 1069                           EXPE6:
 1070    000000B0 ........              DC32    BSOUT           // endif
 1071                           EXPE7:  // LABEL NOT USED BECAUSE BELL AND BSOUT Emit THEMSELVES
 1072    000000B4 ........              DC32    BRAN            // Goto end of loop
 1073    000000B8 54000000              DC32     EXPE33-.
 1074                           EXPE2:
 1075    000000BC ........              DC32    DUP
 1076    000000C0 ........0D000         DC32    LIT, 0x0D       // cr
                  000          
 1077    000000C8 ........              DC32    EQUAL
 1078    000000CC ........              DC32    ZBRAN           // If not cr
 1079    000000D0 1C000000              DC32     EXPE4-.        // Goto save this char and loop again
 1080                           
 1081    000000D4 ........              DC32    LEAVE           // cr means Leave loop
 1082    000000D8 ........              DC32    DROP            // Cleanup to leave loop
 1083    000000DC ........              DC32    BLANK           // Space char
 1084    000000E0 ........              DC32    ZERO            // and a null
 1085    000000E4 ........              DC32    BRAN            // Goto store these end end loop
 1086    000000E8 08000000              DC32     EXPE5-.
 1087                           
 1088                           EXPE4:
 1089    000000EC ........              DC32    DUP             // Regular char 
 1090                           
 1091                           EXPE5:
 1092    000000F0 ........              DC32    I               // Store char
 1093    000000F4 ........              DC32    CSTORE          // or 1rst null
 1094    000000F8 ........              DC32    ZERO            // 1rst or second null if cr
 1095    000000FC ........              DC32    I
 1096    00000100 ........              DC32    ONEP
 1097    00000104 ........              DC32    CSTORE
 1098                           
 1099                           EXPE3:
 1100    00000108 ........              DC32    EMIT
 1101                           
 1102                           EXPE33:
 1103    0000010C ........              DC32    XLOOP
 1104    00000110 14FFFFFF              DC32     EXPE1-.        // Loop is LEAVE'd
 1105                           
 1106                           #ifdef XON_XOFF
 1107    00000114 ........              DC32    XOFF            // FOR CASE OF count reached befor cr
 1108                           #endif
 1109    00000118 ........              DC32    DROP
 1110    0000011C ........              DC32    SEMIS
 1111                           
 1112                           
 1113                           //      COUNT COUNT:    ( addr1 --- addr2 n )
 1114                           //      Leave the byte address addr2 and byte count n of a message text
 1115                           //      beginning at address addr1. It is presumed that the first byte at
 1116                           //      addr1 contains the text byte count and the actual text starts with
 1117                           //      the second byte. NFA's may report SMUDGE'd byte counts, handled only
 1118                           //      by ID. User Strings may be up to 255 characters.
 1119                           //      Typically COUNT is followed by TYPE.
 1120                           //      See TYPE and $LEN
 1121                           
 1122                            SECTION .text : CONST (2)
 1123                           COUNT_NFA:
 1124    00000000 85                    DC8     0x85
 1125    00000001 434F554E              DC8     'COUN'
 1126    00000005 D4                    DC8     'T'+0x80
 1127    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1128    00000008 ........              DC32    EXPECT_NFA
 1129                           COUNT:
 1130    0000000C ........              DC32    DOCOL
 1131    00000010 ........              DC32    DUP
 1132    00000014 ........              DC32    ONEP
 1133    00000018 ........              DC32    SWAP
 1134                           //        DC32    CATLT7F
 1135    0000001C ........              DC32    CAT     // n could be SMUDGE'd count from NFA's
 1136    00000020 ........              DC32    SEMIS   // Only internal usage is ID.
 1137                           
 1138                           
 1139                           //      $LEN NULLSTRLEN:        ( addr - addr len )
 1140                           //      Count length of null terminated string.
 1141                           //      TYPE can be used after this word.
 1142                           
 1143                            SECTION .text : CONST (2)
 1144                           NULLSTRLEN_NFA:
 1145    00000000 84                    DC8     0x84
 1146    00000001 244C45                DC8     '$LE'
 1147    00000004 CE                    DC8     'N'+0x80
 1148    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1149    00000008 ........              DC32    COUNT_NFA
 1150                           NULLSTRLEN:
 1151    0000000C ........              DC32    .+5
 1152                            SECTION .text : CODE (2)
 1153                                   NDPOP2w                         // Get but leave addr on stack
 1153.1  00000000 3A68                  LDR     w, [p]
 1153.2                                 ENDM
 1154    00000002 4040                  EORS            t, t, t         // zero count
 1155                           
 1156                           NSLEN_LOOP:
 1157    00000004 115C                  LDRB            n, [w,t]
 1158    00000006 0943                  ORRS            n, n, n
 1159    00000008 01D0                  BEQ             NSLEN_DONE
 1160    0000000A 401C                  ADDS            t, t, #1
 1161    0000000C FAE7                  B               NSLEN_LOOP
 1162                           
 1163                           NSLEN_DONE:
 1164                                   TPUSH
 1164                                   PUSHt   // push t to p, pre decrement p
 1164.1  0000000E 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1164.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1164.3                         //      STR     t, [p]
 1164.4                                 ENDM
 1164                                   NEXT
 1164.1                         // ARMv7-M Thumb = .+5
 1164.2  00000012 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1164.3                         // ARMv6-M Thumb = .+4
 1164.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1164                                   NEXT1
 1164.1  00000016 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1164.2  0000001A 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1164.3  0000001E 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1164.4                         // ARMv6-M Thumb = .+4
 1164.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1164.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1164.7                                 ENDM
 1164.8                                 ENDM
 1164.9                                 ENDM
 1165                           
 1166                           
 1167                           //      FORGET FORGET:  ( -- )
 1168                           //      PRINTS NEW HERE IF SUCCESSFUL. FIXED FIG VERSION MEMORY LEAK.
 1169                           //      Executed in the form:
 1170                           //      FORGET CCcc
 1171                           //      Deletes definition named CCcc from the dictionary with all entries
 1172                           //      physically following it. In fig-FORTH, an error message will occur
 1173                           //      if the CURRENT and CONTEXT vocabularies are not currently the same.
 1174                           //      MODIFIED: To update Current along with context and reset DP,
 1175                           //      and execute .DS and .VS
 1176                           
 1177                            SECTION .text : CONST (2)
 1178                           FORGET_NFA:
 1179    00000000 86                    DC8     0x86
 1180    00000001 464F524745            DC8     'FORGE'
 1181    00000006 D4                    DC8     'T'+0x80
 1182    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 1183    00000008 ........              DC32    NULLSTRLEN_NFA
 1184                           FORGET:
 1185    0000000C ........              DC32    DOCOL
 1186    00000010 ........              DC32    TICK                    // \ -- pfa ELSE error message
 1187    00000014 ........              DC32    DUP
 1188    00000018 ........00000         DC32    LIT, FLASH_SPAGE        // DONT FORGET FISH WORDS SAVED IN FLASH
                  208          
 1189    00000020 ........              DC32    LESSTHAN
 1190    00000024 .............         DC32    LIT, msg_forget_fish
                  ...          
 1191    0000002C ........              DC32    QERROR                  // \ f nullstr-addr --
 1192    00000030 ........              DC32    DUP
 1193    00000034 ........00001         DC32    LIT, FLASH_PPAGE        // DONT FORGET USER WORDS IN FLASH
                  008          
 1194    0000003C ........              DC32    LESSTHAN
 1195    00000040 .............         DC32    LIT, msg_forget_saved
                  ...          
 1196    00000048 ........              DC32    QERROR                  // \ f nullstr-addr --
 1197                           //      MOVE NFA update of the DP to after Currrent and Context
 1198    0000004C ........              DC32    DUP                     // PFA PFA --
 1199    00000050 ........              DC32    LFA                     // PFA LFA --
 1200                           
 1201                           // VAR space reclamation starts here:
 1202                           // PFA LFA --
 1203    00000054 ........              DC32    TOR                     // LFA_BOT
 1204                           
 1205                           VS_RECVR_LOOP:
 1206    00000058 .............         DC32    LATEST, PFA, LFA        // LFA_TOP
                  ...........  
 1207    00000064 .............         DC32    DUP, AT                 // LFA NEXT_LFA
                  ...          
 1208    0000006C .............         DC32    CURRENT_SV, STORE       // SET NEXT WORD TO CHECK
                  ...          
 1209    00000074 .............         DC32    DUP, FOURP, AT          // GET CFA
                  ...........  
 1210    00000080 .............         DC32    LIT, DOVAR, EQUAL       // IS IT A DOVAR
                  ...........  
 1211    0000008C ........              DC32    ZBRAN
 1212    00000090 14000000              DC32     VS_RECVR_NEXT-.
 1213                                   
 1214    00000094 ........FCFFF         DC32    LIT, -4, UP_SV, PSTORE  // DECREMENT UP
                  FFF..........
                  ......       
 1215                           
 1216                           VS_RECVR_NEXT:
 1217    000000A4 .............         DC32    R, EQUAL
                  ...          
 1218    000000AC ........              DC32    ZBRAN
 1219    000000B0 A8FFFFFF              DC32     VS_RECVR_LOOP-.
 1220                           
 1221    000000B4 ........              DC32    RFROM
 1222                           // VAR SPACE RECLAMATION DONE
 1223                           
 1224                           // PFA LFA --
 1225    000000B8 ........              DC32    AT              // LFA
 1226    000000BC ........              DC32    CURRENT_SV
 1227    000000C0 ........              DC32    STORE
 1228    000000C4 ........              DC32    NFA             // FROM PFA
 1229    000000C8 ........              DC32    DP_SV
 1230    000000CC ........              DC32    STORE
 1231    000000D0 .............         DC32    DOTVARSPACE, DOTDICTSPACE
                  ...          
 1232    000000D8 ........              DC32    SEMIS
 1233                           
 1234                           
 1235                           //      BYE BYE: ( -- ) COLD RESTART WITH SERIAL INITIALIZATION
 1236                           
 1237                            SECTION .text : CONST (2)
 1238                           BYE_NFA:
 1239    00000000 83                    DC8     0x83
 1240    00000001 4259                  DC8     'BY'
 1241    00000003 C5                    DC8     'E'+0x80
 1242                            ALIGNROM 2,0xFFFFFFFF
 1243    00000004 ........              DC32    FORGET_NFA
 1244                           BYE:
 1245    00000008 ........              DC32    .+5
 1246                            //SECTION .text : CODE (2)
 1247    0000000C ........              B        FM4_WARM //__iar_program_start // STM32Fx_COLD_FISH 
 1248                                   //B       STM32Fx_COLD_FISH      // __iar_program_start
 1249                            LTORG
 1250                           
 1251                           
 1252                           //      ABORT ABORT:    ( -- )
 1253                           //      Clear the stacks, zero out and execute RUN or QUIT
 1254                           //      DOES NOT RESET DICTIONAIRY. SEE COLD.
 1255                           
 1256                            SECTION .text : CONST (2)
 1257                           ABORT_NFA:
 1258    00000000 85                    DC8     0x85
 1259    00000001 41424F52              DC8     'ABOR'
 1260    00000005 D4                    DC8     'T'+0x80
 1261    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1262    00000008 ........              DC32    BYE_NFA
 1263                           ABORT:
 1264    0000000C ........              DC32    DOCOL
 1265    00000010 ........              DC32    SPSTO
 1266    00000014 ........              DC32    RPSTO
 1267                           #ifdef IO2TP
 1272                           #endif
 1273    00000018 ........              DC32    zero_OUT
 1274                           //      DC32    QSTACK  // IF STACK error abort using QERROR->ERROR
 1275                           
 1276                           // LOOK UP RUN AND EXEC IT
 1277    0000001C .............         DC32    LIT, msg_RUN
                  ...          
 1278    00000024 ........              DC32    LATEST
 1279                           //ABORT_BP1_B4_PFIND_RUN:
 1280                           // DC32 NOOP
 1281    00000028 ........              DC32    PFIND   // 0 OR pfa len 1
 1282    0000002C ........              DC32    ZBRAN
 1283    00000030 10000000              DC32      ABORT_QUIT-.
 1284                           
 1285    00000034 ........              DC32    DROP    // LEN
 1286    00000038 .............         DC32    CFA, EXEC
                  ...          
 1287                           ABORT_QUIT:
 1288                           //      DC32    SEMIC_CREATE // Use ERROR if need to recover from bad definition
 1289    00000040 ........              DC32    QUIT    // OI
 1290                           
 1291                           
 1292                           //      COLD COLD:      ( -- )  MODIFIED:
 1293                           //      FIGISH SYSTEM COLD = WARM (INIT RAMVARSPACE) -> type signon MSG ->ABORT
 1294                           //      CLEARS DICTIONAIRY. SEE ABORT.
 1295                           
 1296                            SECTION .text : CONST (2)
 1297                           COLD_NFA:
 1298    00000000 84                    DC8     0x84
 1299    00000001 434F4C                DC8     'COL'
 1300    00000004 C4                    DC8     'D'+0x80
 1301    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1302    00000008 ........              DC32    ABORT_NFA
 1303                           COLD:
 1304    0000000C ........              DC32    DOCOL
 1305    00000010 ........              DC32    WARM            // FISH System VAR init.
 1306    00000014 ........              DC32    SIGNON
 1307    00000018 ........              DC32    ABORT
 1308                           
 1309                           
 1310                           //=============================== WORDCAT ====================================//
 1311                           //NOEXEC HEADERFORWORDCATEGORIES
 1312                           //      WC_FISH_SYS: = FISH SYSTEM CATEGORY
 1313                           
 1314                            SECTION .text : CONST (2)
 1315                           WC_FISH_SYS_NFA:
 1316    00000000 90                    DC8     0x80+4+12
 1317    00000001 0D0A                  DC8     0x0D, 0x0A
 1318    00000003 4649534820537         DC8     'FISH System:'
                  97374656D3A  
 1319    0000000F 0D8A                  DC8     0x0D, 0x0A+0x80
 1320    00000011 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1321    00000014 ........              DC32    COLD_NFA
 1322                           
 1323                           
 1324                           //----------------------------- DOTSTACK SECTION -------------------------------
 1325                           
 1326                           //      .SH DOTSHEX:    ( -- )
 1327                           //      Nondestructively print items on stack in HEX, preserving base.
 1328                           //      Prints TOS 1rst, i.e. TOS, NOS, etc.
 1329                           
 1330                            SECTION .text : CONST (2)
 1331                           DOTSHEX_NFA:
 1332    00000000 83                    DC8     0x83
 1333    00000001 2E53                  DC8     '.S'
 1334    00000003 C8                    DC8     'H'+0x80
 1335                            ALIGNROM 2,0xFFFFFFFF
 1336    00000004 ........              DC32    WC_FISH_SYS_NFA
 1337                           DOTSHEX:
 1338    00000008 ........              DC32    DOCOL
 1339    0000000C ........10000         DC32    LIT, 16, DOTSBASE
                  000........  
 1340    00000018 ........              DC32    SEMIS
 1341                           
 1342                           
 1343                           //      .SD DOTSDEC:    ( -- )
 1344                           //      Nondestructively print items on stack in DECIMAL, preserving base.
 1345                           //      Prints TOS 1rst, i.e. TOS, NOS, etc.
 1346                           
 1347                            SECTION .text : CONST (2)
 1348                           DOTSDEC_NFA:
 1349    00000000 83                    DC8     0x83
 1350    00000001 2E53                  DC8     '.S'
 1351    00000003 C4                    DC8     'D'+0x80
 1352                            ALIGNROM 2,0xFFFFFFFF
 1353    00000004 ........              DC32    DOTSHEX_NFA
 1354                           DOTSDEC:
 1355    00000008 ........              DC32    DOCOL
 1356    0000000C ........0A000         DC32    LIT, 10, DOTSBASE
                  000........  
 1357    00000018 ........              DC32    SEMIS
 1358                           
 1359                           
 1360                           //      .SB DOTSBIN:    ( -- )
 1361                           //      Nondestructively print items on stack in BINARY, preserving base.
 1362                           //      Prints TOS 1rst, i.e. TOS, NOS, etc.
 1363                           
 1364                            SECTION .text : CONST (2)
 1365                           DOTSBIN_NFA:
 1366    00000000 83                    DC8     0x83
 1367    00000001 2E53                  DC8     '.S'
 1368    00000003 C2                    DC8     'B'+0x80
 1369                            ALIGNROM 2,0xFFFFFFFF
 1370    00000004 ........              DC32    DOTSDEC_NFA
 1371                           DOTSBIN:
 1372    00000008 ........              DC32    DOCOL
 1373    0000000C .............         DC32    TWO, DOTSBASE
                  ...          
 1374    00000014 ........              DC32    SEMIS
 1375                           
 1376                           
 1377                           //      .S DOTS:        ( -- )
 1378                           //      Nondestructively print items on stack in current base.
 1379                           //      Prints TOS 1rst, i.e. TOS, NOS, etc.
 1380                           
 1381                            SECTION .text : CONST (2)
 1382                           DOTS_NFA:
 1383    00000000 82                    DC8     0x82
 1384    00000001 2E                    DC8     '.'
 1385    00000002 D3                    DC8     'S'+0x80
 1386    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 1387    00000004 ........              DC32    DOTSBIN_NFA
 1388                           DOTS:
 1389    00000008 ........              DC32    DOCOL
 1390    0000000C .............         DC32    INITSO_SV, AT, SPAT, FOURP
                  .............
                  ......       
 1391    0000001C .............         DC32    EQUAL, ZEQU, ZBRAN
                  ...........  
 1392    00000028 68000000              DC32    DOTSEND-.                       // IF NOTHING ON STACK
 1393                           
 1394    0000002C ........              DC32    PDOTQ
 1395    00000030 05                    DC8     5
 1396    00000031 544F533E20            DC8     'TOS> '
 1397    00000036 FFFF           ALIGNROM 2,0xFFFFFFFF
 1398                                 
 1399    00000038 .............         DC32    INITSO_SV, AT, SPAT, FOURP
                  .............
                  ......       
 1400    00000048 ........              DC32    XDO
 1401                           
 1402                           DOTSLOOP:
 1403    0000004C .............         DC32    I, AT
                  ...          
 1404    00000054 .............         DC32    BASE_SV, AT
                  ...          
 1405    0000005C ........0A000         DC32    LIT, 10, EQUAL                  // 
                  000........  
 1406    00000068 ........              DC32    ZBRAN                           // NOT = DECIMAL
 1407    0000006C 10000000              DC32    DBSUSEDUDOT-.
 1408    00000070 ........              DC32    DOT_BASE_SUFFIX
 1409    00000074 ........              DC32    BRAN
 1410    00000078 08000000              DC32    DBSUSEDOT-.
 1411                           
 1412                           DBSUSEDUDOT:
 1413    0000007C ........              DC32    UDOT_BASE_SUFFIX
 1414                           
 1415                           DBSUSEDOT:
 1416    00000080 ........              DC32    SPACE
 1417    00000084 .............         DC32    FOUR, XPLOOP
                  ...          
 1418    0000008C C0FFFFFF              DC32    DOTSLOOP-.
 1419                           
 1420                           DOTSEND:
 1421    00000090 ........              DC32    SEMIS
 1422                           
 1423                           
 1424                           //      2DUP TDUP:      ( n2 n1 -- n2 n1 n2 n1 )
 1425                           //      Duplicate top two stack items. The prefix 2 convention means
 1426                           //      an operation on the top two stack items.
 1427                           
 1428                            SECTION .text : CONST (2)
 1429                           TDUP_NFA:
 1430    00000000 84                    DC8     0x84
 1431    00000001 324455                DC8     '2DU'
 1432    00000004 D0                    DC8     'P'+0x80
 1433    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1434    00000008 ........              DC32    DOTS_NFA
 1435                           TDUP:
 1436    0000000C ........              DC32    .+5
 1437                            SECTION .text : CODE (2)
 1438                           // TDUP: OPT by picking pops
 1439    00000000 3868                  LDR     t, [p]          //
 1440    00000002 7A68                  LDR     w, [p, #4]      //
 1441                                   DPUSH                   // 
 1441                                   PUSHw   // push w to p, post decrement p
 1441.1  00000004 47F8042D              STR     w, [p, #-4]!
 1441.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 1441.3                         //      STR     w, [p]
 1441.4                                 ENDM
 1441                                   TPUSH
 1441                                   PUSHt   // push t to p, pre decrement p
 1441.1  00000008 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1441.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1441.3                         //      STR     t, [p]
 1441.4                                 ENDM
 1441                                   NEXT
 1441.1                         // ARMv7-M Thumb = .+5
 1441.2  0000000C 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1441.3                         // ARMv6-M Thumb = .+4
 1441.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1441                                   NEXT1
 1441.1  00000010 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1441.2  00000014 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1441.3  00000018 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1441.4                         // ARMv6-M Thumb = .+4
 1441.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1441.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1441.7                                 ENDM
 1441.8                                 ENDM
 1441.9                                 ENDM
 1441.10                                ENDM
 1442                           
 1443                           
 1444                           //      -DUP ZNDUP:     ( n1 -- n1 (if zero)
 1445                           //                      ( n1 -- n1 n1 (non-zero)
 1446                           //      Reproduce n1 only if it is non-zero. Used in type andSPACES.
 1447                           //      This is usually used to copy a value just before IF, to eliminate
 1448                           //      the need for an ELSE part to drop it. 
 1449                           
 1450                            SECTION .text : CONST (2)
 1451                           DDUP_NFA:
 1452    00000000 84                    DC8     0x84
 1453    00000001 2D4455                DC8     '-DU'
 1454    00000004 D0                    DC8     'P'+0x80
 1455    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1456    00000008 ........              DC32    TDUP_NFA
 1457                           ZNDUP:
 1458    0000000C ........              DC32    DOCOL
 1459    00000010 ........              DC32    DUP
 1460    00000014 ........              DC32    ZBRAN   // IF
 1461    00000018 08000000              DC32    DDUP1-.
 1462                           
 1463    0000001C ........              DC32    DUP     //endif
 1464                           DDUP1:
 1465    00000020 ........              DC32    SEMIS
 1466                           
 1467                           
 1468                           //      ROT ROT: ( nl n2 n3 --- n2 n3 nl )
 1469                           //      Rotate the top three values on the stack, bringing the third to the top.
 1470                           
 1471                            SECTION .text : CONST (2)
 1472                           ROT_NFA:
 1473    00000000 83                    DC8     0x83
 1474    00000001 524F                  DC8     'RO'
 1475    00000003 D4                    DC8     'T'+0x80
 1476                            ALIGNROM 2,0xFFFFFFFF
 1477    00000004 ........              DC32    DDUP_NFA
 1478                           ROT:
 1479    00000008 ........              DC32    .+5
 1480                            SECTION .text : CODE (2)
 1481                                   POP2w
 1481.1  00000000 57F8042B              LDR     w, [p],#4
 1481.2                         //      LDR     w, [p]
 1481.3                         //      ADDS    p, p, #4
 1481.4                                 ENDM
 1482                                   POP2n
 1482.1  00000004 57F8041B              LDR     n, [p],#4
 1482.2                         //      LDR     n, [p]
 1482.3                         //      ADDS    p, p, #4
 1482.4                                 ENDM
 1483                           #ifdef TOSCT
 1485                           #endif
 1486                                   POP2t
 1486.1  00000008 57F8040B              LDR     t, [p],#4       // Post-increment
 1486.2                         //#ifndef TOSCT
 1486.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 1486.4                         //#endif
 1486.5                         //      ADDS    p, p, #4
 1486.6                                 ENDM
 1487                                   PUSHn
 1487.1  0000000C 47F8041D              STR     n, [p, #-4]!
 1487.2                         //      SUBS    p, p, #4        // push n to p, pre decrement p
 1487.3                         //      STR     n, [p]
 1487.4                                 ENDM
 1488                                   DPUSH                   //  --  LSW MSW )
 1488                                   PUSHw   // push w to p, post decrement p
 1488.1  00000010 47F8042D              STR     w, [p, #-4]!
 1488.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 1488.3                         //      STR     w, [p]
 1488.4                                 ENDM
 1488                                   TPUSH
 1488                                   PUSHt   // push t to p, pre decrement p
 1488.1  00000014 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1488.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1488.3                         //      STR     t, [p]
 1488.4                                 ENDM
 1488                                   NEXT
 1488.1                         // ARMv7-M Thumb = .+5
 1488.2  00000018 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1488.3                         // ARMv6-M Thumb = .+4
 1488.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1488                                   NEXT1
 1488.1  0000001C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1488.2  00000020 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1488.3  00000024 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1488.4                         // ARMv6-M Thumb = .+4
 1488.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1488.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1488.7                                 ENDM
 1488.8                                 ENDM
 1488.9                                 ENDM
 1488.10                                ENDM
 1489                           
 1490                           
 1491                           //      I I:    ( -- n )
 1492                           //      Used within a DO-LOOP to copy the loop index to the stack. Other use
 1493                           //      is implementation dependent.
 1494                           //      See R.
 1495                           
 1496                            SECTION .text : CONST (2)
 1497                           I_NFA:
 1498    00000000 81                    DC8     0x81
 1499    00000001 C9                    DC8     'I'+0x80
 1500    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 1501    00000004 ........              DC32    ROT_NFA
 1502                           I:
 1503    00000008 ........              DC32    .+5
 1504                            SECTION .text : CODE (2)
 1505    00000000 3068                  LDR     t, [r]  // GET INDEX VALUE
 1506                                   TPUSH
 1506                                   PUSHt   // push t to p, pre decrement p
 1506.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1506.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1506.3                         //      STR     t, [p]
 1506.4                                 ENDM
 1506                                   NEXT
 1506.1                         // ARMv7-M Thumb = .+5
 1506.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1506.3                         // ARMv6-M Thumb = .+4
 1506.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1506                                   NEXT1
 1506.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1506.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1506.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1506.4                         // ARMv6-M Thumb = .+4
 1506.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1506.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1506.7                                 ENDM
 1506.8                                 ENDM
 1506.9                                 ENDM
 1507                           
 1508                           
 1509                           //      SP@ SPAT:       ( -- addr )
 1510                           //      \ -- addr = Current TOP of the parameter stack (p) )
 1511                           //      Place the address of the TOP of the parameter stack (p)
 1512                           //      on the parameter stack (p) as it was before RP@ was executed.
 1513                           //      e.g.  1  2  SP@  @  .   .   .     would type 2  2  1
 1514                           
 1515                            SECTION .text : CONST (2)
 1516                           SPAT_NFA:
 1517    00000000 83                    DC8     0x83
 1518    00000001 5350                  DC8     'SP'
 1519    00000003 C0                    DC8     '@'+0x80
 1520                            ALIGNROM 2,0xFFFFFFFF
 1521    00000004 ........              DC32    I_NFA
 1522                           SPAT:
 1523    00000008 ........              DC32    .+5
 1524                            SECTION .text : CODE (2)
 1525    00000000 3846                  MOV     t, p
 1526                                   TPUSH
 1526                                   PUSHt   // push t to p, pre decrement p
 1526.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1526.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1526.3                         //      STR     t, [p]
 1526.4                                 ENDM
 1526                                   NEXT
 1526.1                         // ARMv7-M Thumb = .+5
 1526.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1526.3                         // ARMv6-M Thumb = .+4
 1526.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1526                                   NEXT1
 1526.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1526.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1526.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1526.4                         // ARMv6-M Thumb = .+4
 1526.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1526.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1526.7                                 ENDM
 1526.8                                 ENDM
 1526.9                                 ENDM
 1527                           
 1528                           
 1529                           //      RP@ RPAT:       ( -- addr )
 1530                           //      \ -- addr = Current TOP of the Return Stack (r) )
 1531                           //      Place the address of the TOP of the return stack (r)
 1532                           //      on the parameter stack (p) as it was before RP@ was executed.
 1533                           //      e.g.  1 >R  2 >R  RP@  @  .   .   . would type 2  2  1
 1534                           
 1535                            SECTION .text : CONST (2)
 1536                           RPAT_NFA:
 1537    00000000 83                    DC8     0x83
 1538    00000001 5250                  DC8     'RP'
 1539    00000003 C0                    DC8     '@'+0x80
 1540                            ALIGNROM 2,0xFFFFFFFF
 1541    00000004 ........              DC32    SPAT_NFA
 1542                           RPAT:
 1543    00000008 ........              DC32    .+5
 1544                            SECTION .text : CODE (2)
 1545    00000000 3046                  MOV     t, r
 1546                                   TPUSH
 1546                                   PUSHt   // push t to p, pre decrement p
 1546.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1546.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1546.3                         //      STR     t, [p]
 1546.4                                 ENDM
 1546                                   NEXT
 1546.1                         // ARMv7-M Thumb = .+5
 1546.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1546.3                         // ARMv6-M Thumb = .+4
 1546.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1546                                   NEXT1
 1546.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1546.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1546.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1546.4                         // ARMv6-M Thumb = .+4
 1546.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1546.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1546.7                                 ENDM
 1546.8                                 ENDM
 1546.9                                 ENDM
 1547                           
 1548                           
 1549                           //      LEAVE LEAVE:    ( -- )
 1550                           //      Force termination of a DO-LOOP at the next opportunity by setting
 1551                           //      the loop limit equal to the current value of the index. The index
 1552                           //      itself remains unchanged, and execution proceeds until LOOP
 1553                           //      or +LOOP is encountered.
 1554                           
 1555                            SECTION .text : CONST (2)
 1556                           LEAVE_NFA:
 1557    00000000 85                    DC8     0x85
 1558    00000001 4C454156              DC8     'LEAV'
 1559    00000005 C5                    DC8     'E'+0x80
 1560    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1561                           //      DC32    RPSTO_NFA
 1562    00000008 ........              DC32    RPAT_NFA
 1563                           LEAVE:
 1564    0000000C ........              DC32    .+5
 1565                            SECTION .text : CODE (2)
 1566    00000000 3268                  LDR     w, [r]          // GET Index
 1567    00000002 7260                  STR     w, [r, #4]  // Store it at Limit
 1568                                   NEXT
 1568.1                         // ARMv7-M Thumb = .+5
 1568.2  00000004 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1568.3                         // ARMv6-M Thumb = .+4
 1568.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1568                                   NEXT1
 1568.1  00000008 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1568.2  0000000C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1568.3  00000010 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1568.4                         // ARMv6-M Thumb = .+4
 1568.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1568.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1568.7                                 ENDM
 1568.8                                 ENDM
 1569                           
 1570                           
 1571                           //      R> RFROM:       ( -- n )
 1572                           //      Remove the top value from the return stack and leave it on the
 1573                           //      computation stack. See >R and R.
 1574                           
 1575                            SECTION .text : CONST (2)
 1576                           RFROM_NFA:
 1577    00000000 82                    DC8     0x82
 1578    00000001 52                    DC8     'R'
 1579    00000002 BE                    DC8     '>'+0x80
 1580    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 1581    00000004 ........              DC32    LEAVE_NFA
 1582                           RFROM:
 1583    00000008 ........              DC32    .+5
 1584                            SECTION .text : CODE (2)
 1585                                   POPr2t
 1585.1  00000000 56F8040B              LDR     t, [r],#4
 1585.2                         //      LDR     t, [r]
 1585.3                         //      ADDS    r, r, #4
 1585.4                                 ENDM
 1586                                   TPUSH
 1586                                   PUSHt   // push t to p, pre decrement p
 1586.1  00000004 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1586.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1586.3                         //      STR     t, [p]
 1586.4                                 ENDM
 1586                                   NEXT
 1586.1                         // ARMv7-M Thumb = .+5
 1586.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1586.3                         // ARMv6-M Thumb = .+4
 1586.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1586                                   NEXT1
 1586.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1586.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1586.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1586.4                         // ARMv6-M Thumb = .+4
 1586.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1586.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1586.7                                 ENDM
 1586.8                                 ENDM
 1586.9                                 ENDM
 1587                           
 1588                           
 1589                           //      R R:    ( -- n )
 1590                           //      Copy the top of the return stack to the computation stack.
 1591                           
 1592                            SECTION .text : CONST (2)
 1593                           R_NFA:
 1594    00000000 81                    DC8     0x81
 1595    00000001 D2                    DC8     'R'+0x80
 1596    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 1597    00000004 ........              DC32    RFROM_NFA
 1598                           R:
 1599    00000008 ........              DC32    .+5
 1600                            SECTION .text : CODE (2)
 1601    00000000 3068                  LDR     t, [r]  // Get Index
 1602                                   TPUSH
 1602                                   PUSHt   // push t to p, pre decrement p
 1602.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1602.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1602.3                         //      STR     t, [p]
 1602.4                                 ENDM
 1602                                   NEXT
 1602.1                         // ARMv7-M Thumb = .+5
 1602.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1602.3                         // ARMv6-M Thumb = .+4
 1602.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1602                                   NEXT1
 1602.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1602.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1602.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1602.4                         // ARMv6-M Thumb = .+4
 1602.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1602.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1602.7                                 ENDM
 1602.8                                 ENDM
 1602.9                                 ENDM
 1603                           
 1604                           //      >R TOR: ( n -- )
 1605                           //      Remove a number from the computation stack and place as the most
 1606                           //      accessable on the return stack. Use should be balanced with R> in
 1607                           //      the same definition.
 1608                           
 1609                            SECTION .text : CONST (2)
 1610                           TOR_NFA:
 1611    00000000 82                    DC8     0x82
 1612    00000001 3E                    DC8     '>'
 1613    00000002 D2                    DC8     'R'+0x80
 1614    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 1615    00000004 ........              DC32    R_NFA
 1616                           TOR:
 1617    00000008 ........              DC32    .+5
 1618                            SECTION .text : CODE (2)
 1619                                   POP2n   // preserve TOS
 1619.1  00000000 57F8041B              LDR     n, [p],#4
 1619.2                         //      LDR     n, [p]
 1619.3                         //      ADDS    p, p, #4
 1619.4                                 ENDM
 1620                                   PUSHn2r
 1620.1  00000004 46F8041D              STR     n, [r, #-4]!
 1620.2                         //      SUBS    r, r, #4        //  push t to r, pre decrement r
 1620.3                         //      STR     n, [r]
 1620.4                                 ENDM
 1621                           #ifdef TOSCT
 1623                           #endif
 1624                                   NEXT
 1624.1                         // ARMv7-M Thumb = .+5
 1624.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1624.3                         // ARMv6-M Thumb = .+4
 1624.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1624                                   NEXT1
 1624.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1624.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1624.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1624.4                         // ARMv6-M Thumb = .+4
 1624.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1624.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1624.7                                 ENDM
 1624.8                                 ENDM
 1625                           
 1626                           
 1627                           //      OVER OVER:      ( nl n2 -- nl n2 n1 )
 1628                           //      Copy the second stack value, placing it as the new top.
 1629                           
 1630                            SECTION .text : CONST (2)
 1631                           OVER_NFA:
 1632    00000000 84                    DC8     0x84
 1633    00000001 4F5645                DC8     'OVE'
 1634    00000004 D2                    DC8     'R'+0x80
 1635    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1636    00000008 ........              DC32    TOR_NFA
 1637                           OVER:
 1638    0000000C ........              DC32    .+5
 1639                            SECTION .text : CODE (2)
 1640                                   POP2w           // n2
 1640.1  00000000 57F8042B              LDR     w, [p],#4
 1640.2                         //      LDR     w, [p]
 1640.3                         //      ADDS    p, p, #4
 1640.4                                 ENDM
 1641                           #ifdef TOSCT
 1645                           #else
 1646                                   POP2t           // n1
 1646.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 1646.2                         //#ifndef TOSCT
 1646.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 1646.4                         //#endif
 1646.5                         //      ADDS    p, p, #4
 1646.6                                 ENDM
 1647                           #endif
 1648                                   PUSHt           // -- n1 )
 1648.1  00000008 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1648.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1648.3                         //      STR     t, [p]
 1648.4                                 ENDM
 1649                                   DPUSH           //  --  LSW MSW )
 1649                                   PUSHw   // push w to p, post decrement p
 1649.1  0000000C 47F8042D              STR     w, [p, #-4]!
 1649.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 1649.3                         //      STR     w, [p]
 1649.4                                 ENDM
 1649                                   TPUSH
 1649                                   PUSHt   // push t to p, pre decrement p
 1649.1  00000010 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1649.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1649.3                         //      STR     t, [p]
 1649.4                                 ENDM
 1649                                   NEXT
 1649.1                         // ARMv7-M Thumb = .+5
 1649.2  00000014 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1649.3                         // ARMv6-M Thumb = .+4
 1649.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1649                                   NEXT1
 1649.1  00000018 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1649.2  0000001C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1649.3  00000020 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1649.4                         // ARMv6-M Thumb = .+4
 1649.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1649.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1649.7                                 ENDM
 1649.8                                 ENDM
 1649.9                                 ENDM
 1649.10                                ENDM
 1650                           
 1651                           
 1652                           //      DROP DROP:      ( n1 -- )
 1653                           //      Drop n1 from the stack.
 1654                           
 1655                            SECTION .text : CONST (2)
 1656                           DROP_NFA:
 1657    00000000 84                    DC8     0x84
 1658    00000001 44524F                DC8     'DRO'
 1659    00000004 D0                    DC8     'P'+0x80
 1660    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1661    00000008 ........              DC32    OVER_NFA
 1662                           DROP:
 1663    0000000C ........              DC32    .+5
 1664                            SECTION .text : CODE (2)
 1665                           #ifdef TOSCT
 1669                           #else // DROP:
 1670                           //        POP2t         // Opt to just do p
 1671    00000000 3F1D                  ADDS    p, p, #4
 1672                           
 1673                           #endif
 1674                                   NEXT
 1674.1                         // ARMv7-M Thumb = .+5
 1674.2  00000002 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1674.3                         // ARMv6-M Thumb = .+4
 1674.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1674                                   NEXT1
 1674.1  00000006 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1674.2  0000000A 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1674.3  0000000E 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1674.4                         // ARMv6-M Thumb = .+4
 1674.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1674.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1674.7                                 ENDM
 1674.8                                 ENDM
 1675                           
 1676                           
 1677                           //      SWAP SWAP:      ( nl n2 -- n2 n1 )
 1678                           //      Exchange the top two values On the stack.
 1679                           
 1680                            SECTION .text : CONST (2)
 1681                           SWAP_NFA:
 1682    00000000 84                    DC8     0x84
 1683    00000001 535741                DC8     'SWA'
 1684    00000004 D0                    DC8     'P'+0x80
 1685    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1686    00000008 ........              DC32    DROP_NFA
 1687                           SWAP:
 1688    0000000C ........              DC32    .+5
 1689                            SECTION .text : CODE (2)
 1690                           #ifdef TOSCT
 1694                           #else // SWAP:
 1695                                   POP2w           // n2
 1695.1  00000000 57F8042B              LDR     w, [p],#4
 1695.2                         //      LDR     w, [p]
 1695.3                         //      ADDS    p, p, #4
 1695.4                                 ENDM
 1696                                   POP2t           // n1
 1696.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 1696.2                         //#ifndef TOSCT
 1696.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 1696.4                         //#endif
 1696.5                         //      ADDS    p, p, #4
 1696.6                                 ENDM
 1697                           #endif
 1698                                   DPUSH           //  --  LSW MSW )
 1698                                   PUSHw   // push w to p, post decrement p
 1698.1  00000008 47F8042D              STR     w, [p, #-4]!
 1698.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 1698.3                         //      STR     w, [p]
 1698.4                                 ENDM
 1698                                   TPUSH
 1698                                   PUSHt   // push t to p, pre decrement p
 1698.1  0000000C 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1698.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1698.3                         //      STR     t, [p]
 1698.4                                 ENDM
 1698                                   NEXT
 1698.1                         // ARMv7-M Thumb = .+5
 1698.2  00000010 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1698.3                         // ARMv6-M Thumb = .+4
 1698.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1698                                   NEXT1
 1698.1  00000014 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1698.2  00000018 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1698.3  0000001C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1698.4                         // ARMv6-M Thumb = .+4
 1698.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1698.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1698.7                                 ENDM
 1698.8                                 ENDM
 1698.9                                 ENDM
 1698.10                                ENDM
 1699                           
 1700                           
 1701                           //      DUP DUP:        ( n1 -- n1 n1 )
 1702                           //      Duplicate the value n1 on the stack.
 1703                           
 1704                            SECTION .text : CONST (2)
 1705                           DUP_NFA:
 1706    00000000 83                    DC8     0x83
 1707    00000001 4455                  DC8     'DU'
 1708    00000003 D0                    DC8     'P'+0x80
 1709                            ALIGNROM 2,0xFFFFFFFF
 1710    00000004 ........              DC32    SWAP_NFA
 1711                           DUP:
 1712    00000008 ........              DC32    .+5
 1713                            SECTION .text : CODE (2)
 1714                           //#ifdef TOSCT
 1715                           // NO NEED TO REFRESH t ?
 1716                           //#else DUP:
 1717                           // OPT by picking pops
 1718    00000000 3868                  LDR     t, [p]
 1719                           //#endif
 1720                                   TPUSH
 1720                                   PUSHt   // push t to p, pre decrement p
 1720.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1720.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1720.3                         //      STR     t, [p]
 1720.4                                 ENDM
 1720                                   NEXT
 1720.1                         // ARMv7-M Thumb = .+5
 1720.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1720.3                         // ARMv6-M Thumb = .+4
 1720.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1720                                   NEXT1
 1720.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1720.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1720.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1720.4                         // ARMv6-M Thumb = .+4
 1720.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1720.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1720.7                                 ENDM
 1720.8                                 ENDM
 1720.9                                 ENDM
 1721                           
 1722                           //=============================== WORDCAT ====================================//
 1723                           //NOEXEC HEADERFORWORDCATEGORIES
 1724                           //      WC_STACK_NFA = STACK STUFF CATEGORY
 1725                           
 1726                            SECTION .text : CONST (2)
 1727                           WC_STACK_NFA:
 1728    00000000 90                    DC8     0x80+4+12
 1729    00000001 0D0A                  DC8     0x0D, 0x0A
 1730    00000003 537461636B205         DC8     'Stack Stuff:'
                  3747566663A  
 1731    0000000F 0D8A                  DC8     0x0D, 0x0A+0x80
 1732    00000011 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1733    00000014 ........              DC32    DUP_NFA
 1734                           
 1735                           
 1736                           //      ANDBITS ANDBITS:        ( addr val -- )
 1737                           
 1738                            SECTION .text : CONST (2)
 1739                           ANDBITS_NFA:
 1740    00000000 87                    DC8     0x87
 1741    00000001 414E44424954          DC8     'ANDBIT'
 1742    00000007 D3                    DC8     'S'+0x80
 1743                            ALIGNROM 2,0xFFFFFFFF
 1744    00000008 ........              DC32    WC_STACK_NFA
 1745                           ANDBITS:
 1746    0000000C ........              DC32    .+5
 1747                            SECTION .text : CODE (2)
 1748                                   POPp2w          // val
 1748.1                                 // as in xeq token on ToS setup for exec
 1748.2  00000000 57F8042B              LDR     w, [p], #4      ; xeq token at ToS
 1748.3                         //      LDM     p!, {w} // fetch memory p points to into {w}, inc p
 1748.4                                 ENDM
 1749                                   POP2n           // addr
 1749.1  00000004 57F8041B              LDR     n, [p],#4
 1749.2                         //      LDR     n, [p]
 1749.3                         //      ADDS    p, p, #4
 1749.4                                 ENDM
 1750    00000008 0868                  LDR     t, [n]  // read [val]
 1751    0000000A 1040                  ANDS    t, t, w // modify val
 1752    0000000C 0860                  STR     t, [n]  // Write val
 1753                                   NEXT
 1753.1                         // ARMv7-M Thumb = .+5
 1753.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1753.3                         // ARMv6-M Thumb = .+4
 1753.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1753                                   NEXT1
 1753.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1753.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1753.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1753.4                         // ARMv6-M Thumb = .+4
 1753.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1753.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1753.7                                 ENDM
 1753.8                                 ENDM
 1754                           
 1755                           
 1756                           //      SETBITS SETBITS:        ( addr val -- ) OR val bits into addr.
 1757                           //      See also CLRBITS.
 1758                           //      Preserves bits at addr - useful for ARM SoC initialization.
 1759                           
 1760                            SECTION .text : CONST (2)
 1761                           SETBITS_NFA:
 1762    00000000 87                    DC8     0x87
 1763    00000001 534554424954          DC8     'SETBIT'
 1764    00000007 D3                    DC8     'S'+0x80
 1765                            ALIGNROM 2,0xFFFFFFFF
 1766    00000008 ........              DC32    ANDBITS_NFA
 1767                           SETBITS:
 1768    0000000C ........              DC32    .+5
 1769                            SECTION .text : CODE (2)
 1770                                   POPp2w          // val
 1770.1                                 // as in xeq token on ToS setup for exec
 1770.2  00000000 57F8042B              LDR     w, [p], #4      ; xeq token at ToS
 1770.3                         //      LDM     p!, {w} // fetch memory p points to into {w}, inc p
 1770.4                                 ENDM
 1771                                   POP2n           // addr
 1771.1  00000004 57F8041B              LDR     n, [p],#4
 1771.2                         //      LDR     n, [p]
 1771.3                         //      ADDS    p, p, #4
 1771.4                                 ENDM
 1772    00000008 0868                  LDR     t, [n]  // read[val]
 1773    0000000A 1043                  ORRS    t, t, w // modify val
 1774    0000000C 0860                  STR     t, [n]  // Write val
 1775                                   NEXT
 1775.1                         // ARMv7-M Thumb = .+5
 1775.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1775.3                         // ARMv6-M Thumb = .+4
 1775.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1775                                   NEXT1
 1775.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1775.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1775.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1775.4                         // ARMv6-M Thumb = .+4
 1775.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1775.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1775.7                                 ENDM
 1775.8                                 ENDM
 1776                           
 1777                           
 1778                           //      CLRBITS CLRBITS:        ( addr val -- )
 1779                           //      XOR val bits into addr. See also SETBITS.
 1780                           //      Preserves bits at addr - useful for ARM SoC initialization.
 1781                           
 1782                            SECTION .text : CONST (2)
 1783                           CLRBITS_NFA:
 1784    00000000 87                    DC8     0x87
 1785    00000001 434C52424954          DC8     'CLRBIT'
 1786    00000007 D3                    DC8     'S'+0x80
 1787                            ALIGNROM 2,0xFFFFFFFF
 1788    00000008 ........              DC32    SETBITS_NFA
 1789                           CLRBITS:
 1790    0000000C ........              DC32    .+5
 1791                            SECTION .text : CODE (2)
 1792                                   POPp2w                  // val
 1792.1                                 // as in xeq token on ToS setup for exec
 1792.2  00000000 57F8042B              LDR     w, [p], #4      ; xeq token at ToS
 1792.3                         //      LDM     p!, {w} // fetch memory p points to into {w}, inc p
 1792.4                                 ENDM
 1793                                   POP2n                   // addr
 1793.1  00000004 57F8041B              LDR     n, [p],#4
 1793.2                         //      LDR     n, [p]
 1793.3                         //      ADDS    p, p, #4
 1793.4                                 ENDM
 1794    00000008 0868                  LDR     t, [n]          // read [val]
 1795    0000000A 9043                  BICS    t, t, w         // modify val  - AND-NOT
 1796    0000000C 0860                  STR     t, [n]          // write val
 1797                                   NEXT
 1797.1                         // ARMv7-M Thumb = .+5
 1797.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1797.3                         // ARMv6-M Thumb = .+4
 1797.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1797                                   NEXT1
 1797.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1797.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1797.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1797.4                         // ARMv6-M Thumb = .+4
 1797.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1797.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1797.7                                 ENDM
 1797.8                                 ENDM
 1798                           
 1799                           
 1800                           //      CMOVE CMOVE:    ( from to count -- )
 1801                           //      Move the specified quantity of bytes beginning at address from to
 1802                           //      address to. The contents of address from is moved first proceeding
 1803                           //      toward high memory. Further specification is necessary on word
 1804                           //      addressing computers.
 1805                           
 1806                            SECTION .text : CONST (2)
 1807                           CMOVE_NFA:
 1808    00000000 85                    DC8     0x85
 1809    00000001 434D4F56              DC8     'CMOV'
 1810    00000005 C5                    DC8     'E'+0x80
 1811    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1812    00000008 ........              DC32    CLRBITS_NFA
 1813                           CMOVE:
 1814    0000000C ........              DC32    .+5
 1815                            SECTION .text : CODE (2)
 1816                                   POP2n //    ldr n, [p],#4      //COUNT
 1816.1  00000000 57F8041B              LDR     n, [p],#4
 1816.2                         //      LDR     n, [p]
 1816.3                         //      ADDS    p, p, #4
 1816.4                                 ENDM
 1817                                   POP2w //    ldr w, [p],#4      //DEST
 1817.1  00000004 57F8042B              LDR     w, [p],#4
 1817.2                         //      LDR     w, [p]
 1817.3                         //      ADDS    p, p, #4
 1817.4                                 ENDM
 1818                                   POP2x //    ldr x, [p],#4      //SOURCE
 1818.1  00000008 57F8043B              LDR     x, [p],#4
 1818.2                         //      LDR     x, [p]
 1818.3                         //      ADDS    p, p, #4
 1818.4                                 ENDM
 1819    0000000C 0029                  CMP     n, #0
 1820    0000000E 07D0                  BEQ     CM2
 1821                           CM1:
 1822                           //not for THUMB
 1823                           //strcpy  LDRB R2, [R1], #1
 1824                           //        STRB R2, [R0], #1
 1825                           //        TST R2, R2      // repeat if R2 is nonzero
 1826                           //        BNE strcpy
 1827    00000010 1878                  LDRB    t, [x]
 1828    00000012 1070                  STRB    t, [w]
 1829    00000014 491E                  SUBS    n, n, #1
 1830    00000016 0029                  CMP     n, #0
 1831    00000018 02D0                  BEQ     CM2
 1832                           
 1833    0000001A 521C                  ADDS    w, w, #1
 1834    0000001C 5B1C                  ADDS    x, x, #1
 1835    0000001E F7D1                  BNE     CM1
 1836                           CM2:
 1837                           #ifdef TOSCT
 1839                           #endif
 1840                                   NEXT
 1840.1                         // ARMv7-M Thumb = .+5
 1840.2  00000020 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1840.3                         // ARMv6-M Thumb = .+4
 1840.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1840                                   NEXT1
 1840.1  00000024 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1840.2  00000028 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1840.3  0000002C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1840.4                         // ARMv6-M Thumb = .+4
 1840.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1840.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1840.7                                 ENDM
 1840.8                                 ENDM
 1841                           
 1842                           
 1843                           //      FILL FILL:      ( addr quan b -- )
 1844                           //      Fill memory at the address with the specified quantity of bytes b.
 1845                           
 1846                            SECTION .text : CONST (2)
 1847                           FILL_NFA:
 1848    00000000 84                    DC8     0x84
 1849    00000001 46494C                DC8     'FIL'
 1850    00000004 CC                    DC8     'L'+0x80
 1851    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1852    00000008 ........              DC32    CMOVE_NFA
 1853                           FILL:
 1854    0000000C ........              DC32    .+5
 1855                            SECTION .text : CODE (2)
 1856                                   POP2t                   // Fill CHAR
 1856.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 1856.2                         //#ifndef TOSCT
 1856.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 1856.4                         //#endif
 1856.5                         //      ADDS    p, p, #4
 1856.6                                 ENDM
 1857                                   POP2n                   // Fill COUNT
 1857.1  00000004 57F8041B              LDR     n, [p],#4
 1857.2                         //      LDR     n, [p]
 1857.3                         //      ADDS    p, p, #4
 1857.4                                 ENDM
 1858                                   POP2w                   // Beginning ADDR
 1858.1  00000008 57F8042B              LDR     w, [p],#4
 1858.2                         //      LDR     w, [p]
 1858.3                         //      ADDS    p, p, #4
 1858.4                                 ENDM
 1859    0000000C 0029                  CMP     n, #0
 1860    0000000E 04D0                  BEQ     FEND            // Count is zero
 1861    00000010 8B18                  ADDS    x, n, w
 1862                           FLOOP:
 1863    00000012 1070                  STRB    t, [w]
 1864    00000014 521C                  ADDS    w, w, #1
 1865    00000016 9A42                  CMP     w, x
 1866    00000018 FBD1                  BNE     FLOOP
 1867                           FEND:
 1868                           #ifdef TOSCT
 1870                           #endif
 1871                                   NEXT
 1871.1                         // ARMv7-M Thumb = .+5
 1871.2  0000001A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1871.3                         // ARMv6-M Thumb = .+4
 1871.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1871                                   NEXT1
 1871.1  0000001E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1871.2  00000022 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1871.3  00000026 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1871.4                         // ARMv6-M Thumb = .+4
 1871.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1871.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1871.7                                 ENDM
 1871.8                                 ENDM
 1872                           
 1873                           
 1874                           //      ERASE ERASE:    ( addr n -- )
 1875                           //      Clear a region of memory to zero from addr over n addresses.
 1876                           
 1877                            SECTION .text : CONST (2)
 1878                           ERASE_NFA:
 1879    00000000 85                    DC8     0x85
 1880    00000001 45524153              DC8     'ERAS'
 1881    00000005 C5                    DC8     'E'+0x80
 1882    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1883    00000008 ........              DC32    FILL_NFA
 1884                           ERASE:
 1885    0000000C ........              DC32    DOCOL
 1886    00000010 ........              DC32    ZERO
 1887    00000014 ........              DC32    FILL
 1888    00000018 ........              DC32    SEMIS
 1889                           
 1890                           
 1891                           //      BLANKS BLANKS:  ( addr count -- )
 1892                           //      Fill an area of memory beginning at addr with blanks (0x20).
 1893                           
 1894                            SECTION .text : CONST (2)
 1895                           BLANKS_NFA:
 1896    00000000 86                    DC8     0x86
 1897    00000001 424C414E4B            DC8     'BLANK'
 1898    00000006 D3                    DC8     'S'+0x80
 1899    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 1900    00000008 ........              DC32    ERASE_NFA
 1901                           BLANKS:
 1902    0000000C ........              DC32    DOCOL
 1903    00000010 ........              DC32    BLANK
 1904    00000014 ........              DC32    FILL
 1905    00000018 ........              DC32    SEMIS
 1906                           
 1907                           
 1908                           //      +! PSTORE:      ( n addr -- )
 1909                           //      Add n to the value at the address.
 1910                           //      Pronounced Plus Store
 1911                           
 1912                            SECTION .text : CONST (2)
 1913                           PSTORE_NFA:
 1914    00000000 82                    DC8     0x82
 1915    00000001 2B                    DC8     '+'
 1916    00000002 A1                    DC8     '!'+0x80
 1917    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 1918    00000004 ........              DC32    BLANKS_NFA
 1919                           PSTORE:
 1920    00000008 ........              DC32    .+5
 1921                            SECTION .text : CODE (2)
 1922                                   POP2n                   // ADDRESS
 1922.1  00000000 57F8041B              LDR     n, [p],#4
 1922.2                         //      LDR     n, [p]
 1922.3                         //      ADDS    p, p, #4
 1922.4                                 ENDM
 1923                           #ifdef TOSCT
 1925                           #endif
 1926                                   POP2t                   // INCREMENT
 1926.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 1926.2                         //#ifndef TOSCT
 1926.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 1926.4                         //#endif
 1926.5                         //      ADDS    p, p, #4
 1926.6                                 ENDM
 1927    00000008 0A68                  LDR     w, [n]
 1928    0000000A 8018                  ADDS    t, t, w
 1929    0000000C 0860                  STR     t, [n]
 1930                                   NEXT
 1930.1                         // ARMv7-M Thumb = .+5
 1930.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1930.3                         // ARMv6-M Thumb = .+4
 1930.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1930                                   NEXT1
 1930.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1930.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1930.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1930.4                         // ARMv6-M Thumb = .+4
 1930.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1930.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1930.7                                 ENDM
 1930.8                                 ENDM
 1931                           
 1932                           
 1933                           //      @ AT:   ( addr -- n )
 1934                           //      Read 32 bit contents of address to TOS.
 1935                           //      Pronounced Fetch, as in Fetch word at addr.
 1936                           
 1937                            SECTION .text : CONST (2)
 1938                           AT_NFA:
 1939    00000000 81                    DC8     0x81
 1940    00000001 C0                    DC8     '@'+0x80 //C0H
 1941    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 1942                           //      DC32    TOGGLE_NFA
 1943    00000004 ........              DC32    PSTORE_NFA
 1944                           AT:
 1945    00000008 ........              DC32    .+5
 1946                            SECTION .text : CODE (2)
 1947                           //#ifdef TOSCT
 1948                           //        LDR     t, [t]
 1949                           //        STR     t, [p]
 1950                           //        NEXT
 1951                           //#else AT:
 1952                                   POP2n
 1952.1  00000000 57F8041B              LDR     n, [p],#4
 1952.2                         //      LDR     n, [p]
 1952.3                         //      ADDS    p, p, #4
 1952.4                                 ENDM
 1953    00000004 0868                  LDR     t, [n]
 1954                                   TPUSH
 1954                                   PUSHt   // push t to p, pre decrement p
 1954.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1954.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1954.3                         //      STR     t, [p]
 1954.4                                 ENDM
 1954                                   NEXT
 1954.1                         // ARMv7-M Thumb = .+5
 1954.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1954.3                         // ARMv6-M Thumb = .+4
 1954.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1954                                   NEXT1
 1954.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1954.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1954.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1954.4                         // ARMv6-M Thumb = .+4
 1954.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1954.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1954.7                                 ENDM
 1954.8                                 ENDM
 1954.9                                 ENDM
 1955                           //#endif
 1956                                   
 1957                           //      C@ CAT: ( addr -- b )
 1958                           //      Leave the 8 bit contents of addr on the stack.
 1959                           //      Pronounced "Char Fetch", as in Fetch byte at addr.
 1960                           
 1961                            SECTION .text : CONST (2)
 1962                           CAT_NFA:
 1963    00000000 82                    DC8     0x82
 1964    00000001 43                    DC8     'C'
 1965    00000002 C0                    DC8     '@'+0x80 //C0H
 1966    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 1967    00000004 ........              DC32    AT_NFA
 1968                           CAT:
 1969    00000008 ........              DC32    .+5
 1970                            SECTION .text : CODE (2)
 1971                                   POP2n
 1971.1  00000000 57F8041B              LDR     n, [p],#4
 1971.2                         //      LDR     n, [p]
 1971.3                         //      ADDS    p, p, #4
 1971.4                                 ENDM
 1972    00000004 0878                  LDRB    t, [n]
 1973                                   TPUSH
 1973                                   PUSHt   // push t to p, pre decrement p
 1973.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1973.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1973.3                         //      STR     t, [p]
 1973.4                                 ENDM
 1973                                   NEXT
 1973.1                         // ARMv7-M Thumb = .+5
 1973.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1973.3                         // ARMv6-M Thumb = .+4
 1973.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1973                                   NEXT1
 1973.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1973.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1973.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1973.4                         // ARMv6-M Thumb = .+4
 1973.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1973.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1973.7                                 ENDM
 1973.8                                 ENDM
 1973.9                                 ENDM
 1974                           
 1975                           
 1976                           //      ! STORE:        ( n addr -- )
 1977                           //      Store n at address. Pronounced "Store".
 1978                           
 1979                            SECTION .text : CONST (2)
 1980                           STORE_NFA:
 1981    00000000 81                    DC8     0x81
 1982    00000001 A1                    DC8     '!'+0x80
 1983    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 1984    00000004 ........              DC32    CAT_NFA
 1985                           STORE:
 1986    00000008 ........              DC32    .+5
 1987                            SECTION .text : CODE (2)
 1988                                   POP2t           // ADDR
 1988.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 1988.2                         //#ifndef TOSCT
 1988.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 1988.4                         //#endif
 1988.5                         //      ADDS    p, p, #4
 1988.6                                 ENDM
 1989                                   POP2n           // DATA
 1989.1  00000004 57F8041B              LDR     n, [p],#4
 1989.2                         //      LDR     n, [p]
 1989.3                         //      ADDS    p, p, #4
 1989.4                                 ENDM
 1990    00000008 0160                  STR     n, [t]
 1991                                   NEXT
 1991.1                         // ARMv7-M Thumb = .+5
 1991.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1991.3                         // ARMv6-M Thumb = .+4
 1991.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1991                                   NEXT1
 1991.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1991.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1991.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1991.4                         // ARMv6-M Thumb = .+4
 1991.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1991.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1991.7                                 ENDM
 1991.8                                 ENDM
 1992                           
 1993                           
 1994                           //      C! CSTORE:      ( n addr -- )
 1995                           //      Store LS 8 bits of n at address. Pronounced "Char Store".
 1996                           
 1997                            SECTION .text : CONST (2)
 1998                           CSTORE_NFA:
 1999    00000000 82                    DC8     0x82
 2000    00000001 43                    DC8     'C'
 2001    00000002 A1                    DC8     '!'+0x80
 2002    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2003    00000004 ........              DC32    STORE_NFA
 2004                           CSTORE:
 2005    00000008 ........              DC32    .+5
 2006                            SECTION .text : CODE (2)
 2007                                   POP2t
 2007.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 2007.2                         //#ifndef TOSCT
 2007.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 2007.4                         //#endif
 2007.5                         //      ADDS    p, p, #4
 2007.6                                 ENDM
 2008                                   POP2n
 2008.1  00000004 57F8041B              LDR     n, [p],#4
 2008.2                         //      LDR     n, [p]
 2008.3                         //      ADDS    p, p, #4
 2008.4                                 ENDM
 2009    00000008 0170                  STRB    n, [t]
 2010                                   NEXT
 2010.1                         // ARMv7-M Thumb = .+5
 2010.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2010.3                         // ARMv6-M Thumb = .+4
 2010.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2010                                   NEXT1
 2010.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2010.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2010.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2010.4                         // ARMv6-M Thumb = .+4
 2010.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2010.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2010.7                                 ENDM
 2010.8                                 ENDM
 2011                           
 2012                           
 2013                           //=============================== WORDCAT ====================================//
 2014                           //NOEXEC HEADERFORWORDCATEGORIES
 2015                           //      WC_RWMEMORY_NFA = MEMORY READ AND WRITE CATEGORY
 2016                           
 2017                            SECTION .text : CONST (2)
 2018                           WC_RWMEMORY_NFA:
 2019    00000000 9F                    DC8     0x80+31
 2020    00000001 0D0A                  DC8     0x0D, 0x0A
 2021    00000003 5265616420616         DC8     'Read and Write Memory With:'
                  E642057726974
                  65204D656D6F7
                  2792057697468
                  3A           
 2022    0000001E 0D8A                  DC8     0x0D, 0x0A+0x80
 2023                            ALIGNROM 2,0xFFFFFFFF
 2024    00000020 ........              DC32    CSTORE_NFA
 2025                           
 2026                           
 2027                           //      ] RBRAC:        ( -- )
 2028                           //      Resume compilation, by STATE back to 0xC0 (zero is interpreting)
 2029                           //      0xC0 STATE  used in INTERPRET to execute Immediate words while compiling
 2030                           //      See [.
 2031                           
 2032                            SECTION .text : CONST (2)
 2033                           RBRAC_NFA:
 2034    00000000 81                    DC8     0x81
 2035    00000001 DD                    DC8     ']'+0x80
 2036    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2037                           //      DC32    SMUDGE_NFA
 2038    00000004 ........              DC32    WC_RWMEMORY_NFA
 2039                           RBRAC:
 2040    00000008 ........              DC32    DOCOL
 2041    0000000C ........C0000         DC32    strva, 0xC0, CSTATE
                  000........  
 2042    00000018 ........              DC32    SEMIS
 2043                           
 2044                           
 2045                           //      [ LBRAC:        ( -- ) IMMEDIATE
 2046                           //      Used in a colon-definition in form
 2047                           //              xxx    [  words   ]    more
 2048                           //      Suspend compilation by setting STATE to zero (0xC0 is compiling).
 2049                           //      The words after [ are executed, not compiled. This allows calculation
 2050                           //      or compilation exceptions before resuming compilation with ] .
 2051                           //      See LITERAL and ]
 2052                           
 2053                            SECTION .text : CONST (2)
 2054                           LBRAC_NFA:
 2055    00000000 C1                    DC8     0x0C1
 2056    00000001 DB                    DC8     '['+0x80
 2057    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2058    00000004 ........              DC32    RBRAC_NFA
 2059                           LBRAC:
 2060    00000008 ........              DC32    DOCOL
 2061    0000000C ........00000         DC32    strva, 0, CSTATE
                  000........  
 2062    00000018 ........              DC32    SEMIS
 2063                           
 2064                           
 2065                           //      [COMPILE] BCOMP:        ( -- ) IMMEDIATE
 2066                           //      Used in a colon-definition in form:
 2067                           //              :  xxx    [COMPILE]   immediate_word   ;
 2068                           //      [COMPILE] will force the compilation of an IMMEDIATE WORD
 2069                           //      that would otherwise execute during compilation. The above example
 2070                           //      will select the FORTH vocabulary then xxx executes, rather than at
 2071                           //      compile time.
 2072                           
 2073                            SECTION .text : CONST (2)
 2074                           BCOMP_NFA:
 2075    00000000 C9                    DC8     0x0C9
 2076    00000001 5B434F4D50494         DC8     '[COMPILE'
                  C45          
 2077    00000009 DD                    DC8     ']'+0x80
 2078    0000000A FFFF           ALIGNROM 2,0xFFFFFFFF
 2079    0000000C ........              DC32    LBRAC_NFA
 2080                           BCOMP:
 2081    00000010 ........              DC32    DOCOL
 2082    00000014 ........              DC32    DFIND   // noop there for TIB entry
 2083                           //      -FIND \ --- pfa len tf (found) \ --- ff (not found)
 2084    00000018 ........              DC32    ZEQU
 2085    0000001C .............         DC32    LIT, msg_qstack
                  ...          
 2086    00000024 ........              DC32    QERROR    // \ f nullstr-addr --
 2087    00000028 ........              DC32    DROP
 2088    0000002C ........              DC32    CFA
 2089    00000030 ........              DC32    COMMA   // alighned, INCREMENTS DP REFLECTED by HERE
 2090    00000034 ........              DC32    SEMIS
 2091                           
 2092                           
 2093                           //      DLITERAL DLITERAL:      ( d -- d ) IMMEDIATE
 2094                           //                              ( d -- )   (compiling)
 2095                           //      If compiling, compile a stack double number into a literal. Later
 2096                           //      execution of the definition containing the literal will push it to
 2097                           //      the stack. If executing, the number will remain on the stack.
 2098                           //      : xxx    [ calculate ]  DLITERAL  ; //
 2099                           
 2100                            SECTION .text : CONST (2)
 2101                           DLITERAL_NFA:
 2102    00000000 C8                    DC8     0x0C8
 2103    00000001 444C495445524         DC8     'DLITERA'
                  1            
 2104    00000008 CC                    DC8     'L'+0x80
 2105    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2106    0000000C ........              DC32    BCOMP_NFA
 2107                           DLITERAL:
 2108    00000010 ........              DC32    DOCOL
 2109    00000014 ........              DC32    STATE_SV
 2110    00000018 ........              DC32    AT
 2111    0000001C ........              DC32    ZBRAN   // IF
 2112    00000020 10000000              DC32     DLIT1-.
 2113                           
 2114    00000024 ........              DC32    SWAP
 2115    00000028 ........              DC32    LITERAL
 2116    0000002C ........              DC32    LITERAL // endif
 2117                           DLIT1:
 2118    00000030 ........              DC32    SEMIS
 2119                           
 2120                           
 2121                           //      LITERAL LITERAL:        ( n -- ) IMMEDIATE
 2122                           //      If compiling, then compile the stack value n as a 32 bit literal.
 2123                           //      This definition is immediate so that it will execute during a colon
 2124                           //      definition. The intended use is:
 2125                           //      : xxx    [ calculate ]  LITERAL  ; //
 2126                           //      Compilation is suspended for the compile time calculation of value.
 2127                           //      Compilation is resumed and LITERAL compiles this value.
 2128                           
 2129                            SECTION .text : CONST (2)
 2130                           LITERAL_NFA:
 2131    00000000 C7                    DC8     0x0C7
 2132    00000001 4C4954455241          DC8     'LITERA'
 2133    00000007 CC                    DC8     'L'+0x80
 2134                            ALIGNROM 2,0xFFFFFFFF
 2135    00000008 ........              DC32    DLITERAL_NFA
 2136                           LITERAL:
 2137    0000000C ........              DC32    DOCOL
 2138    00000010 ........              DC32    STATE_SV
 2139    00000014 ........              DC32    AT
 2140    00000018 ........              DC32    ZBRAN           // If not compiling
 2141    0000001C 10000000              DC32     LITE1-.        // go here
 2142                           
 2143    00000020 ........              DC32    COMP            // Compile
 2144    00000024 ........              DC32    LIT             // Literal
 2145    00000028 ........              DC32    COMMA           // Then COMPILE THE LITERAL VALUE
 2146                           LITE1:
 2147    0000002C ........              DC32    SEMIS
 2148                           
 2149                           
 2150                           //      #> EDIGS:       ( d=(LSW MSW) -- addr count )
 2151                           //      Terminates numeric output conversion by dropping dnum,
 2152                           //      leaving the text address and character count suitable for type.
 2153                           
 2154                            SECTION .text : CONST (2)
 2155                           EDIGS_NFA:
 2156    00000000 82                    DC8     0x82
 2157    00000001 23                    DC8     '#'
 2158    00000002 BE                    DC8     '>'+0x80
 2159    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2160    00000004 ........              DC32    LITERAL_NFA
 2161                           EDIGS:
 2162    00000008 ........              DC32    DOCOL
 2163    0000000C ........              DC32    DROP
 2164    00000010 ........              DC32    DROP
 2165    00000014 ........              DC32    HLD_SV
 2166    00000018 ........              DC32    AT
 2167    0000001C ........              DC32    PAD_SV
 2168    00000020 ........              DC32    OVER
 2169    00000024 ........              DC32    SUBB
 2170    00000028 ........              DC32    SEMIS
 2171                           
 2172                           
 2173                           //      HOLD HOLD:      ( c -- )
 2174                           //      Used between <# and #> to insert an ascii character into a pictured
 2175                           //      numeric output string.
 2176                           //      e.g. 0x2E HOLD will place a decimal point.
 2177                           
 2178                            SECTION .text : CONST (2)
 2179                           HOLD_NFA:
 2180    00000000 84                    DC8     0x84
 2181    00000001 484F4C                DC8     'HOL'
 2182    00000004 C4                    DC8     'D'+0x80
 2183    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2184    00000008 ........              DC32    EDIGS_NFA
 2185                           HOLD:
 2186    0000000C ........              DC32    DOCOL
 2187    00000010 ........FFFFF         DC32    LIT,-1
                  FFF          
 2188    00000018 ........              DC32    HLD_SV
 2189    0000001C ........              DC32    PSTORE
 2190    00000020 ........              DC32    HLD_SV
 2191    00000024 ........              DC32    AT
 2192    00000028 ........              DC32    CSTORE
 2193    0000002C ........              DC32    SEMIS
 2194                           
 2195                           
 2196                           //      SIGN SIGN:      ( n d=<LSW MSW> -- d=<LSW MSW> )
 2197                           //      Place an ascii "-" sign just before a converted numeric output
 2198                           //      string in the text output buffer when n is negative. n is discarded
 2199                           //      but double number dnum is maintained. Must be used between <# and #>.
 2200                           
 2201                            SECTION .text : CONST (2)
 2202                           SIGN_NFA:
 2203    00000000 84                    DC8     0x84
 2204    00000001 534947                DC8     'SIG'
 2205    00000004 CE                    DC8     'N'+0x80
 2206    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2207    00000008 ........              DC32    HOLD_NFA
 2208                           SIGN:
 2209    0000000C ........              DC32    DOCOL
 2210    00000010 ........              DC32    ROT
 2211    00000014 ........              DC32    ZLESS
 2212    00000018 ........              DC32    ZBRAN           // If
 2213    0000001C 10000000              DC32     SIGN1-.
 2214                           
 2215    00000020 ........2D000         DC32    LIT, '-'        // 0x2D
                  000          
 2216    00000028 ........              DC32    HOLD            // Endif
 2217                           SIGN1:
 2218    0000002C ........              DC32    SEMIS
 2219                           
 2220                           
 2221                           //      #S DIGS:        ( d1=<LSW MSW> -- d2=<LSW MSW> )
 2222                           //      Generates ascii text in the text output buffer, by the use of #,
 2223                           //      until a zero double number d2 results.
 2224                           //      Used between <# and #>.
 2225                           //      EACH NUMBER = BASE*number+(character-'0')
 2226                           
 2227                            SECTION .text : CONST (2)
 2228                           DIGS_NFA:
 2229    00000000 82                    DC8     0x82
 2230    00000001 23                    DC8     '#'
 2231    00000002 D3                    DC8     'S'+0x80
 2232    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2233    00000004 ........              DC32    SIGN_NFA
 2234                           DIGS:
 2235    00000008 ........              DC32    DOCOL
 2236                           DIGS1:                          // Begin generating ascii chars by DIG
 2237    0000000C ........              DC32    DIG             //\ d1=<LSW MSW> -- d2=QUO=<LSW MSW>
 2238    00000010 ........              DC32    OVER
 2239    00000014 ........              DC32    OVER
 2240    00000018 ........              DC32    OR
 2241    0000001C ........              DC32    ZEQU
 2242    00000020 ........              DC32    ZBRAN           //UNTIL
 2243    00000024 E8FFFFFF              DC32     DIGS1-.
 2244    00000028 ........              DC32    SEMIS
 2245                           
 2246                           
 2247                           //      # DIG:  ( d1=<LSW MSW> -- d2=QUO=<LSW MSW> ) BASE MUST BE SET!
 2248                           //      Generate from a double number d1, the next ascii character which is
 2249                           //      placed in an output string. Result d2 is the quotient after division
 2250                           //      by base, and is maintained for further processing.
 2251                           //      Used between <# and #>.
 2252                           //      See #S.
 2253                           //      EACH NUMBER = BASE*number+(character-'0')
 2254                           
 2255                            SECTION .text : CONST (2)
 2256                           DIG_NFA:
 2257    00000000 81                    DC8     0x81
 2258    00000001 A3                    DC8     '#'+0x80
 2259    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2260    00000004 ........              DC32    DIGS_NFA
 2261                           DIG:
 2262    00000008 ........              DC32    DOCOL
 2263    0000000C ........              DC32    BASE_SV         // EX 0 1 0
 2264    00000010 ........              DC32    AT              // -- 0 1 0 A
 2265    00000014 ........              DC32    MSMOD           // -- 0 1 0 0
 2266    00000018 ........              DC32    ROT             // -- 0 0 0 1
 2267    0000001C ........09000         DC32    LIT,9
                  000          
 2268    00000024 ........              DC32    OVER
 2269    00000028 ........              DC32    LESSTHAN
 2270    0000002C ........              DC32    ZBRAN           // If
 2271    00000030 10000000              DC32     DIG1-.
 2272                           
 2273    00000034 ........07000         DC32    LIT,7
                  000          
 2274    0000003C ........              DC32    PLUS            // Endif
 2275                           DIG1:
 2276    00000040 ........30000         DC32    LIT, 0x30
                  000          
 2277    00000048 ........              DC32    PLUS
 2278    0000004C ........              DC32    HOLD
 2279    00000050 ........              DC32    SEMIS
 2280                           
 2281                           
 2282                           //      <# BDIGS:       ( -- )
 2283                           //      Setup for pictured numeric output formatting using the words:
 2284                           //              <# # #S SIGN HOLD #>
 2285                           //      The conversion is done on a double number producing text at Pad
 2286                           
 2287                            SECTION .text : CONST (2)
 2288                           BDIGS_NFA:
 2289    00000000 82                    DC8     0x82
 2290    00000001 3C                    DC8     '<'
 2291    00000002 A3                    DC8     '#'+0x80
 2292    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2293    00000004 ........              DC32    DIG_NFA
 2294                           BDIGS:
 2295    00000008 ........              DC32    DOCOL
 2296    0000000C .............         DC32    strva, PAD, NHLD
                  ...........  
 2297    00000018 ........              DC32    SEMIS
 2298                           
 2299                           
 2300                           //      DOES> DOES:     ( pfa -- ) MODIFIED:
 2301                           //      A word which defines the run-time action within a high-level
 2302                           //      defining word. DOES> alters the code field and first parameter of
 2303                           //      the new word to execute the sequence of compiled word addresses
 2304                           //      following DOES>. Used in combination with <BUILDS. When the DOES>
 2305                           //      part executes it begins with the address of the first parameter of
 2306                           //      the new word on the stack. This allows interpretation using this
 2307                           //      area or its contents. Typical uses include the Forth assembler,
 2308                           //      multidimensional arrays, and compiler generation.
 2309                           
 2310                            SECTION .text : CONST (2)
 2311                           DOES_NFA:
 2312    00000000 85                    DC8     0x85
 2313    00000001 444F4553              DC8     'DOES'
 2314    00000005 BE                    DC8     '>'+0x80
 2315    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2316    00000008 ........              DC32    BDIGS_NFA
 2317                           DOES:
 2318    0000000C ........              DC32    DOCOL
 2319    00000010 ........              DC32    RFROM   // Get the addr of the first word after DOES>
 2320    00000014 ........              DC32    LATEST  // ( -- addr ) nfa OF the current <creator> word
 2321    00000018 ........              DC32    PFA     // Use the pfa to store a run-time cfa
 2322    0000001C .............         DC32    DUP, CFA
                  ...          
 2323    00000024 .............         DC32    LIT, CREATE_DOES_GOTO
                  ...          
 2324    0000002C .............         DC32    SWAP, STORE     // STORE GOTO
                  ...          
 2325    00000034 ........              DC32    STORE   // Store the run-time cfa as 1rst pfa Parameter.
 2326    00000038 ........              DC32    SEMIS
 2327                           
 2328                           
 2329                           //      <BUILDS BUILDS: ( -- )  MODIFIED: See CREATE and DOES>
 2330                           //      Used within a colon-definition
 2331                           //              CCcc  <BUILDS  ...  DOES>     ...
 2332                           //      Each time CCcc is executed, <BUILDS defines a new word with a
 2333                           //      high-level execution proceedure. Executing CCcc in the form
 2334                           //              CCcc nnnn
 2335                           //      uses <BUILDS to create a dictionary entry for nnnn with a call to
 2336                           //      the DOES> part for nnnn. When nnnn is later executed, it has the
 2337                           //      address of its parameter area on the stack and executes the words
 2338                           //      after DOES> in CCcc. <BUILDS and DOES> allow runtime proceedures to
 2339                           //      written in high-level code.
 2340                           
 2341                            SECTION .text : CONST (2)
 2342                           BUILDS_NFA:
 2343    00000000 87                    DC8     0x87
 2344    00000001 3C4255494C44          DC8     '<BUILD'
 2345    00000007 D3                    DC8     'S'+0x80
 2346                            ALIGNROM 2,0xFFFFFFFF
 2347    00000008 ........              DC32    DOES_NFA
 2348                           BUILDS:
 2349    0000000C ........              DC32    DOCOL   // CREATE DOES DICTSPACE CHECK
 2350    00000010 ........              DC32    CREATE                  // CREATE's A CON POINTING TO IT'S PFA
 2351    00000014 ........              DC32    SEMIS
 2352                           
 2353                           
 2354                           //      +LOOP PLOOP:    ( n1 -- ) IMMEDIATE
 2355                           //                      ( addr n2 -- ) COMPILE
 2356                           //      At run time, DO begins a sequence with repetitive execution
 2357                           //      controlled by a loop limit n1 and an index with initial value n2. DO
 2358                           //      removes these from the stack. Upon reaching LOOP the index is
 2359                           //      incremented by one.
 2360                           //      Until the new index equals or exceeds the limit, execution loops
 2361                           //      back to just after DO// otherwise the loop parameters are discarded
 2362                           //      and execution continues ahead. Both n1 and n2 are determined at
 2363                           //      run-time and may be the result of other operations.
 2364                           //      Within a loop 'I' will copy the current value of the index to the
 2365                           //      stack. See I, LOOP, +LOOP, LEAVE.
 2366                           //
 2367                           //      When compiling within the colon definition, DO compiles (DO), leaves
 2368                           //      the following address addr and n for later error checking.
 2369                           
 2370                            SECTION .text : CONST (2)
 2371                           PLOOP_NFA:
 2372    00000000 C5                    DC8     0x0C5
 2373    00000001 2B4C4F4F              DC8     '+LOO'
 2374    00000005 D0                    DC8     'P'+0x80
 2375    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2376    00000008 ........              DC32    BUILDS_NFA
 2377                           PLOOP:
 2378    0000000C ........              DC32    DOCOL
 2379    00000010 ........              DC32    THREE
 2380    00000014 ........              DC32    QPAIR
 2381    00000018 ........              DC32    COMP
 2382    0000001C ........              DC32    XPLOOP
 2383    00000020 ........              DC32    BACK
 2384    00000024 ........              DC32    SEMIS
 2385                           
 2386                           
 2387                           //      LOOP LOOP:      ( addr n -- ) IMMEDIATE
 2388                           //      Occurs in a colon-definition in form:
 2389                           //              DO ... LOOP
 2390                           //      At run-time, LOOP selectively controls branching back to the
 2391                           //      corresponding DO based on the loop index and limit. The loop index
 2392                           //      is incremented by one and compared to the limit. The branch back to
 2393                           //      DO occurs until the index equals or exceeds the limit, then
 2394                           //      the parameters are discarded and execution continues ahead.
 2395                           //
 2396                           //      At compile-time. LOOP compiles (LOOP) and uses addr to calculate an
 2397                           //      offset to DO. n is used for error testing.
 2398                           
 2399                            SECTION .text : CONST (2)
 2400                           LOOP_NFA:
 2401    00000000 C4                    DC8     0x0C4
 2402    00000001 4C4F4F                DC8     'LOO'
 2403    00000004 D0                    DC8     'P'+0x80
 2404    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2405    00000008 ........              DC32    PLOOP_NFA
 2406                           LOOP:
 2407    0000000C ........              DC32    DOCOL
 2408    00000010 ........              DC32    THREE
 2409    00000014 ........              DC32    QPAIR
 2410    00000018 ........              DC32    COMP
 2411    0000001C ........              DC32    XLOOP
 2412    00000020 ........              DC32    BACK
 2413    00000024 ........              DC32    SEMIS
 2414                           
 2415                           
 2416                           //      DO DO:  ( n1 n2 -- ) IMMEDIATE
 2417                           //              (addr n -- ) COMPILE
 2418                           //      Occurs in a colon-definition in form:
 2419                           //      DO ... LOOP
 2420                           
 2421                            SECTION .text : CONST (2)
 2422                           DO_NFA:
 2423    00000000 C2                    DC8     0x0C2
 2424    00000001 44                    DC8     'D'
 2425    00000002 CF                    DC8     'O'+0x80
 2426    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2427    00000004 ........              DC32    LOOP_NFA
 2428                           DO:
 2429    00000008 ........              DC32    DOCOL
 2430    0000000C ........              DC32    COMP
 2431    00000010 ........              DC32    XDO
 2432    00000014 ........              DC32    HERE
 2433    00000018 ........              DC32    THREE
 2434    0000001C ........              DC32    SEMIS
 2435                           
 2436                           
 2437                           //      ENDIF ENDIF:    ( addr n -- ) IMMEDIATE
 2438                           //      Occurs in a colon-definition in form:
 2439                           //              IF ... ENDIF
 2440                           //              IF ... ELSE ... ENDIF
 2441                           //      At run-time, ENDIF serves only as the destination of a forward
 2442                           //      branch from IF or ELSE. It marks the conclusion of the conditional
 2443                           //      structure. THEN is another name for ENDIF. Both names are supported
 2444                           //      in fig-FORTH. See also IF and ELSE.
 2445                           //
 2446                           //      At compile-time, ENDIF computes the forward branch offset from addr
 2447                           //      to HERE and stores it at addr. n is used for error tests.
 2448                           
 2449                            SECTION .text : CONST (2)
 2450                           ENDIF_NFA:
 2451    00000000 C5                    DC8     0x0C5
 2452    00000001 454E4449              DC8     'ENDI'
 2453    00000005 C6                    DC8     'F'+0x80
 2454    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2455    00000008 ........              DC32    DO_NFA
 2456                           ENDIF:
 2457    0000000C ........              DC32    DOCOL
 2458    00000010 ........              DC32    QCOMP
 2459    00000014 ........              DC32    TWO     // 2 is the Error checking number for if.
 2460    00000018 ........              DC32    QPAIR
 2461    0000001C ........              DC32    HERE
 2462    00000020 ........              DC32    OVER
 2463    00000024 ........              DC32    SUBB
 2464    00000028 ........              DC32    SWAP
 2465    0000002C ........              DC32    STORE
 2466    00000030 ........              DC32    SEMIS
 2467                           
 2468                           
 2469                           //      THEN THEN:      ( -- ) IMMEDIATE
 2470                           //      An alias for ENDIF.
 2471                           
 2472                            SECTION .text : CONST (2)
 2473                           THEN_NFA:
 2474    00000000 C4                    DC8     0x0C4
 2475    00000001 544845                DC8     'THE'
 2476    00000004 CE                    DC8     'N'+0x80
 2477    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2478    00000008 ........              DC32    ENDIF_NFA
 2479                           THEN:
 2480    0000000C ........              DC32    DOCOL
 2481    00000010 ........              DC32    ENDIF
 2482    00000014 ........              DC32    SEMIS
 2483                           
 2484                           
 2485                           //      ELSE ELSE:      ( addr1 n1 -- ) IMMEDIATE
 2486                           //                      ( addr2 n2 -- ) COMPILING
 2487                           //      Occurs within a colon-definition in the form:
 2488                           //              IF ... ELSE ... ENDIF
 2489                           //      At run-time, ELSE executes after the true part following IF. ELSE
 2490                           //      forces execution to skip over the following false part and resumes
 2491                           //      execution after the ENDIF. It has no stack effect.
 2492                           //
 2493                           //      At compile-time ELSE emplaces BRANCH reserving a branch offset,
 2494                           //      leaves the address addr2 and n2 for error testing. ELSE also
 2495                           //      resolves the pending forward branch from IF by calculating the
 2496                           //      offset from addr1 to HERE and storing at addr1.
 2497                           
 2498                            SECTION .text : CONST (2)
 2499                           ELSE_NFA:
 2500    00000000 C4                    DC8     0x0C4
 2501    00000001 454C53                DC8     'ELS'
 2502    00000004 C5                    DC8     'E'+0x80
 2503    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2504    00000008 ........              DC32    THEN_NFA
 2505                           ELSE:
 2506    0000000C ........              DC32    DOCOL
 2507    00000010 ........              DC32    TWO
 2508    00000014 ........              DC32    QPAIR
 2509    00000018 ........              DC32    COMP
 2510    0000001C ........              DC32    BRAN
 2511    00000020 ........              DC32    HERE
 2512    00000024 ........              DC32    ZERO
 2513    00000028 ........              DC32    COMMA   // aligned, INCREMENTS DP REFLECTED by HERE
 2514    0000002C ........              DC32    SWAP
 2515    00000030 ........              DC32    TWO
 2516    00000034 ........              DC32    ENDIF
 2517    00000038 ........              DC32    TWO
 2518    0000003C ........              DC32    SEMIS
 2519                           
 2520                           
 2521                           //      IF IF:  ( f -- ) IMMEDIATE
 2522                           //              ( -- addr n ) COMPILE
 2523                           //      Occurs is a colon-definition in form:
 2524                           //              IF (tp) ...  ENDIF      .
 2525                           //              IF (tp) ... ELSE (fp) ... ENDIF
 2526                           //      At run-time, IF selects execution based on a boolean flag. If f is
 2527                           //      true (non-zero), execution continues ahead thru the true part. If f
 2528                           //      is false (zero), execution skips till just after ELSE to execute
 2529                           //      the false part. After either part, execution resumes after ENDIF.
 2530                           //      ELSE and its false part are optional.; if missing, false execution
 2531                           //      skips to just after ENDIF..
 2532                           //
 2533                           //      At compile-time IF compiles 0BRANCH and reserves space for an offset
 2534                           //      at addr. addr and n are used later for resolution of the offset and
 2535                           //      error testing.
 2536                           
 2537                            SECTION .text : CONST (2)
 2538                           IF_NFA:
 2539    00000000 C2                    DC8     0x0C2
 2540    00000001 49                    DC8     'I'
 2541    00000002 C6                    DC8     'F'+0x80
 2542    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2543    00000004 ........              DC32    ELSE_NFA
 2544                           IF:
 2545    00000008 ........              DC32    DOCOL
 2546    0000000C ........              DC32    COMP
 2547    00000010 ........              DC32    ZBRAN
 2548    00000014 ........              DC32    HERE
 2549    00000018 ........              DC32    ZERO
 2550    0000001C ........              DC32    COMMA
 2551    00000020 ........              DC32    TWO     // 2 is the Error checking number for if.
 2552    00000024 ........              DC32    SEMIS
 2553                           
 2554                           
 2555                           //      UNTIL UNTIL:    ( f -- ) IMMEDIATE
 2556                           //                      ( addr n -- ) COMPILE:
 2557                           //      Occurs within a colon-definition in the form:
 2558                           //              BEGIN ... UNTIL
 2559                           //      At run-time, UNTIL controls the conditional branch back to the
 2560                           //      corresponding BEGIN. If f is false, execution returns to just after.
 2561                           //      BEGIN:  if true, execution continues ahead.
 2562                           //      At compile-time, UNTIL compiles (0BRANCH) and an offset from HERE to
 2563                           //      addr. n is used for error tests.
 2564                           
 2565                            SECTION .text : CONST (2)
 2566                           UNTIL_NFA:
 2567    00000000 C5                    DC8     0x0C5
 2568    00000001 554E5449              DC8     'UNTI'
 2569    00000005 CC                    DC8     'L'+0x80
 2570    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2571    00000008 ........              DC32    IF_NFA
 2572                           UNTIL:
 2573    0000000C ........              DC32    DOCOL
 2574    00000010 ........              DC32    ONE
 2575    00000014 ........              DC32    QPAIR
 2576    00000018 ........              DC32    COMP
 2577    0000001C ........              DC32    ZBRAN
 2578    00000020 ........              DC32    BACK
 2579    00000024 ........              DC32    SEMIS
 2580                           
 2581                           
 2582                           //      AGAIN AGAIN:    ( addr n -- ) IMMEDIATE
 2583                           //      Used in a colon-definition in the form:
 2584                           //                      BEGIN ... AGAIN
 2585                           //      At run-time, AGAIN forces execution to return to corresponding BEGIN.
 2586                           //      There is no effect on the stack. Execution cannot leave this loop
 2587                           //      (unless R> DROP is executed one level below).
 2588                           //
 2589                           //      At compile time, AGAIN compiles BRANCH with an offset from HERE to
 2590                           //      addr. n is used for compile-time error checking.
 2591                           
 2592                            SECTION .text : CONST (2)
 2593                           AGAIN_NFA:
 2594    00000000 C5                    DC8     0x0C5
 2595    00000001 41474149              DC8     'AGAI'
 2596    00000005 CE                    DC8     'N'+0x80
 2597    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2598    00000008 ........              DC32    UNTIL_NFA
 2599                           AGAIN:
 2600    0000000C ........              DC32    DOCOL
 2601    00000010 ........              DC32    ONE
 2602    00000014 ........              DC32    QPAIR
 2603    00000018 ........              DC32    COMP
 2604    0000001C ........              DC32    BRAN
 2605    00000020 ........              DC32    BACK
 2606    00000024 ........              DC32    SEMIS
 2607                           
 2608                           
 2609                           //      REPEAT REPEAT:  ( addr n -- ) IMMEDIATE
 2610                           //      Used within a colon-definition in the form:
 2611                           //              BEGIN ... WHILE ... REPEAT
 2612                           //      At run-time, REPEAT forces an unconditional branch back to just
 2613                           //      after the corresponding BEGIN.
 2614                           //
 2615                           //      At compile-time, REPEAT compiles BRANCH and the offset from HERE to
 2616                           //      addr. n is used for error testing.
 2617                           
 2618                            SECTION .text : CONST (2)
 2619                           REPEAT_NFA:
 2620    00000000 C6                    DC8     0x0C6
 2621    00000001 5245504541            DC8     'REPEA'
 2622    00000006 D4                    DC8     'T'+0x80
 2623    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 2624    00000008 ........              DC32    AGAIN_NFA
 2625                           REPEAT:
 2626    0000000C ........              DC32    DOCOL
 2627    00000010 ........              DC32    TOR
 2628    00000014 ........              DC32    TOR
 2629    00000018 ........              DC32    AGAIN
 2630    0000001C ........              DC32    RFROM
 2631    00000020 ........              DC32    RFROM
 2632    00000024 ........              DC32    TWO
 2633    00000028 ........              DC32    SUBB
 2634    0000002C ........              DC32    ENDIF
 2635    00000030 ........              DC32    SEMIS
 2636                           
 2637                           
 2638                           //      WHILE WHILE:    ( f -- ) IMMEDIATE
 2639                           //                      (ad1 nl -- ad1 n1 ad2 n2 ) COMPILE
 2640                           //      Occurs in a colon-definition in the form:
 2641                           //              BEGIN ... WHILE (tp) ... REPEAT
 2642                           //      At run-time, WHILE selects conditional execution based on boolean
 2643                           //      flag f. If f is true (non-zero), WHILE continues execution of the
 2644                           //      true part thru to REPEAT, which then branches back to BEGIN. If f is
 2645                           //      false (zero), execution skips to just after REPEAT, exiting the
 2646                           //      structure.
 2647                           //
 2648                           //      At compile time, WHILE emplaces (0BRANCH) and leaves ad2 of the
 2649                           //      reserved offset. The stack values will be resolved by REPEAT.
 2650                           
 2651                            SECTION .text : CONST (2)
 2652                           WHILE_NFA:
 2653    00000000 C5                    DC8     0x0C5
 2654    00000001 5748494C              DC8     'WHIL'
 2655    00000005 C5                    DC8     'E'+0x80
 2656    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2657    00000008 ........              DC32    REPEAT_NFA
 2658                           WHILE:
 2659    0000000C ........              DC32    DOCOL
 2660    00000010 ........              DC32    IF
 2661    00000014 ........              DC32    TWOP
 2662    00000018 ........              DC32    SEMIS
 2663                           
 2664                           
 2665                           //      BEGIN BEGIN:    ( -- addr n ) IMMEDIATE
 2666                           //      Occurs in a colon-definition in form:
 2667                           //      BEGIN ... UNTIL
 2668                           //      BEGIN ... AGAIN
 2669                           //      BEGIN ... WHILE ... REPEAT
 2670                           //      At run-time, BEGIN marks the start of a sequence that may be
 2671                           //      repetitively executed. It serves as a return point from the
 2672                           //      corresponding UNTIL, AGAIN or REPEAT. When executing UNTIL, a return
 2673                           //      to BEGIN will occur if the top of the stack is false//
 2674                           //      for AGAIN and REPEAT a return to BEGIN always occurs.
 2675                           //
 2676                           //      At compile time BEGIN leaves its return address and n for compiler
 2677                           //      error checking.
 2678                           
 2679                            SECTION .text : CONST (2)
 2680                           BEGIN_NFA:
 2681    00000000 C5                    DC8     0x0C5
 2682    00000001 42454749              DC8     'BEGI'
 2683    00000005 CE                    DC8     'N'+0x80
 2684    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2685    00000008 ........              DC32    WHILE_NFA
 2686                           BEGIN:
 2687    0000000C ........              DC32    DOCOL
 2688    00000010 ........              DC32    QCOMP
 2689    00000014 ........              DC32    HERE
 2690    00000018 ........              DC32    ONE
 2691    0000001C ........              DC32    SEMIS
 2692                           
 2693                           
 2694                           //=============================== WORDCAT ====================================//
 2695                           //NOEXEC HEADERFORWORDCATEGORIES
 2696                           //      WC_COMPILE_NFA = COMPILING WORDS CATEGORY
 2697                           
 2698                            SECTION .text : CONST (2)
 2699                           WC_COMPILE_NFA:
 2700    00000000 97                    DC8     0x80+4+19
 2701    00000001 0D0A                  DC8     0x0D, 0x0A
 2702    00000003 496E736964652         DC8     'Inside Colon WORDS:'
                  0436F6C6F6E20
                  574F5244533A 
 2703    00000016 0D8A                  DC8     0x0D, 0x0A+0x80
 2704                            ALIGNROM 2,0xFFFFFFFF
 2705    00000018 ........              DC32    BEGIN_NFA
 2706                           
 2707                           
 2708                           //      IMMEDIATE IMMED:        ( -- )
 2709                           //      Mark the most recently made definition so that when encountered at
 2710                           //      compile time, it will be executed rather than being compiled. i.e.
 2711                           //      the precedence bit in its header is set.
 2712                           //      This method allows definitions to handle unusual compiling
 2713                           //      situations, rather. than build them into the fundamental compiler.
 2714                           //      The system may force compilation of an immediate definition by
 2715                           //      preceeding it with [COMPILE].
 2716                           
 2717                            SECTION .text : CONST (2)
 2718                           IMMED_NFA:
 2719    00000000 89                    DC8     0x89
 2720    00000001 494D4D4544494         DC8     'IMMEDIAT'
                  154          
 2721    00000009 C5                    DC8     'E'+0x80
 2722    0000000A FFFF           ALIGNROM 2,0xFFFFFFFF
 2723    0000000C ........              DC32    WC_COMPILE_NFA
 2724                           IMMED:
 2725    00000010 ........              DC32    DOCOL
 2726    00000014 ........              DC32    LATEST
 2727    00000018 ........40000         DC32    LIT, 0x40
                  000          
 2728    00000020 ........              DC32    TOGGLE
 2729    00000024 ........              DC32    SEMIS
 2730                           
 2731                           
 2732                           //      CREATE CREATE:  ( -- )
 2733                           //      Create a word in The Dictionary.
 2734                           //      Make searchable and forgetable NFA/LFA, DOCON, ADDR->PFA
 2735                           //      USE <BUILDS with DOES> instead of CREATE.
 2736                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
 2737                           //
 2738                           //      Saves HERE in CSDP in case there's an error creating a word.
 2739                           //      CSDP is reset when a word is completed, by ; <BUILDS (?) CON and VAR.
 2740                           //
 2741                           //      A defining word used in the form:
 2742                           //              CREATE CCcc
 2743                           //      by such words as VAR, CON AND <BUILDS to create a dictionary header for
 2744                           //      a new word. The code field contains the address of the words
 2745                           //      parameter field.
 2746                           
 2747                            SECTION .text : CONST (2)
 2748                           CREATE_NFA:
 2749    00000000 86                    DC8     0x86
 2750    00000001 4352454154            DC8     'CREAT'
 2751    00000006 C5                    DC8     'E'+0x80
 2752    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 2753    00000008 ........              DC32    IMMED_NFA
 2754                           CREATE:
 2755    0000000C ........              DC32    DOCOL
 2756    00000010 ........              DC32    DICTSPACE       //      \ -- n
 2757    00000014 ........0F000         DC32    LIT, 15, SUBB   // One less than smallest definition
                  000........  
 2758    00000020 ........              DC32    ZLESS
 2759    00000024 ........              DC32    ZBRAN
 2760    00000028 08000000              DC32    CREATEOK-.
 2761                           
 2762    0000002C ........              DC32    DICTFULL_ABORT
 2763                           
 2764                           CREATEOK:
 2765    00000030 ........              DC32    DFIND                   // Parse nfa
 2766                           //      -FIND DFIND \ --- pfa len tf (found) \ --- ff (not found)
 2767    00000034 ........              DC32    ZBRAN
 2768    00000038 24000000              DC32     CREA1-.
 2769                           
 2770                           #ifdef IO2TP
 2774                           #endif
 2775    0000003C ........              DC32    DROP
 2776    00000040 ........              DC32    NFA
 2777    00000044 ........              DC32    IDDOT
 2778    00000048 .............         DC32    LIT, msg_wordexists
                  ...          
 2779                           // Nothing created yet so ABORT is correct.
 2780                           //        DC32    ERROR
 2781    00000050 .............         DC32    NULLSTRLEN, TYPE
                  ...          
 2782    00000058 ........              DC32    ABORT
 2783                           
 2784                           CREA1:
 2785                           // Save HERE in CSDP so ERROR can reset DP if this definition fails.
 2786                           // CSDP is reset by SEMIC_CREATE when this definition is completed.
 2787                           // SEMIC_CREATE used in ; CON and VAR to reset CSDP.
 2788                           
 2789                           // This new definitions cstring name has been moved to HERE 
 2790    0000005C .............         DC32    HERE, DUP       // This will become the new CURRENT (this NFA).
                  ...          
 2791    00000064 .............         DC32    CSDP_SV, STORE  // HERE to CSDP to restore in case of error.
                  ...          
 2792                           // Dup HERE-NFA to allot NFAx
 2793    0000006C ........              DC32    DUP
 2794                           // Limit NFA allot to maxwordlen. DOES NOT CHANGE actual count!
 2795                           // If count is larger than MAXWORDLEN behaviour of this def is unpredictable!
 2796    00000070 ........              DC32    CAT
 2797    00000074 ........1F000         DC32    LIT, MAXWORDLEN // ELIMINATED WIDTH AND WIDTH_SV 
                  000          
 2798    0000007C ........              DC32    MIN
 2799    00000080 ........              DC32    ALLOT_PRIM      // HERE (DP) at end of NFA with padding.
 2800                           // Dup HERE-NFA to set count byte, and to be consumed later
 2801                           // for setting CURRENT after previous CURRENT compiled into LFA.
 2802    00000084 ........              DC32    DUP
 2803                           // Make regular (not immediate) NFA count byte
 2804    00000088 ........80000         DC32    LIT, 0x80
                  000          
 2805    00000090 ........              DC32    TOGGLE          // Count Byte = 80+count
 2806                           // HERE is new now. Mark end of NFA for PFIND search
 2807    00000094 ........              DC32    HERE            // DP after allot of NFA
 2808    00000098 ........80000         DC32    LIT,0x80        // Set last character in NFA
                  000          
 2809    000000A0 ........              DC32    TOGGLE          // smudge bit
 2810                           // Bump DP to LFA
 2811    000000A4 .............         DC32    ONE, DP_SV      // MOVE HERE (DP)
                  ...          
 2812    000000AC ........              DC32    PSTORE          // TO LFA
 2813                           // Set LFA
 2814    000000B0 ........              DC32    LATEST          // LATEST = CURRENT_SV -> MOST RECENT DEF NFA
 2815    000000B4 ........              DC32    COMMA           // Compile last words NFA into this link field.
 2816                                                           // DUP'd HERE should be on stack
 2817                           // Have to set CURRENT with last dup's HERE-NFA after LATEST is compiled
 2818    000000B8 ........              DC32    CURRENT_SV      // LATEST = CURRENT_SV
 2819    000000BC ........              DC32    STORE           // so storing NEWWORD_NFA into CURRENT.
 2820    000000C0 .............         DC32    COMP, DOCON     // Compile DOCON as CFA
                  ...          
 2821    000000C8 .............         DC32    HERE, FOURP     // Compute and
                  ...          
 2822    000000D0 ........              DC32    COMMA           // COMPILE Addr of PFA
 2823                           //      DC32    SMUDGE          // ELIMINATED
 2824                           //      DC32    SEMIC_CREATE    // USED IN CALLERS OF CREATE, NOT HERE!
 2825    000000D4 ........              DC32    SEMIS
 2826                           
 2827                           
 2828                           //      CON CON:        ( n -- )  MODIFIED: and CONSTANT renamed CON
 2829                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
 2830                           //      A defining word used in the form:
 2831                           //              n CONSTANT CCcc
 2832                           //      to create word CCcc, with its parameter field containing n. When
 2833                           //      CCcc is later executed, it will push the value of n to the stack.
 2834                           
 2835                            SECTION .text : CONST (2)
 2836                           CONSTANT_NFA:
 2837    00000000 88                    DC8     0x88
 2838    00000001 434F4E5354414         DC8     'CONSTAN'
                  E            
 2839    00000008 D4                    DC8     'T'+0x80
 2840    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2841    0000000C ........              DC32    CREATE_NFA
 2842                           CONSTANT:
 2843    00000010 .............         DC32    DOCOL, CON, SEMIS   // CREATE DOES DICTSPACE CHECK
                  ...........  
 2844                           
 2845                           
 2846                            SECTION .text : CONST (2)
 2847                           CON_NFA:
 2848    00000000 83                    DC8     0x83
 2849    00000001 434F                  DC8     'CO'
 2850    00000003 CE                    DC8     'N'+0x80
 2851                            ALIGNROM 2,0xFFFFFFFF
 2852                           //      DC32    CREATE_NFA
 2853    00000004 ........              DC32    CONSTANT_NFA
 2854                           CON:
 2855    00000008 ........              DC32    DOCOL   // CREATE DOES DICTSPACE CHECK
 2856    0000000C ........              DC32    CREATE  // Make Header NFA/LFA, DOCON, ADDR->PFA
 2857    00000010 ........FCFFF         DC32    LIT, -4, DP_SV, PSTORE  // back up to ADDR->PFA
                  FFF..........
                  ......       
 2858    00000020 ........              DC32    COMMA                   // Replace with Con value
 2859    00000024 ........              DC32    SEMIC_CREATE            // RESET AUTO FORGET
 2860                           //        DC32    DOTDICTSPACE
 2861    00000028 ........              DC32    SEMIS
 2862                           
 2863                           
 2864                           //      VAR VAR:        ( -- ) RENAMED: VARIABLE to VAR
 2865                           //      IF RAMVARSPACE FULL PRINT Error MESSAGE AND Abort.
 2866                           //      A defining word used in the form:
 2867                           //              VARIABLE CCcc
 2868                           //      When VARIABLE is executed, it creates the definition CCcc with its
 2869                           //      with its cell space uninitialized. When CCcc is executed,
 2870                           //      its cell space address is put on the stack. Use with @ or !
 2871                           //      NOTE: VAR's cell space is allocated in ram. See UP and VARALLOT.
 2872                           
 2873                            SECTION .text : CONST (2)
 2874                           VARIABLE_NFA:
 2875    00000000 88                    DC8     0x88
 2876    00000001 5641524941424         DC8     'VARIABL'
                  C            
 2877    00000008 C5                    DC8     'E'+0x80
 2878    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2879    0000000C ........              DC32    CON_NFA
 2880                           VARIABLE:
 2881    00000010 .............         DC32    DOCOL, VAR_, SEMIS   // CREATE DOES DICTSPACE CHECK
                  ...........  
 2882                           
 2883                            SECTION .text : CONST (2)
 2884                           VAR_NFA:
 2885    00000000 83                    DC8     0x83
 2886    00000001 5641                  DC8     'VA'
 2887    00000003 D2                    DC8     'R'+0x80
 2888                            ALIGNROM 2,0xFFFFFFFF
 2889                           //      DC32    CON_NFA
 2890    00000004 ........              DC32    VARIABLE_NFA
 2891                           VAR_:
 2892    00000008 ........              DC32    DOCOL   // CREATE DOES DICTSPACE CHECK
 2893    0000000C ........              DC32    CREATE  // Make Header NFA and LFA, update CURRENT
 2894    00000010 ........F8FFF         DC32    LIT, -8, DP_SV, PSTORE
                  FFF..........
                  ......       
 2895    00000020 .............         DC32    COMP, DOVAR     // CFA of VAR's
                  ...          
 2896                           //        DC32    COMP, DOCON     // CFA of VAR's
 2897                           // aligned, INCREMENTS DP REFLECTED by HERE
 2898                           // compile the value \ v --
 2899    00000028 ........              DC32    ONE
 2900    0000002C ........              DC32    VARALLOT        // Do .VS check and return VAR addr.
 2901    00000030 ........              DC32    COMMA           // Compile address of the ram allotment.
 2902    00000034 ........              DC32    SEMIC_CREATE            // RESET AUTO FORGET
 2903                           //        DC32    DOTDICTSPACE
 2904                           //        DC32    DOTVARSPACE
 2905    00000038 ........              DC32    SEMIS
 2906                           
 2907                           
 2908                           //      ; SEMI: ( -- ) IMMEDIATE
 2909                           //      Terminate a colon-definition and stop further compilation.
 2910                           //      Compiles the run-time ;S.
 2911                           
 2912                            SECTION .text : CONST (2)
 2913                           SEMI_NFA:
 2914    00000000 C1                    DC8     0x0C1
 2915    00000001 BB                    DC8     ';'+0x80
 2916    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2917    00000004 ........              DC32    VAR_NFA
 2918                           SEMI:
 2919    00000008 ........              DC32    DOCOL
 2920    0000000C ........              DC32    QCSP
 2921    00000010 ........              DC32    COMP
 2922    00000014 ........              DC32    SEMIS
 2923    00000018 ........              DC32    LBRAC
 2924    0000001C ........              DC32    SEMIC_CREATE            // RESET AUTO FORGET
 2925                           //        DC32    DOTDICTSPACE
 2926    00000020 ........              DC32    SEMIS
 2927                           
 2928                           
 2929                           //      : COLON:        ( -- ) IMMEDIATE
 2930                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
 2931                           //      Used in the form called a colon-definition:
 2932                           //              : CCcc     ...     //
 2933                           //      Creates a dictionary entry defining CCcc as equivalent to the
 2934                           //      following sequence of Forth word definitions '...' until the next
 2935                           //      ';' or ';CODE'.
 2936                           //      The compiling process is done by the text interpreter as long as
 2937                           //      STATE is non-zero. Other details are that the CONTEXT vocabulary is
 2938                           //      set to the CURRENT vocabulary and that words with the precedence bit
 2939                           //      set (P) are executed rather than being compiled.
 2940                           
 2941                            SECTION .text : CONST (2)
 2942                           COLON_NFA:
 2943    00000000 C1                    DC8     0x0C1
 2944    00000001 BA                    DC8     ':'+0x80
 2945    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2946    00000004 ........              DC32    SEMI_NFA
 2947                           COLON:
 2948    00000008 ........              DC32    DOCOL
 2949                           //      DICTSPACE TEST DONE IN CREATE
 2950    0000000C ........              DC32    QEXEC
 2951    00000010 ........              DC32    SCSP    // Save the stack position in CSP. Compiler security.
 2952    00000014 ........              DC32    CREATE  // Make Header NFA and LFA, update CURRENT
 2953    00000018 ........              DC32    RBRAC   // Resume compiliting by setting STATE_SV to 0xC0
 2954    0000001C ........F8FFF         DC32    LIT, -8, DP_SV, PSTORE
                  FFF..........
                  ......       
 2955    0000002C .............         DC32    COMP, DOCOL     // aligned, INCREMENTS DP REFLECTED by HERE
                  ...          
 2956    00000034 ........              DC32    SEMIS
 2957                           
 2958                           
 2959                           //=============================== WORDCAT ====================================//
 2960                           //NOEXEC HEADERFORWORDCATEGORIES
 2961                           //      WC_CREATE_NFA = CREATEing WORDS CATEGORY
 2962                           
 2963                            SECTION .text : CONST (2)
 2964                           WC_CREATE_NFA:
 2965    00000000 96                    DC8     0x80+22
 2966    00000001 0D0A                  DC8     0x0D, 0x0A
 2967    00000003 4352454154452         DC8     'CREATE WORDS With:'
                  0574F52445320
                  576974683A   
 2968    00000015 0D8A                  DC8     0x0D, 0x0A+0x80
 2969    00000017 FF             ALIGNROM 2,0xFFFFFFFF
 2970    00000018 ........              DC32    COLON_NFA
 2971                           
 2972                           //------------------------------ DOTBASE SECTION -------------------------------
 2973                           
 2974                           //      .H DOTHEX:      ( n -- )
 2975                           //      Prints TOS in Hex using DOT, not affecting Base in the system
 2976                           
 2977                            SECTION .text : CONST (2)
 2978                           DOTHEX_NFA:
 2979    00000000 82                    DC8     0x82
 2980    00000001 2E                    DC8     '.'
 2981    00000002 C8                    DC8     'H'+0x80
 2982    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2983    00000004 ........              DC32    WC_CREATE_NFA
 2984                           DOTHEX:
 2985    00000008 ........              DC32    DOCOL
 2986    0000000C ........10000         DC32    LIT, 16, DOTBASE
                  000........  
 2987    00000018 ........              DC32    SEMIS
 2988                           
 2989                           
 2990                           //      .D DOTDEC:      ( n -- )
 2991                           //      Prints TOS in DECIMAL using DOT, not affecting Base in the system
 2992                           
 2993                            SECTION .text : CONST (2)
 2994                           DOTDEC_NFA:
 2995    00000000 82                    DC8     0x82
 2996    00000001 2E                    DC8     '.'
 2997    00000002 C4                    DC8     'D'+0x80
 2998    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2999    00000004 ........              DC32    DOTHEX_NFA
 3000                           DOTDEC:
 3001    00000008 ........              DC32    DOCOL
 3002    0000000C ........0A000         DC32    LIT, 10, DOTBASE
                  000........  
 3003    00000018 ........              DC32    SEMIS
 3004                           
 3005                           
 3006                           //      .B DOTBIN:      ( n -- )
 3007                           //      Prints TOS in BINARY using DOT, not affecting Base in the system
 3008                           
 3009                            SECTION .text : CONST (2)
 3010                           DOTBIN_NFA:
 3011    00000000 82                    DC8     0x82
 3012    00000001 2E                    DC8     '.'
 3013    00000002 C2                    DC8     'B'+0x80
 3014    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3015    00000004 ........              DC32    DOTDEC_NFA
 3016                           DOTBIN:
 3017    00000008 ........              DC32    DOCOL
 3018    0000000C .............         DC32    TWO, DOTBASE
                  ...          
 3019    00000014 ........              DC32    SEMIS
 3020                           
 3021                           
 3022                           //      D.R DDOTR:      ( sd=<LSW MSW> n -- ) SIGNED:
 3023                           //      Print a signed double number sd right aligned
 3024                           //      in a field n characters wide.
 3025                           
 3026                            SECTION .text : CONST (2)
 3027                           DDOTR_NFA:
 3028    00000000 83                    DC8     0x83
 3029    00000001 442E                  DC8     'D.'
 3030    00000003 D2                    DC8     'R'+0x80
 3031                            ALIGNROM 2,0xFFFFFFFF
 3032    00000004 ........              DC32    DOTBIN_NFA
 3033                           DDOTR:
 3034    00000008 ........              DC32    DOCOL
 3035    0000000C ........              DC32    TOR     // N CHAR FIELD LEN to r
 3036    00000010 ........              DC32    SWAP    // \ LSW MSW -- MSW LSW
 3037    00000014 ........              DC32    OVER    // \ MSW LSW -- MSW LSW MSW
 3038    00000018 ........              DC32    DABS    // \ MSW LSW MSW -- MSW uLSW uMSW
 3039    0000001C ........              DC32    BDIGS   // <# SET HLD to Pad
 3040    00000020 ........              DC32    DIGS    // \ d=<LSW MSW> -- d=<LSW MSW>
 3041    00000024 ........              DC32    SIGN    // \ d=<LSW MSW> -- d=<LSW MSW>
 3042    00000028 ........              DC32    EDIGS   //      #>  \ d=<LSW MSW>  ---  addr  count
 3043    0000002C ........              DC32    RFROM   // GET THE N CHAR FIELD LEN
 3044    00000030 ........              DC32    OVER    // \ addr count n -- addr count n count
 3045    00000034 ........              DC32    SUBB    // \ n addr count addr -- n addr count-n
 3046    00000038 ........              DC32    SPACES  // SPACES  \ n --
 3047    0000003C ........              DC32    TYPE    // \ n addr --
 3048    00000040 ........              DC32    SEMIS
 3049                           
 3050                           
 3051                           
 3052                           //      .R DOTR:        ( sn1 n2 -- ) SIGNED:
 3053                           //      Print the signed number sn1 right aligned in a field whose width is n2.
 3054                           //      No following blank is printed.
 3055                           
 3056                            SECTION .text : CONST (2)
 3057                           DOTR_NFA:
 3058    00000000 82                    DC8     0x82
 3059    00000001 2E                    DC8     '.'
 3060    00000002 D2                    DC8     'R'+0x80
 3061    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3062    00000004 ........              DC32    DDOTR_NFA
 3063                           DOTR:
 3064    00000008 ........              DC32    DOCOL
 3065    0000000C ........              DC32    TOR
 3066    00000010 ........              DC32    STOD
 3067    00000014 ........              DC32    RFROM
 3068    00000018 ........              DC32    DDOTR
 3069    0000001C ........              DC32    SEMIS
 3070                           
 3071                           
 3072                           //      .RU DOTRU:      ( n1 n2 -- ) UNSIGNED:
 3073                           //      Print the unsigned number n1 right aligned in a field whose width is n2.
 3074                           //      No following blank is printed.
 3075                           
 3076                            SECTION .text : CONST (2)
 3077                           DOTRU_NFA:
 3078    00000000 83                    DC8     0x83
 3079    00000001 2E52                  DC8     '.R'
 3080    00000003 D5                    DC8     'U'+0x80
 3081                            ALIGNROM 2,0xFFFFFFFF
 3082    00000004 ........              DC32    DOTR_NFA
 3083                           DOTRU:
 3084    00000008 ........              DC32    DOCOL
 3085    0000000C ........              DC32    TOR
 3086    00000010 ........              DC32    ZERO
 3087    00000014 .............         DC32    BDIGS, DIGS, EDIGS
                  ...........  
 3088    00000020 .............         DC32    DUP, RFROM
                  ...          
 3089    00000028 .............         DC32    SWAP, SUBB, SPACES, TYPE
                  .............
                  ......       
 3090                           #ifdef IO2TP
 3094                           #endif
 3095    00000038 ........              DC32    SEMIS
 3096                           
 3097                           
 3098                           //      D. DDOT:        ( S32-2'S COMPLEMET = (d=<LSW MSW> -- )
 3099                           //      Print a signed double number from a 32 bit two's complement value.
 3100                           //      The high-order 32 bits are most accessable on the stack. Conversion
 3101                           //      is performed according to the current base. A blank follows.
 3102                           
 3103                            SECTION .text : CONST (2)
 3104                           DDOT_NFA:
 3105    00000000 82                    DC8     0x82
 3106    00000001 44                    DC8     'D'
 3107    00000002 AE                    DC8     '.'+0x80
 3108    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3109    00000004 ........              DC32    DOTRU_NFA
 3110                           DDOT:
 3111    00000008 ........              DC32    DOCOL
 3112    0000000C ........              DC32    ZERO
 3113    00000010 ........              DC32    DDOTR
 3114    00000014 ........              DC32    SPACE
 3115    00000018 ........              DC32    SEMIS
 3116                           
 3117                           
 3118                           //      U. UDOT:        ( n -- ) USIGNED DOT
 3119                           
 3120                            SECTION .text : CONST (2)
 3121                           UDOT_NFA:
 3122    00000000 82                    DC8     0x82
 3123    00000001 55                    DC8     'U'
 3124    00000002 AE                    DC8     '.'+0x80
 3125    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3126    00000004 ........              DC32    DDOT_NFA
 3127                           UDOT:
 3128    00000008 ........              DC32    DOCOL
 3129    0000000C ........              DC32    ZERO
 3130    00000010 ........              DC32    DDOT    // SPACE DONE HERE
 3131    00000014 ........              DC32    SEMIS
 3132                           
 3133                           
 3134                           //      . DOT:  ( n -- ) SIGNED 2'S COMPLEMENT:
 3135                           //      Print a number from a signed 32 bit two's complement value,
 3136                           //      converted according to the numeric base.
 3137                           //      A trailing blanks follows.
 3138                           
 3139                            SECTION .text : CONST (2)
 3140                           DOT_NFA:
 3141    00000000 81                    DC8     0x81
 3142    00000001 AE                    DC8     '.'+0x80
 3143    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3144    00000004 ........              DC32    UDOT_NFA
 3145                           DOT:
 3146    00000008 ........              DC32    DOCOL
 3147    0000000C ........              DC32    STOD
 3148    00000010 ........              DC32    DDOT    // SPACE DONE HERE
 3149    00000014 ........              DC32    SEMIS
 3150                           
 3151                           
 3152                           //      ? QUES: ( addr -- ) Print number at addr
 3153                           //      Print the value contained at the address in free format according to
 3154                           //      the current base using DOT.
 3155                           
 3156                            SECTION .text : CONST (2)
 3157                           QUES_NFA:
 3158    00000000 81                    DC8     0x81
 3159    00000001 BF                    DC8     '?'+0x80
 3160    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3161    00000004 ........              DC32    DOT_NFA
 3162                           QUES:
 3163    00000008 ........              DC32    DOCOL
 3164    0000000C ........              DC32    AT
 3165    00000010 ........              DC32    DOT
 3166    00000014 ........              DC32    SEMIS
 3167                           
 3168                           
 3169                           //      S->D STOD:      ( n -- d=<LSW MSW> ) SIGNED:
 3170                           //      Sign extend a single number to form a double number.
 3171                           //      : S->D DUP 0< NEGATE // hi level equivalent
 3172                           
 3173                            SECTION .text : CONST (2)
 3174                           STOD_NFA:
 3175    00000000 84                    DC8     0x84
 3176    00000001 532D3E                DC8     'S->'
 3177    00000004 C4                    DC8     'D'+0x80
 3178    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3179    00000008 ........              DC32    QUES_NFA
 3180                           STOD:
 3181    0000000C ........              DC32    .+5
 3182                            SECTION .text : CODE (2)
 3183                                   POP2w                   // POP LSW
 3183.1  00000000 57F8042B              LDR     w, [p],#4
 3183.2                         //      LDR     w, [p]
 3183.3                         //      ADDS    p, p, #4
 3183.4                                 ENDM
 3184    00000004 4040                  EORS    t, t, t         // Zero MSW
 3185    00000006 1243                  ORRS    w, w, w         // OR LSW
 3186    00000008 00D5                  BPL     STOD1           // LSW is POS
 3187                           
 3188    0000000A 401E                  SUBS     t, t, #1       // LSW is NEG
 3189                           STOD1:
 3190                                   DPUSH                   //  --  LSW MSW )
 3190                                   PUSHw   // push w to p, post decrement p
 3190.1  0000000C 47F8042D              STR     w, [p, #-4]!
 3190.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 3190.3                         //      STR     w, [p]
 3190.4                                 ENDM
 3190                                   TPUSH
 3190                                   PUSHt   // push t to p, pre decrement p
 3190.1  00000010 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3190.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3190.3                         //      STR     t, [p]
 3190.4                                 ENDM
 3190                                   NEXT
 3190.1                         // ARMv7-M Thumb = .+5
 3190.2  00000014 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3190.3                         // ARMv6-M Thumb = .+4
 3190.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3190                                   NEXT1
 3190.1  00000018 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3190.2  0000001C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3190.3  00000020 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3190.4                         // ARMv6-M Thumb = .+4
 3190.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3190.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3190.7                                 ENDM
 3190.8                                 ENDM
 3190.9                                 ENDM
 3190.10                                ENDM
 3191                           
 3192                           
 3193                           //      ABS ABS:        ( n -- ub )
 3194                           //      Leave the absolute value of n as un.
 3195                           
 3196                            SECTION .text : CONST (2)
 3197                           ABS_NFA:
 3198    00000000 83                    DC8     0x83
 3199    00000001 4142                  DC8     'AB'
 3200    00000003 D3                    DC8     'S'+0x80
 3201                            ALIGNROM 2,0xFFFFFFFF
 3202    00000004 ........              DC32    STOD_NFA
 3203                           /* THIS HANGS IN UART_INIT WITH 2580 BAUD VALUE IN t and n
 3204                           ABS:
 3205                                   DC32    .+5
 3206                            SECTION .text : CODE (2)
 3207                                   POP2n
 3208                                   MOVS    t, n    // Set flags
 3209                                   IT MI
 3210                                   RSBMI   t, n, #0
 3211                                   PUSHt
 3212                           */
 3213                           ABS:
 3214    00000008 ........              DC32    DOCOL
 3215    0000000C ........              DC32    DUP
 3216    00000010 ........              DC32    PM
 3217    00000014 ........              DC32    SEMIS
 3218                           
 3219                           
 3220                           //      DABS DABS: ( sd=(LSW MSW) -- ud=(LSW MSW) )
 3221                           //      Leave the absolute value ud of a signed double number.
 3222                           
 3223                            SECTION .text : CONST (2)
 3224                           DABS_NFA:
 3225    00000000 84                    DC8     0x84
 3226    00000001 444142                DC8     'DAB'
 3227    00000004 D3                    DC8     'S'+0x80
 3228    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3229    00000008 ........              DC32    ABS_NFA
 3230                           DABSF:
 3231                           DABS:
 3232    0000000C ........              DC32    DOCOL
 3233    00000010 ........              DC32    DUP
 3234    00000014 ........              DC32    DPM
 3235    00000018 ........              DC32    SEMIS
 3236                           
 3237                           //      MIN MIN:        ( n1 n2 -- min )
 3238                           //      Leave the smaller of two numbers.
 3239                           
 3240                            SECTION .text : CONST (2)
 3241                           MIN_NFA:
 3242    00000000 83                    DC8     0x83
 3243    00000001 4D49                  DC8     'MI'
 3244    00000003 CE                    DC8     'N'+0x80
 3245                            ALIGNROM 2,0xFFFFFFFF
 3246    00000004 ........              DC32    DABS_NFA
 3247                           MIN:
 3248    00000008 .............         DC32    DOCOL,TDUP
                  ...          
 3249    00000010 ........              DC32    GREATERTHAN
 3250    00000014 ........              DC32    ZBRAN   //IF
 3251    00000018 08000000              DC32     MIN1-.
 3252                           
 3253    0000001C ........              DC32    SWAP    //endif
 3254                           MIN1:
 3255    00000020 ........              DC32    DROP
 3256    00000024 ........              DC32    SEMIS
 3257                           
 3258                           
 3259                           //      MAX MAX:        ( n1 n2 -- max )
 3260                           //      Leave the greater of two numbers.
 3261                           
 3262                            SECTION .text : CONST (2)
 3263                           MAX_NFA:
 3264    00000000 83                    DC8     0x83
 3265    00000001 4D41                  DC8     'MA'
 3266    00000003 D8                    DC8     'X'+0x80
 3267                            ALIGNROM 2,0xFFFFFFFF
 3268    00000004 ........              DC32    MIN_NFA
 3269                           MAX:
 3270    00000008 .............         DC32    DOCOL,TDUP
                  ...          
 3271    00000010 ........              DC32    LESSTHAN
 3272    00000014 ........              DC32    ZBRAN   //IF
 3273    00000018 08000000              DC32     MAX1-.
 3274                           
 3275    0000001C ........              DC32    SWAP    //endif
 3276                           MAX1:
 3277    00000020 ........              DC32    DROP
 3278    00000024 ........              DC32    SEMIS
 3279                           
 3280                           
 3281                           //      M* MSTAR:       ( n1 n2 -- d=<S32LSW S32MSW> )  SIGNED:
 3282                           //      A mixed magnitude math operation which leaves the double number
 3283                           //      signed product of two signed number.
 3284                           
 3285                            SECTION .text : CONST (2)
 3286                           MSTAR_NFA:
 3287    00000000 82                    DC8     0x82
 3288    00000001 4D                    DC8     'M'
 3289    00000002 AA                    DC8     '*'+0x80
 3290    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3291    00000004 ........              DC32    MAX_NFA
 3292                           MSTAR:
 3293    00000008 .............         DC32    DOCOL,TDUP
                  ...          
 3294    00000010 ........              DC32    XORR
 3295    00000014 ........              DC32    TOR
 3296    00000018 ........              DC32    ABS
 3297    0000001C ........              DC32    SWAP
 3298    00000020 ........              DC32    ABS
 3299    00000024 ........              DC32    USTAR
 3300    00000028 ........              DC32    RFROM
 3301    0000002C ........              DC32    DPM
 3302    00000030 ........              DC32    SEMIS
 3303                           
 3304                           
 3305                           //      M/ MSLASH:      ( sd  n1  ---  d=<s32REM  S32QUO> )
 3306                           //      A mixed magnitude math operator which leaves the signed remainder
 3307                           //      and signed quotient from sd, a double number dividend and divisor n1.
 3308                           //      The remainder takes its sign from the dividend.
 3309                           
 3310                            SECTION .text : CONST (2)
 3311                           MSLASH_NFA:
 3312    00000000 82                    DC8     0x82
 3313    00000001 4D                    DC8     'M'
 3314    00000002 AF                    DC8     '/'+0x80
 3315    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3316    00000004 ........              DC32    MSTAR_NFA
 3317                           MSLASH:
 3318    00000008 ........              DC32    DOCOL
 3319    0000000C ........              DC32    OVER
 3320    00000010 ........              DC32    TOR
 3321    00000014 ........              DC32    TOR
 3322    00000018 ........              DC32    DABS    // \ LSW MSW -- uLSW uMSW
 3323    0000001C ........              DC32    R
 3324    00000020 ........              DC32    ABS
 3325    00000024 ........              DC32    USLASH
 3326    00000028 ........              DC32    RFROM
 3327    0000002C ........              DC32    R
 3328    00000030 ........              DC32    XORR
 3329    00000034 ........              DC32    PM
 3330    00000038 ........              DC32    SWAP
 3331    0000003C ........              DC32    RFROM
 3332    00000040 ........              DC32    PM
 3333    00000044 ........              DC32    SWAP
 3334    00000048 ........              DC32    SEMIS
 3335                           
 3336                           
 3337                           //      * STAR: ( n1 n2 -- prod=n3 )
 3338                           //      Leave the signed product n3 of two (32bit) signed numbers n1 and n2.
 3339                           
 3340                            SECTION .text : CONST (2)
 3341                           STAR_NFA:
 3342    00000000 81                    DC8     0x81
 3343    00000001 AA                    DC8     '*'+0x80
 3344    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3345    00000004 ........              DC32    MSLASH_NFA
 3346                           STAR:
 3347    00000008 ........              DC32    DOCOL
 3348    0000000C ........              DC32    MSTAR
 3349    00000010 ........              DC32    DROP
 3350    00000014 ........              DC32    SEMIS
 3351                           
 3352                           
 3353                           //      /MOD SLMOD:     ( n1 n2 -- rem quot )   SIGNED:
 3354                           //      Leave the remainder and signed quotient of n1/n2. The remainder has
 3355                           //      the sign of the dividend.
 3356                           
 3357                            SECTION .text : CONST (2)
 3358                           SLMOD_NFA:
 3359    00000000 84                    DC8     0x84
 3360    00000001 2F4D4F                DC8     '/MO'
 3361    00000004 C4                    DC8     'D'+0x80
 3362    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3363    00000008 ........              DC32    STAR_NFA
 3364                           SLMOD:
 3365    0000000C ........              DC32    DOCOL
 3366    00000010 ........              DC32    TOR
 3367    00000014 ........              DC32    STOD
 3368    00000018 ........              DC32    RFROM
 3369    0000001C ........              DC32    MSLASH
 3370    00000020 ........              DC32    SEMIS
 3371                           
 3372                           
 3373                           //      / SLASH:        ( sn1 sn2 -- sn ) SIGNED:
 3374                           //      Leave the signed quotient sn of sn1/sn2.
 3375                           
 3376                            SECTION .text : CONST (2)
 3377                           SLASH_NFA:
 3378    00000000 81                    DC8     0x81
 3379    00000001 AF                    DC8     '/'+0x80
 3380    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3381    00000004 ........              DC32    SLMOD_NFA
 3382                           SLASH:
 3383    00000008 ........              DC32    DOCOL
 3384    0000000C ........              DC32    SLMOD
 3385    00000010 ........              DC32    SWAP
 3386    00000014 ........              DC32    DROP
 3387    00000018 ........              DC32    SEMIS
 3388                           
 3389                           
 3390                           //      MOD MOD:        ( sn1 n2 -- modulo )
 3391                           //      Leave the remainder of sn1/n2, with the same sign as sn1.
 3392                           
 3393                            SECTION .text : CONST (2)
 3394                           MODD_NFA:
 3395    00000000 83                    DC8     0x83
 3396    00000001 4D4F                  DC8     'MO'
 3397    00000003 C4                    DC8     'D'+0x80
 3398                            ALIGNROM 2,0xFFFFFFFF
 3399    00000004 ........              DC32    SLASH_NFA
 3400                           MOD:
 3401    00000008 ........              DC32    DOCOL
 3402    0000000C ........              DC32    SLMOD
 3403    00000010 ........              DC32    DROP
 3404    00000014 ........              DC32    SEMIS
 3405                           
 3406                           
 3407                           //      */MOD SSMOD:    ( n1 n2 n3 -- n4 n5 )
 3408                           //      Leave the quotient n5 and remainder n4 of the operation n1*n2/n3 A
 3409                           //      31 bit intermediate product is used as for */.
 3410                           
 3411                            SECTION .text : CONST (2)
 3412                           SSMOD_NFA:
 3413    00000000 85                    DC8     0x85
 3414    00000001 2A2F4D4F              DC8     '*/MO'
 3415    00000005 C4                    DC8     'D'+0x80
 3416    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 3417    00000008 ........              DC32    MODD_NFA
 3418                           SSMOD:
 3419    0000000C ........              DC32    DOCOL
 3420    00000010 ........              DC32    TOR
 3421    00000014 ........              DC32    MSTAR
 3422    00000018 ........              DC32    RFROM
 3423    0000001C ........              DC32    MSLASH
 3424    00000020 ........              DC32    SEMIS
 3425                           
 3426                           
 3427                           //      */ SSLASH:      ( n1 n2 n3 -- n4 )
 3428                           //      Leave the ratio n4 = n1*n2/n3 where all are signed numbers.
 3429                           //      Retention of an intermediate 31 bit product permits greater accuracy
 3430                           //      than would. be available with the sequence:
 3431                           //              n1  n2  *  n3  /
 3432                           
 3433                            SECTION .text : CONST (2)
 3434                           SSLASH_NFA:
 3435    00000000 82                    DC8     0x82
 3436    00000001 2A                    DC8     '*'
 3437    00000002 AF                    DC8     '/'+0x80
 3438    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3439    00000004 ........              DC32    SSMOD_NFA
 3440                           SSLASH:
 3441    00000008 ........              DC32    DOCOL
 3442    0000000C ........              DC32    SSMOD
 3443    00000010 ........              DC32    SWAP
 3444    00000014 ........              DC32    DROP
 3445    00000018 ........              DC32    SEMIS
 3446                           
 3447                           
 3448                           //      BIN BIN:        ( -- )
 3449                           //      Set the numeric conversion base to TWO (bianry).
 3450                           
 3451                            SECTION .text : CONST (2)
 3452                           BIN_NFA:
 3453    00000000 83                    DC8     0x83
 3454    00000001 4249                  DC8     'BI'
 3455    00000003 CE                    DC8     'N'+0x80
 3456                            ALIGNROM 2,0xFFFFFFFF
 3457    00000004 ........              DC32    SSLASH_NFA
 3458                           BIN:
 3459    00000008 ........              DC32    DOCOL
 3460    0000000C ........02000         DC32    strva, 2, NBASE
                  000........  
 3461    00000018 ........              DC32    SEMIS
 3462                           
 3463                           
 3464                           //      HEX HEX:        ( -- )
 3465                           //      Set the numeric conversion base to sixteen (hexadecimal).
 3466                           
 3467                            SECTION .text : CONST (2)
 3468                           HEX_NFA:
 3469    00000000 83                    DC8     0x83
 3470    00000001 4845                  DC8     'HE'
 3471    00000003 D8                    DC8     'X'+0x80
 3472                            ALIGNROM 2,0xFFFFFFFF
 3473    00000004 ........              DC32    BIN_NFA
 3474                           HEX:
 3475    00000008 ........              DC32    DOCOL
 3476    0000000C ........10000         DC32    strva, 16, NBASE
                  000........  
 3477    00000018 ........              DC32    SEMIS
 3478                           
 3479                           
 3480                           //      DECIMAL DECIMAL:        ( -- )
 3481                           //      Set the numeric conversion base to TEN (decimal).
 3482                           //      DEC IS A NUMBER!
 3483                           
 3484                            SECTION .text : CONST (2)
 3485                           DECIMAL_NFA:
 3486    00000000 87                    DC8     0x87
 3487    00000001 444543494D41          DC8     'DECIMA'
 3488    00000007 CC                    DC8     'L'+0x80
 3489                            ALIGNROM 2,0xFFFFFFFF
 3490    00000008 ........              DC32    HEX_NFA
 3491                           DECIMAL:
 3492    0000000C ........              DC32    DOCOL
 3493    00000010 ........0A000         DC32    strva, 10, NBASE
                  000........  
 3494    0000001C ........              DC32    SEMIS
 3495                           
 3496                           
 3497                           //      AND ANDD:       ( n1 n2 -- n2 )
 3498                           //      Leave the bitwise logical and of n1 and n2 as n3.
 3499                           
 3500                            SECTION .text : CONST (2)
 3501                           ANDD_NFA:
 3502    00000000 83                    DC8     0x83
 3503    00000001 414E                  DC8     'AN'
 3504    00000003 C4                    DC8     'D'+0x80
 3505                            ALIGNROM 2,0xFFFFFFFF
 3506    00000004 ........              DC32    DECIMAL_NFA
 3507                           ANDD:
 3508    00000008 ........              DC32    .+5
 3509                            SECTION .text : CODE (2)
 3510                                   POP2t
 3510.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3510.2                         //#ifndef TOSCT
 3510.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3510.4                         //#endif
 3510.5                         //      ADDS    p, p, #4
 3510.6                                 ENDM
 3511                                   POP2n
 3511.1  00000004 57F8041B              LDR     n, [p],#4
 3511.2                         //      LDR     n, [p]
 3511.3                         //      ADDS    p, p, #4
 3511.4                                 ENDM
 3512    00000008 0840                  ANDS     t, t, n
 3513                                   TPUSH
 3513                                   PUSHt   // push t to p, pre decrement p
 3513.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3513.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3513.3                         //      STR     t, [p]
 3513.4                                 ENDM
 3513                                   NEXT
 3513.1                         // ARMv7-M Thumb = .+5
 3513.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3513.3                         // ARMv6-M Thumb = .+4
 3513.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3513                                   NEXT1
 3513.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3513.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3513.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3513.4                         // ARMv6-M Thumb = .+4
 3513.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3513.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3513.7                                 ENDM
 3513.8                                 ENDM
 3513.9                                 ENDM
 3514                           
 3515                           
 3516                           //      OR OR:  ( n1 n2 -- n3 )
 3517                           //      Leave the bit-wise logical or of n1 and n2 as n3.
 3518                           
 3519                            SECTION .text : CONST (2)
 3520                           OR_NFA:
 3521    00000000 82                    DC8     0x82
 3522    00000001 4F                    DC8     'O'
 3523    00000002 D2                    DC8     'R'+0x80
 3524    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3525    00000004 ........              DC32    ANDD_NFA
 3526                           OR:
 3527    00000008 ........              DC32    .+5
 3528                            SECTION .text : CODE (2)
 3529                                   POP2t
 3529.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3529.2                         //#ifndef TOSCT
 3529.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3529.4                         //#endif
 3529.5                         //      ADDS    p, p, #4
 3529.6                                 ENDM
 3530                                   POP2n
 3530.1  00000004 57F8041B              LDR     n, [p],#4
 3530.2                         //      LDR     n, [p]
 3530.3                         //      ADDS    p, p, #4
 3530.4                                 ENDM
 3531    00000008 0843                  ORRS     t, t, n
 3532                                   TPUSH
 3532                                   PUSHt   // push t to p, pre decrement p
 3532.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3532.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3532.3                         //      STR     t, [p]
 3532.4                                 ENDM
 3532                                   NEXT
 3532.1                         // ARMv7-M Thumb = .+5
 3532.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3532.3                         // ARMv6-M Thumb = .+4
 3532.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3532                                   NEXT1
 3532.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3532.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3532.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3532.4                         // ARMv6-M Thumb = .+4
 3532.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3532.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3532.7                                 ENDM
 3532.8                                 ENDM
 3532.9                                 ENDM
 3533                           
 3534                           
 3535                           //      NOT NOT: ( nl -- n2 )
 3536                           //      Leave the bitwise logical not of n1 as n2
 3537                           
 3538                            SECTION .text : CONST (2)
 3539                           NOT_NFA:
 3540    00000000 83                    DC8     0x83
 3541    00000001 4E4F                  DC8     'NO'
 3542    00000003 D4                    DC8     'T'+0x80
 3543                            ALIGNROM 2,0xFFFFFFFF
 3544    00000004 ........              DC32    OR_NFA
 3545                           NOT:
 3546    00000008 ........              DC32    .+5
 3547                            SECTION .text : CODE (2)
 3548                                   POP2t
 3548.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3548.2                         //#ifndef TOSCT
 3548.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3548.4                         //#endif
 3548.5                         //      ADDS    p, p, #4
 3548.6                                 ENDM
 3549    00000004 C043                  MVNS            t, t    // 1's compliment
 3550                                   TPUSH
 3550                                   PUSHt   // push t to p, pre decrement p
 3550.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3550.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3550.3                         //      STR     t, [p]
 3550.4                                 ENDM
 3550                                   NEXT
 3550.1                         // ARMv7-M Thumb = .+5
 3550.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3550.3                         // ARMv6-M Thumb = .+4
 3550.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3550                                   NEXT1
 3550.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3550.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3550.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3550.4                         // ARMv6-M Thumb = .+4
 3550.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3550.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3550.7                                 ENDM
 3550.8                                 ENDM
 3550.9                                 ENDM
 3551                           
 3552                           
 3553                           //      XORR XOR:       ( nl n2 -- n3 )
 3554                           //      Leave the bitwise logical exclusive or n1 and n2 as n3
 3555                           
 3556                            SECTION .text : CONST (2)
 3557                           XORR_NFA:
 3558    00000000 83                    DC8     0x83
 3559    00000001 584F                  DC8     'XO'
 3560    00000003 D2                    DC8     'R'+0x80
 3561                            ALIGNROM 2,0xFFFFFFFF
 3562    00000004 ........              DC32    NOT_NFA
 3563                           XORR:
 3564    00000008 ........              DC32    .+5
 3565                            SECTION .text : CODE (2)
 3566                                   POP2t
 3566.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3566.2                         //#ifndef TOSCT
 3566.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3566.4                         //#endif
 3566.5                         //      ADDS    p, p, #4
 3566.6                                 ENDM
 3567                                   POP2n
 3567.1  00000004 57F8041B              LDR     n, [p],#4
 3567.2                         //      LDR     n, [p]
 3567.3                         //      ADDS    p, p, #4
 3567.4                                 ENDM
 3568    00000008 4840                  EORS     t, t, n
 3569                                   TPUSH
 3569                                   PUSHt   // push t to p, pre decrement p
 3569.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3569.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3569.3                         //      STR     t, [p]
 3569.4                                 ENDM
 3569                                   NEXT
 3569.1                         // ARMv7-M Thumb = .+5
 3569.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3569.3                         // ARMv6-M Thumb = .+4
 3569.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3569                                   NEXT1
 3569.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3569.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3569.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3569.4                         // ARMv6-M Thumb = .+4
 3569.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3569.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3569.7                                 ENDM
 3569.8                                 ENDM
 3569.9                                 ENDM
 3570                           
 3571                           
 3572                           //      REVW REVW:      ( n -- n )
 3573                           //      Reverse bytes in n.
 3574                           
 3575                            SECTION .text : CONST (2)
 3576                           REVW_NFA:
 3577    00000000 84                    DC8     0x84
 3578    00000001 524556                DC8     'REV'
 3579    00000004 D7                    DC8     'W'+0x80
 3580    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3581    00000008 ........              DC32    XORR_NFA
 3582                           REVW:
 3583    0000000C ........              DC32    .+5
 3584                            SECTION .text : CODE (2)
 3585                                   POP2t
 3585.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3585.2                         //#ifndef TOSCT
 3585.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3585.4                         //#endif
 3585.5                         //      ADDS    p, p, #4
 3585.6                                 ENDM
 3586                           // IMPORT C_CMSIS_REV
 3587                           //        BL      C_CMSIS_REV
 3588    00000004 00BA                  REV     t, t
 3589                                   TPUSH
 3589                                   PUSHt   // push t to p, pre decrement p
 3589.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3589.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3589.3                         //      STR     t, [p]
 3589.4                                 ENDM
 3589                                   NEXT
 3589.1                         // ARMv7-M Thumb = .+5
 3589.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3589.3                         // ARMv6-M Thumb = .+4
 3589.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3589                                   NEXT1
 3589.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3589.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3589.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3589.4                         // ARMv6-M Thumb = .+4
 3589.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3589.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3589.7                                 ENDM
 3589.8                                 ENDM
 3589.9                                 ENDM
 3590                           
 3591                           
 3592                           //      ASR ASR:   ( sn count -- sn' )  
 3593                           //      Shift sn (sign-extended) right by count.
 3594                           //      Valid count values are 0 to 31.
 3595                           
 3596                            SECTION .text : CONST (2)
 3597                           ASR_NFA:
 3598    00000000 83                    DC8     0x83
 3599    00000001 4153                  DC8     'AS'
 3600    00000003 D2                    DC8     'R'+0x80
 3601                            ALIGNROM 2,0xFFFFFFFF
 3602    00000004 ........              DC32    REVW_NFA
 3603                           ASR:
 3604    00000008 ........              DC32    .+5
 3605                            SECTION .text : CODE (2)
 3606                                   POP2w           ; shift count
 3606.1  00000000 57F8042B              LDR     w, [p],#4
 3606.2                         //      LDR     w, [p]
 3606.3                         //      ADDS    p, p, #4
 3606.4                                 ENDM
 3607                                   POP2t           ; original data
 3607.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 3607.2                         //#ifndef TOSCT
 3607.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3607.4                         //#endif
 3607.5                         //      ADDS    p, p, #4
 3607.6                                 ENDM
 3608    00000008 1041                  ASRS    t, t, w
 3609                                   TPUSH           ; shifted data
 3609                                   PUSHt   // push t to p, pre decrement p
 3609.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3609.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3609.3                         //      STR     t, [p]
 3609.4                                 ENDM
 3609                                   NEXT
 3609.1                         // ARMv7-M Thumb = .+5
 3609.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3609.3                         // ARMv6-M Thumb = .+4
 3609.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3609                                   NEXT1
 3609.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3609.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3609.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3609.4                         // ARMv6-M Thumb = .+4
 3609.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3609.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3609.7                                 ENDM
 3609.8                                 ENDM
 3609.9                                 ENDM
 3610                           
 3611                           
 3612                           //      LSR LSR:   ( n count -- n' )
 3613                           //      Logical (zero-extended) shift right by count.
 3614                           //      Valid count values are 0 to 31.
 3615                           
 3616                            SECTION .text : CONST (2)
 3617                           LSR_NFA:
 3618    00000000 83                    DC8     0x83
 3619    00000001 4C53                  DC8     'LS'
 3620    00000003 D2                    DC8     'R'+0x80
 3621                            ALIGNROM 2,0xFFFFFFFF
 3622    00000004 ........              DC32    ASR_NFA
 3623                           LSR:
 3624    00000008 ........              DC32    .+5
 3625                            SECTION .text : CODE (2)
 3626                                   POP2w           ; shift count
 3626.1  00000000 57F8042B              LDR     w, [p],#4
 3626.2                         //      LDR     w, [p]
 3626.3                         //      ADDS    p, p, #4
 3626.4                                 ENDM
 3627                                   POP2t           ; original data
 3627.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 3627.2                         //#ifndef TOSCT
 3627.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3627.4                         //#endif
 3627.5                         //      ADDS    p, p, #4
 3627.6                                 ENDM
 3628    00000008 D040                  LSRS    t, t, w
 3629                                   TPUSH           ; shifted data
 3629                                   PUSHt   // push t to p, pre decrement p
 3629.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3629.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3629.3                         //      STR     t, [p]
 3629.4                                 ENDM
 3629                                   NEXT
 3629.1                         // ARMv7-M Thumb = .+5
 3629.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3629.3                         // ARMv6-M Thumb = .+4
 3629.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3629                                   NEXT1
 3629.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3629.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3629.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3629.4                         // ARMv6-M Thumb = .+4
 3629.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3629.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3629.7                                 ENDM
 3629.8                                 ENDM
 3629.9                                 ENDM
 3630                           
 3631                           
 3632                           //      LSL LSL:   ( n count -- n' )
 3633                           //      Logical (zero-extended) shift left by count.
 3634                           //      Valid count values are 0 to 31.
 3635                           
 3636                            SECTION .text : CONST (2)
 3637                           LSL_NFA:
 3638    00000000 83                    DC8     0x83
 3639    00000001 4C53                  DC8     'LS'
 3640    00000003 CC                    DC8     'L'+0x80
 3641                            ALIGNROM 2,0xFFFFFFFF
 3642    00000004 ........              DC32    LSR_NFA
 3643                           LSL:
 3644    00000008 ........              DC32    .+5
 3645                            SECTION .text : CODE (2)
 3646                                   POP2w           ; shift count
 3646.1  00000000 57F8042B              LDR     w, [p],#4
 3646.2                         //      LDR     w, [p]
 3646.3                         //      ADDS    p, p, #4
 3646.4                                 ENDM
 3647                                   POP2t           ; original data
 3647.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 3647.2                         //#ifndef TOSCT
 3647.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3647.4                         //#endif
 3647.5                         //      ADDS    p, p, #4
 3647.6                                 ENDM
 3648    00000008 9040                  LSLS    t, t, w
 3649                                   TPUSH           ; shifted data---
 3649                                   PUSHt   // push t to p, pre decrement p
 3649.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3649.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3649.3                         //      STR     t, [p]
 3649.4                                 ENDM
 3649                                   NEXT
 3649.1                         // ARMv7-M Thumb = .+5
 3649.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3649.3                         // ARMv6-M Thumb = .+4
 3649.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3649                                   NEXT1
 3649.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3649.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3649.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3649.4                         // ARMv6-M Thumb = .+4
 3649.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3649.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3649.7                                 ENDM
 3649.8                                 ENDM
 3649.9                                 ENDM
 3650                           
 3651                           
 3652                           //      + PLUS: ( n1 n2 -- n3 )
 3653                           //      Add n1 and n2, leaving sum n3
 3654                           
 3655                            SECTION .text : CONST (2)
 3656                           PLUS_NFA:
 3657    00000000 81                    DC8     0x81
 3658    00000001 AB                    DC8     0xAB    // '+' + 0x80
 3659    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3660    00000004 ........              DC32    LSL_NFA
 3661                           PLUS:
 3662    00000008 ........              DC32    .+5
 3663                            SECTION .text : CODE (2)
 3664                                   POP2t
 3664.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3664.2                         //#ifndef TOSCT
 3664.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3664.4                         //#endif
 3664.5                         //      ADDS    p, p, #4
 3664.6                                 ENDM
 3665                                   POP2n
 3665.1  00000004 57F8041B              LDR     n, [p],#4
 3665.2                         //      LDR     n, [p]
 3665.3                         //      ADDS    p, p, #4
 3665.4                                 ENDM
 3666    00000008 4018                  ADDS    t, t, n
 3667                                   TPUSH
 3667                                   PUSHt   // push t to p, pre decrement p
 3667.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3667.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3667.3                         //      STR     t, [p]
 3667.4                                 ENDM
 3667                                   NEXT
 3667.1                         // ARMv7-M Thumb = .+5
 3667.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3667.3                         // ARMv6-M Thumb = .+4
 3667.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3667                                   NEXT1
 3667.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3667.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3667.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3667.4                         // ARMv6-M Thumb = .+4
 3667.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3667.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3667.7                                 ENDM
 3667.8                                 ENDM
 3667.9                                 ENDM
 3668                           
 3669                           
 3670                           //      - SUBB: ( n1 n2 -- n3 )
 3671                           //      Leave the difference of n1-n2 as n3.
 3672                           //      1 2 - . -1
 3673                           //      2 1 - .  1
 3674                           
 3675                            SECTION .text : CONST (2)
 3676                           SUB_NFA:
 3677    00000000 81                    DC8     0x81
 3678    00000001 AD                    DC8     '-'+0x80
 3679    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3680    00000004 ........              DC32    PLUS_NFA
 3681                           SUBB:
 3682    00000008 ........              DC32    .+5
 3683                            SECTION .text : CODE (2)
 3684                                   POP2t
 3684.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3684.2                         //#ifndef TOSCT
 3684.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3684.4                         //#endif
 3684.5                         //      ADDS    p, p, #4
 3684.6                                 ENDM
 3685                                   POP2n
 3685.1  00000004 57F8041B              LDR     n, [p],#4
 3685.2                         //      LDR     n, [p]
 3685.3                         //      ADDS    p, p, #4
 3685.4                                 ENDM
 3686    00000008 081A                  SUBS    t, n, t
 3687                                   TPUSH
 3687                                   PUSHt   // push t to p, pre decrement p
 3687.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3687.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3687.3                         //      STR     t, [p]
 3687.4                                 ENDM
 3687                                   NEXT
 3687.1                         // ARMv7-M Thumb = .+5
 3687.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3687.3                         // ARMv6-M Thumb = .+4
 3687.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3687                                   NEXT1
 3687.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3687.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3687.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3687.4                         // ARMv6-M Thumb = .+4
 3687.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3687.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3687.7                                 ENDM
 3687.8                                 ENDM
 3687.9                                 ENDM
 3688                           
 3689                           
 3690                           //      = EQUAL:        (n1 n2 -- f )
 3691                           //      Leave a non-zero true flag if n1=n2// otherwise leave a false flag.
 3692                           
 3693                            SECTION .text : CONST (2)
 3694                           EQUAL_NFA:
 3695    00000000 81                    DC8     0x81
 3696    00000001 BD                    DC8     '='+0x80
 3697    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3698    00000004 ........              DC32    SUB_NFA
 3699                           EQUAL:
 3700                           ///* TEST FOR v1.6
 3701    00000008 ........              DC32    .+5
 3702                            SECTION .text : CODE (2)
 3703                                   POP2t
 3703.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3703.2                         //#ifndef TOSCT
 3703.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3703.4                         //#endif
 3703.5                         //      ADDS    p, p, #4
 3703.6                                 ENDM
 3704                                   POP2n
 3704.1  00000004 57F8041B              LDR     n, [p],#4
 3704.2                         //      LDR     n, [p]
 3704.3                         //      ADDS    p, p, #4
 3704.4                                 ENDM
 3705    00000008 401A                  SUBS    t, t, n
 3706    0000000A 09D0                  BEQ     EQUAL_TRUE
 3707    0000000C 4040                  EORS    t, t
 3708                                   TPUSH
 3708                                   PUSHt   // push t to p, pre decrement p
 3708.1  0000000E 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3708.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3708.3                         //      STR     t, [p]
 3708.4                                 ENDM
 3708                                   NEXT
 3708.1                         // ARMv7-M Thumb = .+5
 3708.2  00000012 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3708.3                         // ARMv6-M Thumb = .+4
 3708.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3708                                   NEXT1
 3708.1  00000016 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3708.2  0000001A 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3708.3  0000001E 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3708.4                         // ARMv6-M Thumb = .+4
 3708.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3708.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3708.7                                 ENDM
 3708.8                                 ENDM
 3708.9                                 ENDM
 3709                           
 3710                           EQUAL_TRUE:
 3711    00000020 0120                  MOVS    t, #1
 3712                                   TPUSH
 3712                                   PUSHt   // push t to p, pre decrement p
 3712.1  00000022 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3712.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3712.3                         //      STR     t, [p]
 3712.4                                 ENDM
 3712                                   NEXT
 3712.1                         // ARMv7-M Thumb = .+5
 3712.2  00000026 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3712.3                         // ARMv6-M Thumb = .+4
 3712.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3712                                   NEXT1
 3712.1  0000002A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3712.2  0000002E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3712.3  00000032 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3712.4                         // ARMv6-M Thumb = .+4
 3712.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3712.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3712.7                                 ENDM
 3712.8                                 ENDM
 3712.9                                 ENDM
 3713                           //*/
 3714                           /*
 3715                                   DC32    DOCOL
 3716                                   DC32    SUBB
 3717                                   DC32    ZEQU
 3718                                   DC32    SEMIS
 3719                           */
 3720                           
 3721                           
 3722                           //      < LESSTHAN:     ( n1 n2 -- f ) SIGNED:
 3723                           //      Leave a true flag if n1 is less than n2 otherwise leave a false flag.
 3724                           //      C0 1 < . 0  -1 C0 < . 1
 3725                           
 3726                            SECTION .text : CONST (2)
 3727                           LESSTHAN_NFA:
 3728    00000000 81                    DC8     0x81
 3729    00000001 BC                    DC8     '<'+0x80
 3730    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3731    00000004 ........              DC32    EQUAL_NFA
 3732                           LESSTHAN:
 3733    00000008 ........              DC32    .+5
 3734                            SECTION .text : CODE (2)
 3735    00000000 0120                  MOVS    t, #1
 3736                                   POP2n                   // n2
 3736.1  00000002 57F8041B              LDR     n, [p],#4
 3736.2                         //      LDR     n, [p]
 3736.3                         //      ADDS    p, p, #4
 3736.4                                 ENDM
 3737                                   POP2w                   // n1
 3737.1  00000006 57F8042B              LDR     w, [p],#4
 3737.2                         //      LDR     w, [p]
 3737.3                         //      ADDS    p, p, #4
 3737.4                                 ENDM
 3738    0000000A 9142                  CMP     n, w            // n1 < n2
 3739    0000000C 00DC                  BGT     LESS1
 3740                           
 3741    0000000E 4040                  EORS    t, t, t         // zero t =< n
 3742                           LESS1:
 3743                                   TPUSH
 3743                                   PUSHt   // push t to p, pre decrement p
 3743.1  00000010 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3743.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3743.3                         //      STR     t, [p]
 3743.4                                 ENDM
 3743                                   NEXT
 3743.1                         // ARMv7-M Thumb = .+5
 3743.2  00000014 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3743.3                         // ARMv6-M Thumb = .+4
 3743.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3743                                   NEXT1
 3743.1  00000018 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3743.2  0000001C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3743.3  00000020 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3743.4                         // ARMv6-M Thumb = .+4
 3743.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3743.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3743.7                                 ENDM
 3743.8                                 ENDM
 3743.9                                 ENDM
 3744                           
 3745                           
 3746                           //      U< ULESSTHAN:   ( n1 n2 -- f )  UNSIGNED:
 3747                           //      Leave a true flag if n1 is less than n2 otherwise leave a false flag.
 3748                           //      -1 -2 U< . 0  -1 2 U< . 0  1 2 U< . 1
 3749                           
 3750                            SECTION .text : CONST (2)
 3751                           ULESSTHAN_NFA:
 3752    00000000 82                    DC8     0x82
 3753    00000001 55                    DC8     'U'
 3754    00000002 BC                    DC8     '<'+0x80
 3755    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3756    00000004 ........              DC32    LESSTHAN_NFA
 3757                           ULESSTHAN:
 3758    00000008 .............         DC32    DOCOL,TDUP
                  ...          
 3759    00000010 .............         DC32    XORR, ZLESS
                  ...          
 3760    00000018 ........              DC32    ZBRAN
 3761    0000001C 18000000              DC32    ULES1-. //IF
 3762                           
 3763    00000020 .............         DC32    DROP, ZLESS
                  ...          
 3764    00000028 ........              DC32    ZEQU
 3765    0000002C ........              DC32    BRAN
 3766    00000030 0C000000              DC32    ULES2-.
 3767                           
 3768                           ULES1:
 3769    00000034 .............         DC32    SUBB,ZLESS      //ELSE
                  ...          
 3770                           
 3771                           ULES2:
 3772    0000003C ........              DC32    SEMIS           //endif
 3773                           
 3774                           
 3775                           //      > GREATERTHAN:  ( n1 n2 --  f ) SIGNED: L0
 3776                           //      Leave a true flag if n1 is greater than n2 otherwise a false flag.
 3777                           //      -1 1 > . 0  1 -1 > . 1
 3778                           
 3779                            SECTION .text : CONST (2)
 3780                           GREATERTHAN_NFA:
 3781    00000000 81                    DC8     0x81
 3782    00000001 BE                    DC8     '>'+0x80
 3783    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3784    00000004 ........              DC32    ULESSTHAN_NFA
 3785                           GREATERTHAN:
 3786    00000008 ........              DC32    DOCOL
 3787    0000000C ........              DC32    SWAP
 3788    00000010 ........              DC32    LESSTHAN
 3789    00000014 ........              DC32    SEMIS
 3790                           
 3791                           
 3792                           //      0= ZEQU:        ( n -- f )
 3793                           //      Leave a true flag is the number is equal to zero, otherwise leave a
 3794                           //      false flag. Code dependent on true being 1.
 3795                           
 3796                            SECTION .text : CONST (2)
 3797                           ZEQU_NFA:
 3798    00000000 82                    DC8     0x82
 3799    00000001 30                    DC8     '0'
 3800    00000002 BD                    DC8     '='+0x80
 3801    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3802    00000004 ........              DC32    GREATERTHAN_NFA
 3803                           ZEQU:
 3804    00000008 ........              DC32    .+5
 3805                            SECTION .text : CODE (2)
 3806                                   POP2t
 3806.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3806.2                         //#ifndef TOSCT
 3806.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3806.4                         //#endif
 3806.5                         //      ADDS    p, p, #4
 3806.6                                 ENDM
 3807    00000004 0028                  CMP     t, #0
 3808    00000006 09D1                  BNE     ZEQU1
 3809                           
 3810    00000008 401C                  ADDS    t, t, #1
 3811                                   TPUSH
 3811                                   PUSHt   // push t to p, pre decrement p
 3811.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3811.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3811.3                         //      STR     t, [p]
 3811.4                                 ENDM
 3811                                   NEXT
 3811.1                         // ARMv7-M Thumb = .+5
 3811.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3811.3                         // ARMv6-M Thumb = .+4
 3811.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3811                                   NEXT1
 3811.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3811.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3811.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3811.4                         // ARMv6-M Thumb = .+4
 3811.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3811.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3811.7                                 ENDM
 3811.8                                 ENDM
 3811.9                                 ENDM
 3812                           ZEQU1:
 3813    0000001C 4040                  EORS    t, t, t    // zero t
 3814                                   TPUSH
 3814                                   PUSHt   // push t to p, pre decrement p
 3814.1  0000001E 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3814.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3814.3                         //      STR     t, [p]
 3814.4                                 ENDM
 3814                                   NEXT
 3814.1                         // ARMv7-M Thumb = .+5
 3814.2  00000022 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3814.3                         // ARMv6-M Thumb = .+4
 3814.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3814                                   NEXT1
 3814.1  00000026 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3814.2  0000002A 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3814.3  0000002E 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3814.4                         // ARMv6-M Thumb = .+4
 3814.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3814.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3814.7                                 ENDM
 3814.8                                 ENDM
 3814.9                                 ENDM
 3815                           
 3816                           
 3817                           //      0< ZLESS:       ( n -- f )
 3818                           //      Leave a true flag if the number is less than zero (negative),
 3819                           //      otherwise leave a false flag.
 3820                           
 3821                            SECTION .text : CONST (2)
 3822                           ZLESS_NFA:
 3823    00000000 82                    DC8     0x82
 3824    00000001 30                    DC8     '0'
 3825    00000002 BC                    DC8     '<'+0x80
 3826    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3827    00000004 ........              DC32    ZEQU_NFA
 3828                           ZLESS:
 3829    00000008 ........              DC32    .+5
 3830                            SECTION .text : CODE (2)
 3831                           #ifdef TOSCT    // REPLACING t SO THIS IS FASTER THAN POP2n
 3834                           #else
 3835                                   POP2n
 3835.1  00000000 57F8041B              LDR     n, [p],#4
 3835.2                         //      LDR     n, [p]
 3835.3                         //      ADDS    p, p, #4
 3835.4                                 ENDM
 3836                           #endif
 3837    00000004 0120                  MOVS    t, #1   // TRUE
 3838    00000006 0943                  ORRS    n, n, n // SET FLAGS
 3839    00000008 00D4                  BMI     ZLESS1  // JS   ZLESS1
 3840                           
 3841    0000000A 0020                  MOVS    t, #0   // FALSE
 3842                           ZLESS1:
 3843                                   TPUSH
 3843                                   PUSHt   // push t to p, pre decrement p
 3843.1  0000000C 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3843.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3843.3                         //      STR     t, [p]
 3843.4                                 ENDM
 3843                                   NEXT
 3843.1                         // ARMv7-M Thumb = .+5
 3843.2  00000010 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3843.3                         // ARMv6-M Thumb = .+4
 3843.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3843                                   NEXT1
 3843.1  00000014 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3843.2  00000018 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3843.3  0000001C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3843.4                         // ARMv6-M Thumb = .+4
 3843.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3843.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3843.7                                 ENDM
 3843.8                                 ENDM
 3843.9                                 ENDM
 3844                           
 3845                           
 3846                           //      D+ DPLUS:       ( LSW1 MSW1 LSW2 MSW2 --- LSW MSW )  SIGNED:
 3847                           //      Leave the signed double number sum of two signed double numbers.
 3848                           
 3849                            SECTION .text : CONST (2)
 3850                           DPLUS_NFA:
 3851    00000000 82                    DC8     0x82
 3852    00000001 44                    DC8     'D'
 3853    00000002 AB                    DC8     '+'+0x80
 3854    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3855    00000004 ........              DC32    ZLESS_NFA
 3856                           DPLUS:
 3857    00000008 ........              DC32    .+5
 3858                            SECTION .text : CODE (2)
 3859                                   POP2t   //    ldr     t, [p],#4       // MS
 3859.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3859.2                         //#ifndef TOSCT
 3859.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3859.4                         //#endif
 3859.5                         //      ADDS    p, p, #4
 3859.6                                 ENDM
 3860                                   POP2n   //    ldr     n, [p],#4       // LS
 3860.1  00000004 57F8041B              LDR     n, [p],#4
 3860.2                         //      LDR     n, [p]
 3860.3                         //      ADDS    p, p, #4
 3860.4                                 ENDM
 3861                                   POP2x   //    ldr     x, [p],#4       // MS
 3861.1  00000008 57F8043B              LDR     x, [p],#4
 3861.2                         //      LDR     x, [p]
 3861.3                         //      ADDS    p, p, #4
 3861.4                                 ENDM
 3862                                   POP2w   //    ldr     w, [p],#4       // LS
 3862.1  0000000C 57F8042B              LDR     w, [p],#4
 3862.2                         //      LDR     w, [p]
 3862.3                         //      ADDS    p, p, #4
 3862.4                                 ENDM
 3863    00000010 5218                  ADDS    w, w, n         // LS sum, set status flags
 3864    00000012 5841                  ADCS    t, t, x         // MS sum + carry
 3865                                   DPUSH                   //  --  LSW MSW )
 3865                                   PUSHw   // push w to p, post decrement p
 3865.1  00000014 47F8042D              STR     w, [p, #-4]!
 3865.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 3865.3                         //      STR     w, [p]
 3865.4                                 ENDM
 3865                                   TPUSH
 3865                                   PUSHt   // push t to p, pre decrement p
 3865.1  00000018 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3865.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3865.3                         //      STR     t, [p]
 3865.4                                 ENDM
 3865                                   NEXT
 3865.1                         // ARMv7-M Thumb = .+5
 3865.2  0000001C 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3865.3                         // ARMv6-M Thumb = .+4
 3865.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3865                                   NEXT1
 3865.1  00000020 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3865.2  00000024 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3865.3  00000028 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3865.4                         // ARMv6-M Thumb = .+4
 3865.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3865.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3865.7                                 ENDM
 3865.8                                 ENDM
 3865.9                                 ENDM
 3865.10                                ENDM
 3866                           
 3867                           
 3868                           //      NEGATE NEGATE: ( n1 -- n2 ) RENAMED: MINUS to NEGATE
 3869                           //      Leave the two's complement of a number.
 3870                           
 3871                            SECTION .text : CONST (2)
 3872                           NEGATE_NFA:
 3873    00000000 86                    DC8     0x86
 3874    00000001 4E45474154            DC8     'NEGAT'
 3875    00000006 C5                    DC8     'E'+0x80
 3876    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 3877    00000008 ........              DC32    DPLUS_NFA
 3878                           NEGATE:
 3879    0000000C ........              DC32    .+5
 3880                            SECTION .text : CODE (2)
 3881                                   POP2t                   // MVN YES
 3881.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3881.2                         //#ifndef TOSCT
 3881.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3881.4                         //#endif
 3881.5                         //      ADDS    p, p, #4
 3881.6                                 ENDM
 3882    00000004 C043                  MVNS     t, t           // 1's compliment
 3883    00000006 401C                  ADDS     t, t, #1       // 2's compliment
 3884                                   TPUSH
 3884                                   PUSHt   // push t to p, pre decrement p
 3884.1  00000008 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3884.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3884.3                         //      STR     t, [p]
 3884.4                                 ENDM
 3884                                   NEXT
 3884.1                         // ARMv7-M Thumb = .+5
 3884.2  0000000C 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3884.3                         // ARMv6-M Thumb = .+4
 3884.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3884                                   NEXT1
 3884.1  00000010 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3884.2  00000014 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3884.3  00000018 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3884.4                         // ARMv6-M Thumb = .+4
 3884.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3884.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3884.7                                 ENDM
 3884.8                                 ENDM
 3884.9                                 ENDM
 3885                           
 3886                           
 3887                           //      DNEGATE DNEGATE: ( d1 -- d<2>=(LSW MSW) ) RENAMED: DMINUS to DNEGATE
 3888                           //      Convert d1 to its double number two's complement d2.
 3889                           
 3890                            SECTION .text : CONST (2)
 3891                           DNEGATE_NFA:
 3892    00000000 87                    DC8     0x87
 3893    00000001 444E45474154          DC8     'DNEGAT'
 3894    00000007 C5                    DC8     'E'+0x80
 3895                            ALIGNROM 2,0xFFFFFFFF
 3896    00000008 ........              DC32    NEGATE_NFA
 3897                           DNEGATE:
 3898    0000000C ........              DC32    .+5
 3899                            SECTION .text : CODE (2)
 3900                                   POP2t                   // MSW   //POP  BX
 3900.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3900.2                         //#ifndef TOSCT
 3900.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3900.4                         //#endif
 3900.5                         //      ADDS    p, p, #4
 3900.6                                 ENDM
 3901                                   POP2w                   // LSW   //POP  CX
 3901.1  00000004 57F8042B              LDR     w, [p],#4
 3901.2                         //      LDR     w, [p]
 3901.3                         //      ADDS    p, p, #4
 3901.4                                 ENDM
 3902    00000008 C043                  MVNS    t, t            // negate MSW
 3903    0000000A D243                  MVNS    w, w            // negate LSW
 3904    0000000C 521C                  ADDS    w, w, #1        // add 1 to LSW
 3905                                   DPUSH                   //  --  LSW MSW )
 3905                                   PUSHw   // push w to p, post decrement p
 3905.1  0000000E 47F8042D              STR     w, [p, #-4]!
 3905.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 3905.3                         //      STR     w, [p]
 3905.4                                 ENDM
 3905                                   TPUSH
 3905                                   PUSHt   // push t to p, pre decrement p
 3905.1  00000012 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3905.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3905.3                         //      STR     t, [p]
 3905.4                                 ENDM
 3905                                   NEXT
 3905.1                         // ARMv7-M Thumb = .+5
 3905.2  00000016 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3905.3                         // ARMv6-M Thumb = .+4
 3905.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3905                                   NEXT1
 3905.1  0000001A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3905.2  0000001E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3905.3  00000022 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3905.4                         // ARMv6-M Thumb = .+4
 3905.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3905.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3905.7                                 ENDM
 3905.8                                 ENDM
 3905.9                                 ENDM
 3905.10                                ENDM
 3906                           
 3907                           
 3908                           //      2* TWOSTAR:     ( n -- n*2 ) LSL 1
 3909                           
 3910                            SECTION .text : CONST (2)
 3911                           TWOSTAR_NFA:
 3912    00000000 82                    DC8     0x82
 3913    00000001 32                    DC8     '2'
 3914    00000002 AA                    DC8     '*'+0x80
 3915    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3916    00000004 ........              DC32    DNEGATE_NFA
 3917                           TWOSTAR:
 3918    00000008 ........              DC32    .+5
 3919                            SECTION .text : CODE (2)
 3920                                   POP2t
 3920.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3920.2                         //#ifndef TOSCT
 3920.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3920.4                         //#endif
 3920.5                         //      ADDS    p, p, #4
 3920.6                                 ENDM
 3921    00000004 4000                  LSLS    t, t, #1        //
 3922                                   TPUSH
 3922                                   PUSHt   // push t to p, pre decrement p
 3922.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3922.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3922.3                         //      STR     t, [p]
 3922.4                                 ENDM
 3922                                   NEXT
 3922.1                         // ARMv7-M Thumb = .+5
 3922.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3922.3                         // ARMv6-M Thumb = .+4
 3922.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3922                                   NEXT1
 3922.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3922.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3922.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3922.4                         // ARMv6-M Thumb = .+4
 3922.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3922.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3922.7                                 ENDM
 3922.8                                 ENDM
 3922.9                                 ENDM
 3923                           
 3924                           
 3925                           //      2/ TWOSLASH:    ( n -- n/1 ) ASR 1 (FLOORED)
 3926                           
 3927                            SECTION .text : CONST (2)
 3928                           TWOSLASH_NFA:
 3929    00000000 82                    DC8     0x82
 3930    00000001 32                    DC8     '2'
 3931    00000002 AF                    DC8     '/'+0x80
 3932    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3933    00000004 ........              DC32    TWOSTAR_NFA
 3934                           TWOSLASH:
 3935    00000008 ........              DC32    .+5
 3936                            SECTION .text : CODE (2)
 3937                                   POP2t
 3937.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3937.2                         //#ifndef TOSCT
 3937.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3937.4                         //#endif
 3937.5                         //      ADDS    p, p, #4
 3937.6                                 ENDM
 3938    00000004 4010                  ASRS    t, t, #1        //
 3939                                   TPUSH
 3939                                   PUSHt   // push t to p, pre decrement p
 3939.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3939.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3939.3                         //      STR     t, [p]
 3939.4                                 ENDM
 3939                                   NEXT
 3939.1                         // ARMv7-M Thumb = .+5
 3939.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3939.3                         // ARMv6-M Thumb = .+4
 3939.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3939                                   NEXT1
 3939.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3939.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3939.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3939.4                         // ARMv6-M Thumb = .+4
 3939.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3939.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3939.7                                 ENDM
 3939.8                                 ENDM
 3939.9                                 ENDM
 3940                           
 3941                           
 3942                           //      1+ ONEP:        ( n -- n+1 )
 3943                           
 3944                            SECTION .text : CONST (2)
 3945                           ONEP_NFA:
 3946    00000000 82                    DC8     0x82
 3947    00000001 31                    DC8     '1'
 3948    00000002 AB                    DC8     '+'+0x80
 3949    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3950    00000004 ........              DC32    TWOSLASH_NFA
 3951                           ONEP:
 3952    00000008 ........              DC32    .+5
 3953                            SECTION .text : CODE (2)
 3954                                   POP2t
 3954.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3954.2                         //#ifndef TOSCT
 3954.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3954.4                         //#endif
 3954.5                         //      ADDS    p, p, #4
 3954.6                                 ENDM
 3955    00000004 401C                  ADDS    t, t, #1        //
 3956                                   TPUSH
 3956                                   PUSHt   // push t to p, pre decrement p
 3956.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3956.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3956.3                         //      STR     t, [p]
 3956.4                                 ENDM
 3956                                   NEXT
 3956.1                         // ARMv7-M Thumb = .+5
 3956.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3956.3                         // ARMv6-M Thumb = .+4
 3956.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3956                                   NEXT1
 3956.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3956.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3956.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3956.4                         // ARMv6-M Thumb = .+4
 3956.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3956.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3956.7                                 ENDM
 3956.8                                 ENDM
 3956.9                                 ENDM
 3957                           
 3958                           
 3959                           //      2+ TWOP:        ( n -- n+2 )
 3960                           
 3961                            SECTION .text : CONST (2)
 3962                           TWOP_NFA:
 3963    00000000 82                    DC8     0x82
 3964    00000001 32                    DC8     '2'
 3965    00000002 AB                    DC8     '+'+0x80
 3966    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3967    00000004 ........              DC32    ONEP_NFA
 3968                           TWOP:
 3969    00000008 ........              DC32    .+5
 3970                            SECTION .text : CODE (2)
 3971                                   POP2t
 3971.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3971.2                         //#ifndef TOSCT
 3971.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3971.4                         //#endif
 3971.5                         //      ADDS    p, p, #4
 3971.6                                 ENDM
 3972    00000004 801C                  ADDS    t, t, #2
 3973                                   TPUSH
 3973                                   PUSHt   // push t to p, pre decrement p
 3973.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3973.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3973.3                         //      STR     t, [p]
 3973.4                                 ENDM
 3973                                   NEXT
 3973.1                         // ARMv7-M Thumb = .+5
 3973.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3973.3                         // ARMv6-M Thumb = .+4
 3973.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3973                                   NEXT1
 3973.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3973.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3973.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3973.4                         // ARMv6-M Thumb = .+4
 3973.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3973.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3973.7                                 ENDM
 3973.8                                 ENDM
 3973.9                                 ENDM
 3974                           
 3975                           
 3976                           //      4+ FOURP:       ( n -- n+4 )
 3977                           
 3978                            SECTION .text : CONST (2)
 3979                           FOURP_NFA:
 3980    00000000 82                    DC8     0x82
 3981    00000001 34                    DC8     '4'
 3982    00000002 AB                    DC8     '+'+0x80
 3983    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3984    00000004 ........              DC32    TWOP_NFA
 3985                           FOURP:
 3986    00000008 ........              DC32    .+5
 3987                            SECTION .text : CODE (2)
 3988                                   POP2t
 3988.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3988.2                         //#ifndef TOSCT
 3988.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3988.4                         //#endif
 3988.5                         //      ADDS    p, p, #4
 3988.6                                 ENDM
 3989    00000004 001D                  ADDS    t, t, #4
 3990                                   TPUSH
 3990                                   PUSHt   // push t to p, pre decrement p
 3990.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3990.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3990.3                         //      STR     t, [p]
 3990.4                                 ENDM
 3990                                   NEXT
 3990.1                         // ARMv7-M Thumb = .+5
 3990.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3990.3                         // ARMv6-M Thumb = .+4
 3990.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3990                                   NEXT1
 3990.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3990.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3990.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3990.4                         // ARMv6-M Thumb = .+4
 3990.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3990.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3990.7                                 ENDM
 3990.8                                 ENDM
 3990.9                                 ENDM
 3991                           
 3992                           
 3993                           //      4- FOURM:       ( n -- n-4 )
 3994                           
 3995                            SECTION .text : CONST (2)
 3996                           FOURM_NFA:
 3997    00000000 82                    DC8     0x82
 3998    00000001 34                    DC8     '4'
 3999    00000002 AD                    DC8     '-'+0x80
 4000    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4001    00000004 ........              DC32    FOURP_NFA
 4002                           FOURM:
 4003    00000008 ........              DC32    .+5
 4004                            SECTION .text : CODE (2)
 4005                                   POP2t
 4005.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4005.2                         //#ifndef TOSCT
 4005.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4005.4                         //#endif
 4005.5                         //      ADDS    p, p, #4
 4005.6                                 ENDM
 4006    00000004 001F                  SUBS    t, t, #4
 4007                                   TPUSH
 4007                                   PUSHt   // push t to p, pre decrement p
 4007.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4007.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4007.3                         //      STR     t, [p]
 4007.4                                 ENDM
 4007                                   NEXT
 4007.1                         // ARMv7-M Thumb = .+5
 4007.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4007.3                         // ARMv6-M Thumb = .+4
 4007.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4007                                   NEXT1
 4007.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4007.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4007.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4007.4                         // ARMv6-M Thumb = .+4
 4007.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4007.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4007.7                                 ENDM
 4007.8                                 ENDM
 4007.9                                 ENDM
 4008                           
 4009                           
 4010                           //      0 ZERO: ( -- 0 )
 4011                           
 4012                            SECTION .text : CONST (2)
 4013                           ZERO_NFA:
 4014    00000000 81                    DC8     0x81
 4015    00000001 B0                    DC8     '0'+0x80
 4016    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 4017    00000004 ........              DC32    FOURM_NFA
 4018                           ZERO:
 4019    00000008 ........00000         DC32    DOCON, 0
                  000          
 4020                           
 4021                           
 4022                           //      1 ONE: ( -- 1 )
 4023                           
 4024                            SECTION .text : CONST (2)
 4025                           ONE_NFA:
 4026    00000000 81                    DC8     0x81
 4027    00000001 B1                    DC8     '1'+0x80
 4028    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 4029    00000004 ........              DC32    ZERO_NFA
 4030                           ONE:
 4031    00000008 ........01000         DC32    DOCON, 1
                  000          
 4032                           
 4033                           
 4034                           //      2 TWO: ( -- 2 )
 4035                           
 4036                            SECTION .text : CONST (2)
 4037                           TWO_NFA:
 4038    00000000 81                    DC8     0x81
 4039    00000001 B2                    DC8     '2'+0x80
 4040    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 4041    00000004 ........              DC32    ONE_NFA
 4042                           TWO:
 4043    00000008 ........02000         DC32    DOCON, 2
                  000          
 4044                           
 4045                           
 4046                           //      3 THREE: ( -- 3 )
 4047                           
 4048                            SECTION .text : CONST (2)
 4049                           THREE_NFA:
 4050    00000000 81                    DC8     0x81
 4051    00000001 B3                    DC8     '3'+0x80
 4052    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 4053    00000004 ........              DC32    TWO_NFA
 4054                           THREE:
 4055    00000008 ........03000         DC32    DOCON, 3
                  000          
 4056                           
 4057                           
 4058                           //      4 FOUR: ( -- 4 )
 4059                           
 4060                            SECTION .text : CONST (2)
 4061                           FOUR_NFA:
 4062    00000000 81                    DC8     0x81
 4063    00000001 B4                    DC8     '4'+0x80
 4064    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 4065    00000004 ........              DC32    THREE_NFA
 4066                           FOUR:
 4067    00000008 ........04000         DC32    DOCON, 4
                  000          
 4068                           
 4069                           
 4070                           //=============================== WORDCAT ====================================//
 4071                           //NOEXEC HEADERFORWORDCATEGORIES
 4072                           //      WC_NUMBERS_NFA = NUMBERS CATEGORY
 4073                           
 4074                            SECTION .text : CONST (2)
 4075                           WC_NUMBERS_NFA:
 4076    00000000 91                    DC8     0x80+4+13
 4077    00000001 0D0A                  DC8     0x0D, 0x0A
 4078    00000003 4E554D4245522         DC8     'NUMBER Stuff:'
                  053747566663A
 4079    00000010 0D8A                  DC8     0x0D, 0x0A+0x80
 4080    00000012 FFFF           ALIGNROM 2,0xFFFFFFFF
 4081    00000014 ........              DC32    FOUR_NFA
 4082                           
 4083                           
 4084                           //=============================== UART0_INIT =================================//
 4085                           
 4086                           // LFA ABOVE NEEDS TO BE WC_NUMBERS_NFA
 4087                           $FISH_STM32F4_UART3_INIT.s
 4088                           // LFA BELOW NEEDS TO BE UART3_INIT_NFA
 4089                           
 4090                           //=============================== UART0_INIT =================================//
 4091                           
 4092                           //      MYBAUD MYBAUD: ( n -- ) BAUD MUST BE IN DECIMAL or EQUIVALENT!!!
 4093                           //      MUST BE USED BEFORE USING UART0_INIT!!!
 4094                           //      Because FISH does a reset if you invoke a HARD FAULT RESET
 4095                           //      THIS MECHANISM IS ESSENTIAL TO STAYING AT USER SET BAUDRATE THRU A RESET!
 4096                           //      SET NON-INIT RAM VARIABLES DBAUD TO ZERO AND UBAUD n.
 4097                           //      See UART0_INIT
 4098                           
 4099                            SECTION .text : CONST (2)
 4100                           MYBAUD_NFA:
 4101    00000000 86                    DC8     0x86
 4102    00000001 4D59424155            DC8     'MYBAU'
 4103    00000006 C4                    DC8     'D'+0x80
 4104    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 4105    00000008 ........              DC32    UART3_INIT_NFA
 4106                           MYBAUD:
 4107    0000000C ........              DC32    DOCOL
 4108    00000010 ........00000         DC32    strva, 0, DBAUD
                  000........  
 4109    0000001C .............         DC32    LIT, UBAUD, STORE       // SET UBAUD TO NEW BAUD FOR UART0_INIT
                  ...........  
 4110    00000028 ........              DC32    SEMIS
 4111                           
 4112                           
 4113                           //      STM32F4 UART3_LSR UART3_LSR: ( -- value )
 4114                           
 4115                            SECTION .text : CONST (2)
 4116                           UART3_LSR_NFA:
 4117    00000000 89                    DC8     0x89
 4118    00000001 55415254335F4         DC8     'UART3_LS'
                  C53          
 4119    00000009 D2                    DC8     'R'+0x80
 4120    0000000A FFFF           ALIGNROM 2,0xFFFFFFFF
 4121    0000000C ........              DC32    MYBAUD_NFA
 4122                           UART3_LSR:
 4123    00000010 ........              DC32    .+5
 4124                            SECTION .text : CODE (2)
 4125    00000000 0549                  LDR     n, = USART3_SR
 4126    00000002 0878                  LDRB    t, [n]
 4127                                   TPUSH
 4127                                   PUSHt   // push t to p, pre decrement p
 4127.1  00000004 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4127.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4127.3                         //      STR     t, [p]
 4127.4                                 ENDM
 4127                                   NEXT
 4127.1                         // ARMv7-M Thumb = .+5
 4127.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4127.3                         // ARMv6-M Thumb = .+4
 4127.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4127                                   NEXT1
 4127.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4127.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4127.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4127.4                         // ARMv6-M Thumb = .+4
 4127.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4127.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4127.7                                 ENDM
 4127.8                                 ENDM
 4127.9                                 ENDM
 4128    00000016 0000           LTORG
 4128.1                                  TABLE
 4128.2  00000018 00480040              Reference on line 4125
 4129                           
 4130                           
 4131                           //      STM32F4 UART3_RX UART3_RX: ( -- addr )
 4132                           //      This is the serial terminal.
 4133                           
 4134                            SECTION .text : CONST (2)
 4135                           UART3_RX_NFA:
 4136    00000000 88                    DC8     0x88
 4137    00000001 55415254335F5         DC8     'UART3_R'
                  2            
 4138    00000008 D8                    DC8     'X'+0x80
 4139    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4140    0000000C ........              DC32    UART3_LSR_NFA
 4141                           UART0_RX:
 4142    00000010 ........04480         DC32    DOCON, USART3_DR
                  040          
 4143                           
 4144                           //      STM32F4 UART3_TX UART3_TX: ( -- addr )
 4145                           //      This is the serial terminal.
 4146                           
 4147                            SECTION .text : CONST (2)
 4148                           UART3_TX_NFA:
 4149    00000000 88                    DC8     0x88
 4150    00000001 55415254335F5         DC8     'UART3_T'
                  4            
 4151    00000008 D8                    DC8     'X'+0x80
 4152    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4153    0000000C ........              DC32    UART3_RX_NFA
 4154                           UART3_TX:
 4155    00000010 ........04480         DC32    DOCON, USART3_DR
                  040          
 4156                           
 4157                           
 4158                           #ifdef XON_XOFF
 4159                           //      XOFF XOFF: ( -- ) Send XOFF
 4160                           
 4161                            SECTION .text : CONST (2)
 4162                           XOFF_NFA:
 4163    00000000 84                    DC8     0x84
 4164    00000001 584F46                DC8     'XOF'
 4165    00000004 C6                    DC8     'F'+0x80
 4166    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4167    00000008 ........              DC32    UART3_TX_NFA
 4168                           XOFF:
 4169    0000000C ........              DC32    .+5
 4170                            SECTION .text : CODE (2)       // Does not incr OUT and wait for line status
 4171                           #ifdef IO2TP
 4173                           #else
 4174    00000000 ........              BL      TXRDY_SUBR
 4175    00000004 ........              BL      XOFF_SUBR
 4176                                   NEXT
 4176.1                         // ARMv7-M Thumb = .+5
 4176.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4176.3                         // ARMv6-M Thumb = .+4
 4176.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4176                                   NEXT1
 4176.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4176.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4176.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4176.4                         // ARMv6-M Thumb = .+4
 4176.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4176.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4176.7                                 ENDM
 4176.8                                 ENDM
 4177                           #endif // #else IO2TP
 4178                           //#endif // XON_XOFF after XON:
 4179                           
 4180                           
 4181                           //      XON XON: ( -- ) Send XON
 4182                           
 4183                            SECTION .text : CONST (2)
 4184                           XON_NFA:
 4185    00000000 83                    DC8     0x83
 4186    00000001 584F                  DC8     'XO'
 4187    00000003 CE                    DC8     'N'+0x80
 4188                            ALIGNROM 2,0xFFFFFFFF
 4189    00000004 ........              DC32    XOFF_NFA
 4190                           XON:
 4191    00000008 ........              DC32    .+5
 4192                            SECTION .text : CODE (2)       // Does not incr OUT or wait for line status.
 4193                           #ifdef IO2TP
 4195                           #else
 4196                           // Required, no 'quick send'
 4197    00000000 ........              BL      TXRDY_SUBR
 4198    00000004 ........              BL      XON_SUBR
 4199                                   NEXT
 4199.1                         // ARMv7-M Thumb = .+5
 4199.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4199.3                         // ARMv6-M Thumb = .+4
 4199.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4199                                   NEXT1
 4199.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4199.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4199.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4199.4                         // ARMv6-M Thumb = .+4
 4199.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4199.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4199.7                                 ENDM
 4199.8                                 ENDM
 4200                           #endif // #else IO2TP
 4201                           #endif // XON_XOFF
 4202                           
 4203                           //---------------- EMIT KEY ?KEY CR SECTION ------------------------------
 4204                           
 4205                           //      SPACES SPACES:  ( n -- )
 4206                           //      Transmit n ascii blanks (0x20) to the output device.
 4207                           
 4208                            SECTION .text : CONST (2)
 4209                           SPACES_NFA:
 4210    00000000 86                    DC8     0x86
 4211    00000001 5350414345            DC8     'SPACE'
 4212    00000006 D3                    DC8     'S'+0x80
 4213    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 4214                           #ifdef XON_XOFF
 4215    00000008 ........              DC32    XON_NFA
 4216                           #else
 4218                           #endif
 4219                           SPACES:
 4220    0000000C ........              DC32    DOCOL
 4221    00000010 ........              DC32    ZERO
 4222    00000014 ........              DC32    MAX
 4223    00000018 ........              DC32    ZNDUP
 4224    0000001C ........              DC32    ZBRAN
 4225    00000020 18000000              DC32     SPACES_DONE-.
 4226                           
 4227    00000024 ........              DC32    ZERO
 4228    00000028 ........              DC32    XDO     //DO
 4229                           
 4230                           SPACES_DO:
 4231    0000002C ........              DC32    SPACE
 4232    00000030 ........              DC32    XLOOP   //LOOP
 4233    00000034 F8FFFFFF              DC32     SPACES_DO-.
 4234                           
 4235                           SPACES_DONE:
 4236    00000038 ........              DC32    SEMIS
 4237                           
 4238                           
 4239                           //      SPACE SPACE: ( -- )
 4240                           //      Emit a space character, 0x20.
 4241                           
 4242                            SECTION .text : CONST (2)
 4243                           SPACE_NFA:
 4244    00000000 85                    DC8     0x85
 4245    00000001 53504143              DC8     'SPAC'
 4246    00000005 C5                    DC8     'E'+0x80
 4247    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 4248    00000008 ........              DC32    SPACES_NFA
 4249                           SPACE:
 4250    0000000C ........              DC32    DOCOL
 4251    00000010 ........              DC32    BLANK
 4252    00000014 ........              DC32    EMIT
 4253    00000018 ........              DC32    SEMIS
 4254                           
 4255                           
 4256                           //      ID. IDDOT:      ( NFA-addr -- ) ?RENAME .NFA
 4257                           //      Print a definition's name from its name field address.
 4258                           
 4259                            SECTION .text : CONST (2)
 4260                           IDDOT_NFA:
 4261    00000000 83                    DC8     0x83
 4262    00000001 4944                  DC8     'ID'
 4263    00000003 AE                    DC8     '.'+0x80
 4264                            ALIGNROM 2,0xFFFFFFFF
 4265    00000004 ........              DC32    SPACE_NFA
 4266                           IDDOT:
 4267    00000008 ........              DC32    DOCOL
 4268                           //      NOW COUNT is on NFA, fig code copied it out to pad
 4269    0000000C ........              DC32    COUNT   // Count could be SMUDGE'd.
 4270    00000010 ........1F000         DC32    LIT, MAXWORDLEN // Strip SMUDGEing from count
                  000          
 4271    00000018 ........              DC32    ANDD            // only time 
 4272    0000001C ........              DC32    TYPE    // TYPE needs actual count un SMUDGE'd
 4273    00000020 ........              DC32    SPACE
 4274    00000024 ........              DC32    SEMIS
 4275                           
 4276                           
 4277                           //      ." DOTQ:        ( -- ) IMMEDIATE
 4278                           //      Type quoted string out or compile inline string to be typed at runtime
 4279                           //      CHANGED COMPILE TIME ACTION TO WORK WITH 4 byte alighment REQUIREMENT.
 4280                           //      Used in the form:
 4281                           //              .' CCcc"
 4282                           //      Compiles an in-line string CCcc (delimited by the trailing ") with
 4283                           //      an execution proceedure to transmit the text to the output device.
 4284                           //      If executed outside a definition, ." will immediately print the text
 4285                           //      until the final ',. The maximum number of characters may be an
 4286                           //      installation dependent value. See (.").
 4287                           
 4288                            SECTION .text : CONST (2)
 4289                           DOTQ_NFA:
 4290    00000000 C2                    DC8     0x0C2
 4291    00000001 2E                    DC8     '.'
 4292    00000002 A2                    DC8     '"'+0x80
 4293    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4294    00000004 ........              DC32    IDDOT_NFA
 4295                           DOTQ:
 4296    00000008 ........              DC32    DOCOL
 4297    0000000C ........22000         DC32    LIT, '"'        // 0x22 ending qoute delimiter for WORD
                  000          
 4298    00000014 ........              DC32    STATE_SV
 4299    00000018 ........              DC32    AT
 4300    0000001C ........              DC32    ZBRAN   // IF Not COMPILING
 4301    00000020 2C000000              DC32     DOTQ1-.
 4302                           
 4303    00000024 ........              DC32    COMP    // COMPILING
 4304    00000028 ........              DC32    PDOTQ   // compile LIT, cnt-str-addr, count, type
 4305    0000002C ........              DC32    WORD   // \ cH-DELIM  --  CHCNT-STR OF TOKEN TO HERE
 4306    00000030 ........              DC32    HERE
 4307    00000034 ........              DC32    CAT
 4308    00000038 ........              DC32    ONEP
 4309    0000003C ........              DC32    ALIGNED
 4310    00000040 ........              DC32    ALLOT_PRIM
 4311    00000044 ........              DC32    BRAN    // ELSE
 4312    00000048 14000000              DC32     DOTQ2-.
 4313                           DOTQ1:
 4314    0000004C ........              DC32    WORD   // \ cH-DELIM  --  CHCNT-STR OF TOKEN TO HERE
 4315    00000050 ........              DC32    HERE
 4316    00000054 ........              DC32    COUNT
 4317    00000058 ........              DC32    TYPE    // TYPE needs actual count un SMUDGE'd
 4318                                                   // endif
 4319                           #ifdef IO2TP
 4323                           #endif
 4324                           DOTQ2:
 4325    0000005C ........              DC32    SEMIS
 4326                           
 4327                           
 4328                           //      TYPE TYPE:      ( addr count -- )
 4329                           //      ADDR must be ALIGNED!
 4330                           //      OUT MUST BE INITIALIZED!!
 4331                           //      EMIT COUNT OF 8-bits in a string, preferably ascii characters,
 4332                           //      (last nfa char (+80h)ok!) from addr thru count,
 4333                           
 4334                            SECTION .text : CONST (2)
 4335                           TYPE_NFA:
 4336    00000000 84                    DC8     0x84
 4337    00000001 545950                DC8     'TYP'
 4338    00000004 C5                    DC8     'E'+0x80
 4339    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4340    00000008 ........              DC32    DOTQ_NFA
 4341                           TYPE:
 4342    0000000C ........              DC32    DOCOL
 4343    00000010 ........              DC32    ZNDUP
 4344    00000014 ........              DC32    ZBRAN   // IF NOTHING TO TYPE
 4345    00000018 34000000              DC32     TYPE1-.
 4346                           
 4347                           #ifdef XON_XOFF
 4348    0000001C ........              DC32    XOFF    // TEMP TEST THRE
 4349                           #endif
 4350    00000020 ........              DC32    OVER
 4351    00000024 ........              DC32    PLUS
 4352    00000028 ........              DC32    SWAP
 4353    0000002C ........              DC32    XDO     // DO
 4354                           TYPE2:
 4355    00000030 ........              DC32    I
 4356    00000034 ........              DC32    CATLT7F // Limit output to ASCII characters under 80h
 4357    00000038 ........              DC32    EMIT
 4358                           tt1:
 4359    0000003C ........              DC32    XLOOP   // LOOP
 4360                           tt2:
 4361    00000040 F0FFFFFF              DC32     TYPE2-.
 4362                           
 4363    00000044 ........              DC32    BRAN    // ELSE
 4364    00000048 08000000              DC32     TYPE3-.
 4365                           TYPE1:
 4366    0000004C ........              DC32    DROP    // endif
 4367                           TYPE3:
 4368    00000050 ........              DC32    SEMIS
 4369                           
 4370                           
 4371                           //      EMIT EMIT:      ( c -- )
 4372                           //      Transmit ascii character c to the selected output device. OUT is
 4373                           //      incremented for each character output.
 4374                           
 4375                            SECTION .text : CONST (2)
 4376                           EMIT_NFA:
 4377    00000000 84                    DC8     0x84
 4378    00000001 454D49                DC8     'EMI'
 4379    00000004 D4                    DC8     'T'+0x80
 4380    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4381    00000008 ........              DC32    TYPE_NFA
 4382                           EMIT:
 4383                           #ifndef IO2TP
 4384                           // NOT IO2TP SECTION:
 4385    0000000C ........              DC32    .+5
 4386                            SECTION .text : CODE (2)
 4387                                   POP2t                   // GET CHAR
 4387.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4387.2                         //#ifndef TOSCT
 4387.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4387.4                         //#endif
 4387.5                         //      ADDS    p, p, #4
 4387.6                                 ENDM
 4388    00000004 ........              BL      TXRDY_SUBR
 4389    00000008 0649                  LDR     n, = USART3_DR // 
 4390                           // BSOUT handles negative out issue
 4391    0000000A 0870                  STRB    t, [n]          // EMIT (Send) Char
 4392    0000000C 0649                  LDR     n, = OUT        // Increment Out
 4393    0000000E 0868                  LDR     t, [n]
 4394    00000010 401C                  ADDS    t, t, #1
 4395    00000012 0860                  STR     t, [n]
 4396                                   NEXT
 4396.1                         // ARMv7-M Thumb = .+5
 4396.2  00000014 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4396.3                         // ARMv6-M Thumb = .+4
 4396.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4396                                   NEXT1
 4396.1  00000018 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4396.2  0000001C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4396.3  00000020 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4396.4                         // ARMv6-M Thumb = .+4
 4396.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4396.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4396.7                                 ENDM
 4396.8                                 ENDM
 4397                           #else // if IO2TP Transmit char to PAD, increment OUT
 4412                           #endif  // IO2TP
 4413    00000022 0000           LTORG
 4413.1                                  TABLE
 4413.2  00000024 04480040              Reference on line 4389
 4413.3  00000028 ........              Reference on line 4392
 4414                           
 4415                           
 4416                           //      KEY KEY:        (  -- ch )
 4417                           
 4418                            SECTION .text : CONST (2)
 4419                           KEY_NFA:
 4420    00000000 83                    DC8     0x83
 4421    00000001 4B45                  DC8     'KE'
 4422    00000003 D9                    DC8     'Y'+0x80
 4423                            ALIGNROM 2,0xFFFFFFFF
 4424    00000004 ........              DC32    EMIT_NFA
 4425                           KEY_INTERPRETED_ENTRY:
 4426                           #ifndef IO2TP
 4427    00000008 ........              DC32    DOCOL
 4428    0000000C ........              DC32    XON     // EXEC SETS XOFF SO UNDO IT
 4429    00000010 ........              DC32    KEY     // TE GET KEY!
 4430    00000014 ........              DC32    SEMIS
 4431                           
 4432                           
 4433                           //:NONAME KEY KEY:      ( -- CH ) 0-7Fh
 4434                           KEY:
 4435    00000018 ........              DC32    .+5
 4436                            SECTION .text : CODE (2)
 4437    00000000 074A                  LDR     w, = USART3_DR // 
 4438    00000002 084B                  LDR     x, = USART3_SR // 
 4439                           rxRDY?:
 4440    00000004 1968                  LDR     n, [x]          // Get Line Status
 4441                           //      LSRS    n, n, #5        // Bit 5 RXNE: Read data register not empty
 4442                           // THIS IS ___ AND FAILS TEXT DOWNLOAD
 4443    00000006 8909                  LSRS    n, n, #6        // Bit 6 ORIG - REQ'D FOR TEXT FILE DOWNLOAD
 4444    00000008 FCD3                  BCC     rxRDY?          // sets carry flag
 4445                           
 4446    0000000A 1068                  LDR     t, [w]
 4447                                   TPUSH
 4447                                   PUSHt   // push t to p, pre decrement p
 4447.1  0000000C 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4447.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4447.3                         //      STR     t, [p]
 4447.4                                 ENDM
 4447                                   NEXT
 4447.1                         // ARMv7-M Thumb = .+5
 4447.2  00000010 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4447.3                         // ARMv6-M Thumb = .+4
 4447.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4447                                   NEXT1
 4447.1  00000014 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4447.2  00000018 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4447.3  0000001C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4447.4                         // ARMv6-M Thumb = .+4
 4447.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4447.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4447.7                                 ENDM
 4447.8                                 ENDM
 4447.9                                 ENDM
 4448                           #else
 4450                           #endif  // IO2TP
 4451    0000001E 0000           LTORG
 4451.1                                  TABLE
 4451.2  00000020 04480040              Reference on line 4437
 4451.3  00000024 00480040              Reference on line 4438
 4452                           
 4453                           
 4454                           //      ?KEY QKEY: ( -- f )
 4455                           //      Return zero unless key in fifo - key is not consumed.
 4456                           //      : TB BEGIN ?KEY UNTIL ; Will execute until any key is entered.
 4457                           
 4458                            SECTION .text : CONST (2)
 4459                           QKEY_NFA:
 4460    00000000 84                    DC8     0x84
 4461    00000001 3F4B45                DC8     '?KE'
 4462    00000004 D9                    DC8     'Y'+0x80
 4463    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4464    00000008 ........              DC32    KEY_NFA // -1
 4465                           QKEY:
 4466    0000000C ........              DC32    .+5
 4467                            SECTION .text : CODE (2)
 4468                           #ifndef IO2TP
 4469                           #ifdef XON_XOFF // XON IN QKEY
 4470    00000000 ........              BL      TXRDY_SUBR
 4471    00000004 ........              BL      XON_SUBR
 4472                           #endif
 4473    00000008 0B4B                  LDR     x, = USART3_SR
 4474    0000000A 1968                  LDR     n, [x]          // Get Line Status
 4475    0000000C 4909                  LSRS    n, n, #5        // Char available
 4476    0000000E 09D3                  BCC     NO_KEY          // No char, not Ready
 4477                           
 4478                           // HAVE A KEY - DON'T CONSUME IT
 4479    00000010 0120                  MOVS     t, #1
 4480                                   TPUSH
 4480                                   PUSHt   // push t to p, pre decrement p
 4480.1  00000012 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4480.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4480.3                         //      STR     t, [p]
 4480.4                                 ENDM
 4480                                   NEXT
 4480.1                         // ARMv7-M Thumb = .+5
 4480.2  00000016 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4480.3                         // ARMv6-M Thumb = .+4
 4480.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4480                                   NEXT1
 4480.1  0000001A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4480.2  0000001E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4480.3  00000022 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4480.4                         // ARMv6-M Thumb = .+4
 4480.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4480.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4480.7                                 ENDM
 4480.8                                 ENDM
 4480.9                                 ENDM
 4481                           #endif  // DEFAULT TO NO KEY IF IO2TP
 4482                           NO_KEY:
 4483    00000024 4040                  EORS    t, t, t  // zero t
 4484                                   TPUSH
 4484                                   PUSHt   // push t to p, pre decrement p
 4484.1  00000026 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4484.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4484.3                         //      STR     t, [p]
 4484.4                                 ENDM
 4484                                   NEXT
 4484.1                         // ARMv7-M Thumb = .+5
 4484.2  0000002A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4484.3                         // ARMv6-M Thumb = .+4
 4484.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4484                                   NEXT1
 4484.1  0000002E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4484.2  00000032 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4484.3  00000036 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4484.4                         // ARMv6-M Thumb = .+4
 4484.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4484.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4484.7                                 ENDM
 4484.8                                 ENDM
 4484.9                                 ENDM
 4485                            LTORG
 4485.1                                  TABLE
 4485.2  00000038 00480040              Reference on line 4473
 4486                           
 4487                           
 4488                           //      CRS CRS:        ( n -- )
 4489                           //      Emit n cr'S (0x0d) and lf (0x0A)
 4490                           
 4491                            SECTION .text : CONST (2)
 4492                           CRS_NFA:
 4493    00000000 83                    DC8     0x83
 4494    00000001 4352                  DC8     'CR'
 4495    00000003 D3                    DC8     'S'+0x80
 4496                            ALIGNROM 2,0xFFFFFFFF
 4497    00000004 ........              DC32    QKEY_NFA
 4498                           CRS:
 4499    00000008 ........              DC32    DOCOL
 4500    0000000C ........              DC32    ZERO
 4501    00000010 ........              DC32    XDO
 4502                           CRS_BEGIN:
 4503    00000014 ........              DC32    CR
 4504    00000018 ........              DC32    XLOOP
 4505    0000001C F8FFFFFF              DC32     CRS_BEGIN-.
 4506    00000020 ........              DC32    SEMIS
 4507                           
 4508                           
 4509                           //      CR CR:  ( -- )
 4510                           //      Emit cr (0x0d) and lf (0x0A)
 4511                           
 4512                            SECTION .text : CONST (2)
 4513                           CR_NFA:
 4514    00000000 82                    DC8     0x82
 4515    00000001 43                    DC8     'C'
 4516    00000002 D2                    DC8     'R'+0x80
 4517    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4518    00000004 ........              DC32    CRS_NFA
 4519                           CR:
 4520                           #ifdef IO2TP
 4523                           #else
 4524    00000008 ........              DC32    DOCOL
 4525    0000000C ........              DC32    zero_OUT
 4526    00000010 ........              DC32    PDOTQ
 4527    00000014 02                    DC8     2
 4528    00000015 0D0A                  DC8     0x0D, 0x0A
 4529    00000017 FF             ALIGNROM 2,0xFFFFFFFF
 4530    00000018 ........              DC32    SEMIS
 4531                           #endif
 4532                           
 4533                           
 4534                           //=============================== WORDCAT ====================================//
 4535                           //NOEXEC HEADERFORWORDCATEGORIES
 4536                           //      WC_UART0_NFA = NUMBERS CATEGORY
 4537                           
 4538                            SECTION .text : CONST (2)
 4539                           WC_UARTx_NFA:
 4540    00000000 8C                    DC8     0x80+4+8
 4541    00000001 0D0A                  DC8     0x0D, 0x0A
 4542    00000003 4649534820494         DC8     'FISH IO:'
                  F3A          
 4543    0000000B 0D8A                  DC8     0x0D, 0x0A+0x80
 4544    0000000D FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4545    00000010 ........              DC32    CR_NFA
 4546                           
 4547                           //      CMSIS_ENABLE_IRQS IRQS_RESUME:  ( -- )
 4548                            SECTION .text : CONST (2)
 4549                           IRQS_RESUME_NFA:
 4550    00000000 8B                    DC8     0x8B
 4551    00000001 495251535F524         DC8     'IRQS_RESUM'
                  553554D      
 4552    0000000B C5                    DC8     'E'+0x80
 4553                            ALIGNROM 2,0xFFFFFFFF
 4554    0000000C ........              DC32    WC_UARTx_NFA
 4555                           CMSIS_ENABLE_IRQS:
 4556    00000010 ........              DC32 .+5
 4557                            SECTION .text : CODE (2)
 4558                            ALIGNROM 2,0xFFFFFFFF
 4559                            IMPORT C_CMSIS_ENABLE_IRQS
 4560    00000000 ........              BL      C_CMSIS_ENABLE_IRQS
 4561                                   NEXT
 4561.1                         // ARMv7-M Thumb = .+5
 4561.2  00000004 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4561.3                         // ARMv6-M Thumb = .+4
 4561.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4561                                   NEXT1
 4561.1  00000008 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4561.2  0000000C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4561.3  00000010 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4561.4                         // ARMv6-M Thumb = .+4
 4561.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4561.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4561.7                                 ENDM
 4561.8                                 ENDM
 4562                           
 4563                           //      CMSIS_DISABLE_IRQS IRQS_SUSPEND:        ( -- )
 4564                            SECTION .text : CONST (2)
 4565                           IRQS_SUSPEND_NFA:
 4566    00000000 8C                    DC8     0x8C
 4567    00000001 495251535F535         DC8     'IRQS_SUSPEN'
                  55350454E    
 4568    0000000C C4                    DC8     'D'+0x80
 4569    0000000D FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4570    00000010 ........              DC32    IRQS_RESUME_NFA
 4571                           CMSIS_DISABLE_IRQS:
 4572    00000014 ........              DC32 .+5
 4573                            SECTION .text : CODE (2)
 4574                            ALIGNROM 2,0xFFFFFFFF
 4575                            IMPORT C_CMSIS_DISABLE_IRQS
 4576    00000000 ........              BL      C_CMSIS_DISABLE_IRQS
 4577                                   NEXT
 4577.1                         // ARMv7-M Thumb = .+5
 4577.2  00000004 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4577.3                         // ARMv6-M Thumb = .+4
 4577.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4577                                   NEXT1
 4577.1  00000008 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4577.2  0000000C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4577.3  00000010 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4577.4                         // ARMv6-M Thumb = .+4
 4577.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4577.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4577.7                                 ENDM
 4577.8                                 ENDM
 4578                           
 4579                           
 4580                           //      SYSTICK_IRQ_OFF SYSTICK_IRQ_OFF:        ( -- )
 4581                           //      Turn SYSTICK interrupt off.
 4582                           //      STCTR only incremented when SYSTICK interrupt is on.
 4583                           //      STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! E000E010h @ .H
 4584                            SECTION .text : CONST (2)
 4585                           SYSTICK_IRQ_OFF_NFA:
 4586    00000000 8F                    DC8     0x8F
 4587    00000001 5359535449434         DC8     'SYSTICK_IRQ_OF'
                  B5F4952515F4F
                  46           
 4588    0000000F C6                    DC8     'F'+0x80
 4589                            ALIGNROM 2,0xFFFFFFFF
 4590    00000010 ........              DC32    IRQS_SUSPEND_NFA
 4591                           SYSTICK_IRQ_OFF:
 4592    00000014 ........              DC32    .+5
 4593                            SECTION .text : CODE (2)
 4594    00000000 0449                  LDR     n, = SYST_CSR   // SYSTICK Control and Status Register
 4595    00000002 0520                  MOVS    t, #5
 4596    00000004 0860                  STR     t, [n]
 4597                                   NEXT
 4597.1                         // ARMv7-M Thumb = .+5
 4597.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4597.3                         // ARMv6-M Thumb = .+4
 4597.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4597                                   NEXT1
 4597.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4597.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4597.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4597.4                         // ARMv6-M Thumb = .+4
 4597.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4597.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4597.7                                 ENDM
 4597.8                                 ENDM
 4598                           // LTORG         //Always outside of code, else data in words
 4599                           
 4600                           
 4601                           //      SYSTICK_IRQ_ON SYSTICK_IRQ_ON:  ( -- )
 4602                           //      Turn SYSTICK interrupt on.
 4603                           //      STCTR only incremented when SYSTICK interrupt is on.
 4604                           //      STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! E000E010h @ .H
 4604.1                                  TABLE
 4604.2  00000014 10E000E0              Reference on line 4594
 4605                            SECTION .text : CONST (2)
 4606                           SYSTICK_IRQ_ON_NFA:
 4607    00000000 8E                    DC8     0x8E
 4608    00000001 5359535449434         DC8     'SYSTICK_IRQ_O'
                  B5F4952515F4F
 4609    0000000E CE                    DC8     'N'+0x80
 4610    0000000F FF             ALIGNROM 2,0xFFFFFFFF
 4611    00000010 ........              DC32    SYSTICK_IRQ_OFF_NFA
 4612                           SYSTICK_IRQ_ON:
 4613    00000014 ........              DC32    .+5
 4614                            SECTION .text : CODE (2)
 4615    00000000 0449                  LDR     n, = SYST_CSR   // SYSTICK Control and Status Register
 4616    00000002 0720                  MOVS    t, #7
 4617    00000004 0860                  STR     t, [n]
 4618                                   NEXT
 4618.1                         // ARMv7-M Thumb = .+5
 4618.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4618.3                         // ARMv6-M Thumb = .+4
 4618.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4618                                   NEXT1
 4618.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4618.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4618.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4618.4                         // ARMv6-M Thumb = .+4
 4618.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4618.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4618.7                                 ENDM
 4618.8                                 ENDM
 4619                            LTORG   //Always outside of code, else data in words
 4619.1                                  TABLE
 4619.2  00000014 10E000E0              Reference on line 4615
 4620                           
 4621                           //=============================== WORDCAT ====================================//
 4622                           //NOEXEC HEADERFORWORDCATEGORIES
 4623                           //      WC_IRQ_NFA = NUMBERS CATEGORY
 4624                           
 4625                            SECTION .text : CONST (2)
 4626                           WC_IRQ_NFA:
 4627    00000000 8F                    DC8     0x80+4+11
 4628    00000001 0D0A                  DC8     0x0D, 0x0A
 4629    00000003 494E544552525         DC8     'INTERRUPTS:'
                  55054533A    
 4630    0000000E 0D8A                  DC8     0x0D, 0x0A+0x80
 4631                            ALIGNROM 2,0xFFFFFFFF
 4632    00000010 ........              DC32    SYSTICK_IRQ_ON_NFA
 4633                           
 4634                           
 4635                           //------------------------------------------------------------------------------
 4636                           $FISH_STM32F4_FLASH.s       // FLASH_SAVE and FLASH_FORGET Words
 4637                           // LFA BELOW NEEDS TO BE FLASH_FORGET_NFA
 4638                           //------------------------------------------------------------------------------
 4639                           
 4640                           //-------------------------- DOTDICTSPACE SECTION ------------------------------
 4641                           
 4642                           //      .DS DOTDICTSPACE:       ( n -- )
 4643                           //      Prints number of bytes availble in dictionary in DECIMAL using DOT,
 4644                           //      not affecting Base in the system
 4645                           
 4646                            SECTION .text : CONST (2)
 4647                           DOTDICTSPACE_NFA:
 4648    00000000 83                    DC8     0x83
 4649    00000001 2E44                  DC8     '.D'
 4650    00000003 D3                    DC8     'S'+0x80
 4651                            ALIGNROM 2,0xFFFFFFFF
 4652    00000004 ........              DC32    FLASH_FORGET_NFA
 4653                           DOTDICTSPACE:
 4654    00000008 ........              DC32    DOCOL
 4655    0000000C ........              DC32    DICTSPACE
 4656    00000010 ........              DC32    BASE_TO_R12     // Save current BASE
 4657    00000014 ........              DC32    DOTDEC
 4658    00000018 ........              DC32    BASE_FROM_R12   // Restore BASE
 4659    0000001C .............         DC32    LIT, msg_dictspace
                  ...          
 4660    00000024 .............         DC32    NULLSTRLEN, TYPE
                  ...          
 4661                           #ifdef IO2TP
 4665                           #endif
 4666    0000002C ........              DC32    SEMIS
 4667                           
 4668                           
 4669                           //-------------------------- DOTVARSPACE SECTION -------------------------------
 4670                           
 4671                           //      .VS DOTVARSPACE:        ( n -- )
 4672                           //      Prints number of bytes availble in RAM VAR SPACE in DECIMAL using DOT,
 4673                           //      not affecting Base in the system.
 4674                           
 4675                            SECTION .text : CONST (2)
 4676                           DOTVARSPACE_NFA:
 4677    00000000 83                    DC8     0x83
 4678    00000001 2E56                  DC8     '.V'
 4679    00000003 D3                    DC8     'S'+0x80
 4680                            ALIGNROM 2,0xFFFFFFFF
 4681    00000004 ........              DC32    DOTDICTSPACE_NFA
 4682                           DOTVARSPACE:
 4683    00000008 ........              DC32    DOCOL
 4684    0000000C ........              DC32    VARSPACE
 4685    00000010 ........              DC32    BASE_TO_R12     // Save current BASE
 4686    00000014 .............         DC32    FOUR, SLASH
                  ...          
 4687    0000001C ........              DC32    DOTDEC
 4688    00000020 ........              DC32    BASE_FROM_R12   // Restore BASE
 4689    00000024 .............         DC32    LIT, msg_uvspace
                  ...          
 4690    0000002C .............         DC32    NULLSTRLEN, TYPE
                  ...          
 4691                           #ifdef IO2TP
 4695                           #endif
 4696    00000034 ........              DC32    SEMIS
 4697                           
 4698                           
 4699                           //      DUMP DUMP:      ( addr n -- )
 4700                           //      Print adrr and n lines of 4 columns of memory values in hexadecimal.
 4701                           //      Address must be even and a multiple of 4 else error message issued.
 4702                           //      Any key presssed will stop DUMP.
 4703                           
 4704                            SECTION .text : CONST (2)
 4705                           DUMP_NFA:
 4706    00000000 84                    DC8     0x84
 4707    00000001 44554D                DC8     'DUM'
 4708    00000004 D0                    DC8     'P'+0x80
 4709    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4710    00000008 ........              DC32    DOTVARSPACE_NFA
 4711                           DUMP:
 4712    0000000C ........              DC32    DOCOL
 4713                           
 4714    00000010 .............         DC32    OVER, QALIGNED  // \ -- addr n
                  ...          
 4715                           // DON'T SAVE BASE UNTIL AFTER ALIGNED TEST
 4716    00000018 ........              DC32    BASE_TO_R12     // Save current BASE
 4717    0000001C ........              DC32    HEX
 4718    00000020 .............         DC32    ZERO, XDO
                  ...          
 4719                           DUMP_ADDR_LINE:
 4720    00000028 ........              DC32    CR
 4721    0000002C .............         DC32    DUP, LIT, 10, DOTRU     // Print addr in Field
                  ...0A000000..
                  ......       
 4722    0000003C .............         DC32    FOUR, ZERO, XDO         // Four colum loop
                  ...........  
 4723                           DUMP_EACH_LOC:
 4724    00000048 .............         DC32    DUP, AT
                  ...          
 4725                           // Little Endian means addresses will print correctly
 4726                           // but to see character strings REVW is needed
 4727                           // but the addresses are scrambled!
 4728                           //        DC32    REVW                    // Reverse bytes in word
 4729    00000050 ........0E000         DC32    LIT, 14, DOTRU          // Diplay in Field
                  000........  
 4730    0000005C ........              DC32    FOURP
 4731    00000060 ........              DC32    XLOOP
 4732    00000064 E4FFFFFF              DC32     DUMP_EACH_LOC-.
 4733                           
 4734                           #ifdef IO2TP
 4738                           #endif
 4739    00000068 ........              DC32    QKEY
 4740    0000006C ........              DC32    ZBRAN
 4741    00000070 08000000              DC32     DUMP_CONT-.
 4742    00000074 ........              DC32    LEAVE
 4743                           DUMP_CONT:
 4744    00000078 ........              DC32    XLOOP
 4745    0000007C ACFFFFFF              DC32    DUMP_ADDR_LINE-.
 4746                           
 4747    00000080 .............         DC32    DROP, CR
                  ...          
 4748    00000088 ........              DC32    BASE_FROM_R12   // Restore BASE
 4749    0000008C ........              DC32    SEMIS
 4750                           
 4751                           
 4752                           //      VBASE VBASE:    ( -- addr )
 4753                           //      Return base addr of VAR's .
 4754                           
 4755                            SECTION .text : CONST (2)
 4756                           VBASE_NFA:
 4757    00000000 85                    DC8     0x85
 4758    00000001 56424153              DC8     'VBAS'
 4759    00000005 C5                    DC8     'E'+0x80
 4760    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 4761    00000008 ........              DC32    DUMP_NFA
 4762                           VBASE:
 4763    0000000C .............         DC32    DOCON,  RAMVARSPACE_START
                  ...          
 4764                           
 4765                           
 4766                           //      DBASE DBASE:    ( -- addr )
 4767                           //      Return base addr of the dictionary.
 4768                           
 4769                            SECTION .text : CONST (2)
 4770                           DBASE_NFA:
 4771    00000000 85                    DC8     0x85
 4772    00000001 44424153              DC8     'DBAS'
 4773    00000005 C5                    DC8     'E'+0x80
 4774    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 4775    00000008 ........              DC32    VBASE_NFA
 4776                           DBASE:
 4777    0000000C .............         DC32    DOCON,  ORIG
                  ...          
 4778                           
 4779                           
 4780                           //      RBASE RBASE:    ( -- addr )
 4781                           //      Return base addr of RAM THE DICTIONARY IS IN!.
 4782                           
 4783                            SECTION .text : CONST (2)
 4784                           RBASE_NFA:
 4785    00000000 85                    DC8     0x85
 4786    00000001 52424153              DC8     'RBAS'
 4787    00000005 C5                    DC8     'E'+0x80
 4788    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 4789    00000008 ........              DC32    DBASE_NFA
 4790                           RBASE:
 4791    0000000C .............         DC32    DOCON,  RAM_START    // RAM WHERE DICT ALLOACTED IN MEMMAP
                  ...          
 4792                           
 4793                           
 4794                           //      CLS CLS:        ( -- )
 4795                           //      Clear serial terminal screen using a formfeed character
 4796                           
 4797                            SECTION .text : CONST (2)
 4798                           CLS_NFA:
 4799    00000000 83                    DC8     0x83
 4800    00000001 434C                  DC8     'CL'
 4801    00000003 D3                    DC8     'S'+0x80
 4802                            ALIGNROM 2,0xFFFFFFFF
 4803    00000004 ........              DC32    RBASE_NFA
 4804                           CLS:
 4805    00000008 ........              DC32    DOCOL
 4806    0000000C ........              DC32    PDOTQ
 4807    00000010 04                    DC8     4
 4808    00000011 1B5B                  DC8     0x1B, '['       // ESC[ = ANSI VT100 ESC SETUP
 4809    00000013 324A                  DC8     '2J'            // Clearscreen
 4810    00000015 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4811    00000018 ........              DC32    PDOTQ
 4812    0000001C 04                    DC8     4
 4813    0000001D 1B5B                  DC8     0x1B, '['       // ESC[ = ANSI VT00 ESC SETUP
 4814    0000001F 3B48                  DC8     ';H'            // CURSORHOME \ upper left corner
 4815    00000021 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4816    00000024 ........              DC32    CR              // Reset OUT
 4817    00000028 ........              DC32    SEMIS
 4818                           
 4819                           
 4820                           //      ( PAREN:        ( -- ) IMMEDIATE
 4821                           //      Used in the form:
 4822                           //              ( CCcc )
 4823                           //      Ignore comments within parenthesis. A right parenthesis ends comment.
 4824                           //      The comments may be multi-line but a space or tab is required
 4825                           //      for any line that is otherwise empty for formatting purposes,
 4826                           //      else a comment error will be printed. May occur during execution or in a
 4827                           //      colon-definition. A blank after the leading parenthesis is required.
 4828                           
 4829                            SECTION .text : CONST (2)
 4830                           PAREN_NFA:
 4831    00000000 C1                    DC8     0x0C1
 4832    00000001 A8                    DC8     '('+0x80
 4833    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 4834    00000004 ........              DC32    CLS_NFA
 4835                           PAREN:
 4836                           // Slow Single line comment
 4837                           //      DC32    DOCOL, LIT, ')', WORD, SEMIS
 4838    00000008 ........              DC32    DOCOL
 4839                           PML_LOOP:
 4840    0000000C ........29000         DC32    LIT, ')'
                  000          
 4841    00000014 ........              DC32    TIB_CHAR_SCAN   // \ c -- f
 4842                           //
 4843    00000018 ........              DC32    ZEQU            // If null
 4844    0000001C ........              DC32    ZBRAN           // found fall thru
 4845    00000020 24000000              DC32      PE_DONE-.     // else were done
 4846                           
 4847                           // GET ANOTHER LINE
 4848    00000024 ........              DC32    CR
 4849    00000028 ........              DC32    QUERY
 4850                           //  AND IF ONLY CR (null) ERR
 4851    0000002C .............         DC32    TIB_SV, CAT
                  ...          
 4852    00000034 ........              DC32    ZBRAN
 4853    00000038 10000000              DC32      PAREN_ERR-.
 4854                           
 4855                           //  If closing paren not in this line LOOP
 4856    0000003C ........              DC32    BRAN
 4857    00000040 CCFFFFFF              DC32      PML_LOOP-.
 4858                           
 4859                           PE_DONE:
 4860    00000044 ........              DC32    SEMIS
 4861                           
 4862                           PAREN_ERR:
 4863    00000048 .............         DC32    LIT, msg_paren_err
                  ...          
 4864    00000050 .............         DC32    NULLSTRLEN, TYPE        // Passed in null string
                  ...          
 4865    00000058 ........              DC32    SEMIS
 4866                           
 4867                           
 4868                           //      BACKSLASH BACKSLASH:    ( --  )
 4869                           //      After a trailing space treat the rest of the line as a comment.
 4870                           
 4871                            SECTION .text : CONST (2)
 4872                           BACKSLASH_NFA:
 4873    00000000 C1                    DC8     0x0C1
 4874    00000001 DC                    DC8     '\\'+0x80
 4875    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 4876    00000004 ........              DC32    PAREN_NFA
 4877                           BACKSLASH:
 4878    00000008 ........              DC32    DOCOL
 4879    0000000C .............         DC32    ZERO, TIB_SV, IN_SV, AT, PLUS, CSTORE
                  .............
                  .............
                  .........    
 4880    00000024 ........              DC32    SEMIS
 4881                           
 4882                           
 4883                           //      SYSCLK SYSCLK:  ( -- value )
 4884                           //      Returns system clock value in Hz, i.e. 48000000 = 48Mhz.
 4885                           
 4886                            SECTION .text : CONST (2)
 4887                           SYSCLK_NFA:
 4888    00000000 86                    DC8     0x86
 4889    00000001 535953434C            DC8     'SYSCL'
 4890    00000006 CB                    DC8     'K'+0x80
 4891    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 4892    00000008 ........              DC32    BACKSLASH_NFA
 4893                           SYSCLK:
 4894    0000000C ........              DC32    .+5
 4895                            SECTION .text : CODE (2)
 4896    00000000 0549                  LDR     n, = SYSCLOCK   // SystemCoreClock
 4897    00000002 0868                  LDR     t, [n]
 4898                                   TPUSH   // Push -- t
 4898                                   PUSHt   // push t to p, pre decrement p
 4898.1  00000004 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4898.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4898.3                         //      STR     t, [p]
 4898.4                                 ENDM
 4898                                   NEXT
 4898.1                         // ARMv7-M Thumb = .+5
 4898.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4898.3                         // ARMv6-M Thumb = .+4
 4898.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4898                                   NEXT1
 4898.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4898.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4898.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4898.4                         // ARMv6-M Thumb = .+4
 4898.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4898.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4898.7                                 ENDM
 4898.8                                 ENDM
 4898.9                                 ENDM
 4899    00000016 0000           LTORG   //Always outside of code, else data in words
 4899.1                                  TABLE
 4899.2  00000018 ........              Reference on line 4896
 4900                           
 4901                           
 4902                           //      STCTR   ( -- addr ) SYSTICK Interrupt increments this with 32but wrap.
 4903                           //      STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! E000E010h @ .H
 4904                            SECTION .text : CONST (2)
 4905                           STCTR_NFA:
 4906    00000000 85                    DC8     0x85
 4907    00000001 53544354              DC8     'STCT'
 4908    00000005 D2                    DC8     'R'+0x80
 4909    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 4910                           //      DC32    STI_ON_NFA
 4911    00000008 ........              DC32    SYSCLK_NFA
 4912                           STCTR:
 4913    0000000C .............         DC32    DOCON, STICKER
                  ...          
 4914                           
 4915                           
 4916                           //      DELAY ( n value -- ) 7 E000E010h !   5 E000E010h !
 4917                            SECTION .text : CONST (2)
 4918                           DELAY_NFA:
 4919    00000000 85                    DC8     0x85
 4920    00000001 44454C41              DC8     'DELA'
 4921    00000005 D9                    DC8     'Y'+0x80
 4922    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 4923    00000008 ........              DC32    STCTR_NFA
 4924                           DELAY:
 4925    0000000C ........              DC32    .+5
 4926                            SECTION .text : CODE (2)
 4927                                   POP2n   // Reload value in n
 4927.1  00000000 57F8041B              LDR     n, [p],#4
 4927.2                         //      LDR     n, [p]
 4927.3                         //      ADDS    p, p, #4
 4927.4                                 ENDM
 4928                                   POP2t   // loop count in t
 4928.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 4928.2                         //#ifndef TOSCT
 4928.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4928.4                         //#endif
 4928.5                         //      ADDS    p, p, #4
 4928.6                                 ENDM
 4929                           // SET STCTR TO NEGATIVE LOOP COUNT TO END AT ZERO
 4930    00000008 0B4C                  LDR     y, = STICKER
 4931    0000000A C043                  MVNS    t, t            // 1's compliment
 4932    0000000C 401C                  ADDS    t, t, #1        // 2's compliment
 4933    0000000E 2060                  STR     t, [y]
 4934                           // Load SYST_RVR with countdown value
 4935    00000010 0A4A                  LDR     w, = SYST_RVR
 4936    00000012 1160                  STR     n, [w]
 4937                           // and reset SYST_CVR to start countdown.
 4938                           //        LDR     w, = SYST_CVR
 4939                           // Writing it clears the System Tick counter and the COUNTFLAG bit in STCTRL.
 4940    00000014 1160                  STR     n, [w]
 4941                           // If n=0 in t user is just setting reload value
 4942    00000016 0028                  CMP     t, #0           // LOOP OF ZERO
 4943    00000018 06D0                  BEQ     DELAY_DONE
 4944                           // INTERRUPT VERSION: negate n to STCTR and leave when STCTR = 0
 4945                           // STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! E000E010h @ .H
 4946                           // Save and restore user interrupt setting
 4947                           // y = STICKER
 4948    0000001A 094A                  LDR     w, = SYST_CSR
 4949    0000001C 1068                  LDR     t, [w]          // Save user SYSTICK interrupt setting
 4950    0000001E 0721                  MOVS    n, #7
 4951    00000020 1160                  STR     n, [w]          // Turn SYSTICK interrupt on in case it's off
 4952                           DELAY_LOOP:
 4953    00000022 2168                  LDR     n, [y]
 4954    00000024 0029                  CMP     n, #0
 4955    00000026 FCD1                  BNE     DELAY_LOOP
 4956                           DELAY_DONE:
 4957    00000028 1060                  STR     t, [w]  // Restore user SYSTICK interrupt setting
 4958                                   NEXT
 4958.1                         // ARMv7-M Thumb = .+5
 4958.2  0000002A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4958.3                         // ARMv6-M Thumb = .+4
 4958.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4958                                   NEXT1
 4958.1  0000002E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4958.2  00000032 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4958.3  00000036 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4958.4                         // ARMv6-M Thumb = .+4
 4958.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4958.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4958.7                                 ENDM
 4958.8                                 ENDM
 4959                            LTORG
 4959.1                                  TABLE
 4959.2  00000038 ........              Reference on line 4930
 4959.3  0000003C 14E000E0              Reference on line 4935
 4959.4  00000040 10E000E0              Reference on line 4948
 4960                           
 4961                           
 4962                           //      MS MS: ( n -- ) n * 1 millisecond execution time
 4963                           //      SYSTICK_IRQ_ON/OFF  STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! 
 4964                           
 4965                            SECTION .text : CONST (2)
 4966                           MS_NFA:
 4967    00000000 82                    DC8     0x82
 4968    00000001 4D                    DC8     'M'
 4969    00000002 D3                    DC8     'S'+0x80
 4970    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4971    00000004 ........              DC32    DELAY_NFA
 4972                           MS:
 4973    00000008 ........              DC32    DOCOL
 4974                           #ifdef STM32F4_IRC16_48MHZ
 4976                           #endif
 4977                           #ifdef STM32F4_XRC08_168MHZ
 4978    0000000C ........40900         DC32    LIT, 29040h     // 29040h 1ms @ 168mhz RELOAD COUNTER VALUE
                  200          
 4979                           #endif
 4980    00000014 ........              DC32    DELAY
 4981    00000018 ........              DC32    SEMIS
 4982                           
 4983                           
 4984                           //      WORDCAT WORDCAT: ( -- )
 4985                           //      Creates a Word Category NFA and LFA that cannot be searched for,
 4986                           //      but is displayed by WORDS and MYWORDS to label a group of Words.
 4987                           //      Define a group of Words and then add a category name with WORDCAT.
 4988                           //      EX: WORDCAT MY APP WORDS:
 4989                           //      It must be on a line of it's own.
 4990                           //      The colon at the end is FISH convention.
 4991                            SECTION .text : CONST (2)
 4992                           WORDCAT_NFA:
 4993    00000000 87                    DC8     0x87
 4994    00000001 574F52444341          DC8     'WORDCA'
 4995    00000007 D4                    DC8     'T'+0x80
 4996                            ALIGNROM 2,0xFFFFFFFF
 4997    00000008 ........              DC32    MS_NFA
 4998                           WORDCAT:
 4999    0000000C ........              DC32    DOCOL
 5000    00000010 .............         DC32    HERE, TOR
                  ...          
 5001    00000018 .............         DC32    ZERO, CCOMMA    // Count byte place holder
                  ...          
 5002    00000020 ........0D000         DC32    LIT, 0Dh, CCOMMA
                  000........  
 5003    0000002C ........              DC32    HERE
 5004    00000030 ........0D000         DC32    LIT, 0Dh, WORD
                  000........  
 5005    0000003C .............         DC32    DUP, CAT
                  ...          
 5006    00000044 ........0A000         DC32    LIT, 0Ah, ROT, CSTORE
                  000..........
                  ......       
 5007    00000054 .............         DC32    DUP, ONEP, ALLOT
                  ...........  
 5008    00000060 ........84000         DC32    LIT, 084h        // Count before system text
                  000          
 5009    00000068 .............         DC32    PLUS, R, CSTORE
                  ...........  
 5010    00000074 ........0D000         DC32    LIT, 0Dh, CCOMMA
                  000........  
 5011    00000080 ........8A000         DC32    LIT, 08Ah, CCOMMA
                  000........  
 5012    0000008C ........              DC32    ALIGN32_DP_FF_PAD
 5013    00000090 .............         DC32    LATEST, COMMA
                  ...          
 5014    00000098 ........              DC32    RFROM
 5015    0000009C .............         DC32    LIT, CURRENT
                  ...          
 5016    000000A4 ........              DC32    STORE
 5017    000000A8 ........              DC32    SEMIS
 5018                           
 5019                           
 5020                           //      WORDS WORDS:    ( -- ) RENAMED: VLIST to WORDS
 5021                           //      Output list of Words in the dictionary in search order.
 5022                           //      Uses WC_ nfa's to format Word Categories.
 5023                           //      Uses FENCE for where to stop.
 5024                           //      See MYWORDS.
 5025                           
 5026                            SECTION .text : CONST (2)
 5027                           WORDS_NFA:
 5028    00000000 85                    DC8     0x85
 5029    00000001 574F5244              DC8     'WORD'
 5030    00000005 D3                    DC8     'S'+0x80
 5031    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5032    00000008 ........              DC32    WORDCAT_NFA
 5033                           WORDS:
 5034    0000000C ........              DC32    DOCOL
 5035    00000010 .............         DC32    THREE, SPACES
                  ...          
 5036    00000018 ........              DC32    LATEST
 5037                           #ifdef XON_XOFF
 5038    0000001C ........              DC32    XOFF    // TEMP TEST THRE
 5039                           #endif
 5040                           WORDS1:  // ADD nfa length to current out_uv & verify it doesn't violate csll.
 5041                           
 5042    00000020 .............         DC32    ZERO, OVER      // -- nfa zero nfa
                  ...          
 5043    00000028 .............         DC32    ONEP, CAT       // If wc_ header skip
                  ...          
 5044    00000030 ........0D000         DC32    LIT, 0x0D       // -- nfa zero (c@) 0x0D
                  000          
 5045    00000038 .............         DC32    EQUAL, ZEQU     // -- nfa zerro flag
                  ...          
 5046    00000040 ........              DC32    ZBRAN           // -- nfa zero
 5047    00000044 1C000000              DC32     WORDS2-.       // wc_ goto
 5048                                   
 5049    00000048 ........              DC32    DROP            // -- nfa
 5050    0000004C .............         DC32    DUP, PFA, LFA   // -- nfa lfa
                  ...........  
 5051    00000058 .............         DC32    OVER, SUBB      // -- nfa (lfa - nfa)
                  ...          
 5052                           
 5053                           WORDS2: // -- nfa n
 5054                           
 5055    00000060 .............         DC32    OUT_SV, AT
                  ...          
 5056    00000068 ........              DC32    PLUS
 5057    0000006C ........4A000         DC32    LIT, 74         // was :NONAME CSLL - WORDS line length constant.
                  000          
 5058    00000074 ........              DC32    GREATERTHAN
 5059    00000078 ........              DC32    ZBRAN           // If not at end of line
 5060    0000007C 10000000              DC32     WORD21-.        // skip cr and out reset
 5061                           
 5062    00000080 ........              DC32    CR              // Start another line
 5063    00000084 .............         DC32    THREE, SPACES
                  ...          
 5064                           
 5065                           WORD21:
 5066                           #ifdef  IO2TP
 5069                           #endif
 5070                           // For MYWORDS test FENCE and stop if less
 5071    0000008C ........              DC32    DUP             // nfa
 5072    00000090 .............         DC32    FENCE_SV, AT
                  ...          
 5073    00000098 ........              DC32    LESSTHAN
 5074    0000009C ........              DC32    ZBRAN
 5075    000000A0 0C000000              DC32     WORDSCONT-.
 5076                           
 5077    000000A4 ........              DC32    BRAN
 5078    000000A8 54000000              DC32     WORDSDONE-.
 5079                           
 5080                           WORDSCONT:
 5081    000000AC ........              DC32    DUP             // nfa
 5082    000000B0 ........              DC32    IDDOT
 5083    000000B4 .............         DC32    TWO, SPACES
                  ...          
 5084                           
 5085    000000BC .............         DC32    DUP, ONEP, CAT  // Take nfa and look for WORDCAT signature
                  ...........  
 5086    000000C8 ........0D000         DC32    LIT, 0x0D       // which is cr
                  000          
 5087    000000D0 ........              DC32    EQUAL
 5088    000000D4 ........              DC32    ZBRAN           // If not wordcat
 5089    000000D8 08000000              DC32     NOT_WC-.       // skip
 5090                           
 5091    000000DC ........              DC32    zero_OUT
 5092                           
 5093                           NOT_WC:
 5094    000000E0 ........              DC32    PFA             // \ nfa -- pfa
 5095    000000E4 ........              DC32    LFA             // \ pfa -- lfa
 5096    000000E8 ........              DC32    AT              // Is next lfa
 5097    000000EC ........              DC32    DUP
 5098    000000F0 ........              DC32    ZEQU            // Zero = end of dictionary
 5099                           
 5100                           // REMOVED SO WORDS AND MYWORDS CAN BE USED IN DOWNLOAD FILES
 5101                           //      DC32    QKEY           // Zero or break key \ ^C = 0x03
 5102                           //      DC32    OR
 5103                           
 5104    000000F4 ........              DC32    ZBRAN           // Until break key or end of dictionary
 5105    000000F8 28FFFFFF              DC32     WORDS1-.
 5106                           
 5107                           #ifdef  IO2TP
 5110                           #endif
 5111                           WORDSDONE:
 5112    000000FC .............         DC32    DROP, CR
                  ...          
 5113    00000104 ........              DC32    SEMIS
 5114                           
 5115                           
 5116                           //      MYWORDS MYWORDS: ( -- )
 5117                           //      Print only system defined words by manipulating FENCE.
 5118                           
 5119                            SECTION .text : CONST (2)
 5120                           MYWORDS_NFA:
 5121    00000000 87                    DC8     0x87
 5122    00000001 4D59574F5244          DC8     'MYWORD'
 5123    00000007 D3                    DC8     'S'+0x80
 5124                            ALIGNROM 2,0xFFFFFFFF
 5125    00000008 ........              DC32    WORDS_NFA
 5126                           MYWORDS:
 5127    0000000C ........              DC32    DOCOL
 5128    00000010 ........00000         DC32    strva , FLASH_SPAGE, FENCE
                  208........  
 5129    0000001C ........              DC32    WORDS                   // now print words in ram
 5130    00000020 ........00000         DC32    strva, 0 , FENCE
                  000........  
 5131    0000002C ........              DC32    SEMIS
 5132                           
 5133                           
 5134                           //      FISH_ONLY FISH_ONLY     ( -- ) MODIFIED:
 5135                           //      RESET DP, UP AND CURRENT TO ORIGINAL FLASH IMAGE
 5136                           
 5137                            SECTION .text : CONST (2)
 5138                           FISH_ONLY_NFA:
 5139    00000000 89                    DC8     0x80+9
 5140    00000001 464953485F4F4         DC8     'FISH_ONL'
                  E4C          
 5141    00000009 D9                    DC8     'Y'+0x80
 5142    0000000A FFFF           ALIGNROM 2,0xFFFFFFFF
 5143    0000000C ........              DC32    MYWORDS_NFA
 5144                           FISH_ONLY:
 5145    00000010 ........              DC32    .+5
 5146                            SECTION .text : CODE (2)
 5147                           //      LDR     n, = TASK_NFA           // preserve TOS
 5148                           #ifdef FISH_PubRel_WORDSET
 5149    00000000 0949                  LDR     n, = WC_FISH_PubRel_NFA
 5150                           #endif
 5151                           #ifdef FISH_STM32M407vg_PRO_WORDCAT
 5153                           #endif
 5154    00000002 0A4C                  LDR     y, = CURRENT            // CURRENT SETTING
 5155    00000004 2160                  STR     n, [y]
 5156    00000006 0A4C                  LDR     y, = FPC                // FLASH CURRENT
 5157    00000008 2160                  STR     n, [y]
 5158    0000000A 0A49                  LDR     n, = RAMVARSPACE_START
 5159    0000000C 0A4C                  LDR     y, = UP                 // UP SETTING
 5160    0000000E 2160                  STR     n, [y]
 5161    00000010 0A4C                  LDR     y, = FPSV                // FLASH USER VARS
 5162    00000012 2160                  STR     n, [y]
 5163    00000014 0A49                  LDR     n, = ORIG
 5164    00000016 0B4C                  LDR     y, = DP                 // DP SETTING
 5165    00000018 2160                  STR     n, [y]
 5166                                   NEXT
 5166.1                         // ARMv7-M Thumb = .+5
 5166.2  0000001A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 5166.3                         // ARMv6-M Thumb = .+4
 5166.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 5166                                   NEXT1
 5166.1  0000001E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 5166.2  00000022 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 5166.3  00000026 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 5166.4                         // ARMv6-M Thumb = .+4
 5166.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 5166.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 5166.7                                 ENDM
 5166.8                                 ENDM
 5167                            LTORG
 5167.1                                  TABLE
 5167.2  00000028 ........              Reference on line 5149
 5167.3  0000002C ........              Reference on line 5154
 5167.4  00000030 ........              Reference on line 5156
 5167.5  00000034 ........              Reference on line 5158
 5167.6  00000038 ........              Reference on line 5159
 5167.7  0000003C ........              Reference on line 5161
 5167.8  00000040 ........              Reference on line 5163
 5167.9  00000044 ........              Reference on line 5164
 5168                           
 5169                           
 5170                           //      FISH FISH:      ( -- )
 5171                           //      Print Flash Status and FISH Signon Message.
 5172                           
 5173                           
 5174                            SECTION .text : CONST (2)
 5175                           FISH_NFA:
 5176    00000000 84                    DC8     0x84
 5177    00000001 464953                DC8     'FIS'
 5178    00000004 C8                    DC8     'H'+0x80
 5179    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 5180    00000008 ........              DC32    FISH_ONLY_NFA
 5181                           FISH:
 5182    0000000C ........              DC32    DOCOL
 5183    00000010 ........              DC32    FLASH_SCAN
 5184    00000014 ........              DC32    SIGNON
 5185    00000018 ........              DC32    ABORT
 5186                           
 5187                           //=============================== WORDCAT ====================================//
 5188                           //NOEXEC HEADERFORWORDCATEGORIES
 5189                           //      WC_FISH_PubRel: = FISH PubRel Reference Model CATEGORY
 5190                            SECTION .text : CONST (2)
 5191                           WC_FISH_PubRel_NFA:
 5192    00000000 99                    DC8     0x80+4+21
 5193    00000001 0D0A                  DC8     0x0D, 0x0A
 5194    00000003 4649534820526         DC8     'FISH Reference Model:'
                  5666572656E63
                  65204D6F64656
                  C3A          
 5195    00000018 0D8A                  DC8     0x0D, 0x0A+0x80
 5196    0000001A FFFF           ALIGNROM 2,0xFFFFFFFF
 5197    0000001C ........              DC32    FISH_NFA
 5198                           
 5199                           ;**** FIRST WORD LISTED****
 5200                           
 5201                           //=============================== WORDCAT ====================================//
 5202                           
 5203                           #ifdef FISH_STM_M3_PRO_WORDCAT
 5205                           #endif
 5206                           // FIRST WORDCAT
 5207                           
 5208                           //------------------------------------------------------------------------------
 5209                           // FOR MULTI TASKING MUST BE PLACED IN RAM AND OFFSET USED IN SYSTEM VARS!!!!!!
 5210                           //            T A S K 
 5211                           //
 5212                           ;.data          // Place TASK at beginning of RAM, or not.
 5213                           /*
 5214                            SECTION .text : CONST (2)
 5215                           TASK_NFA:
 5216                                   DC8     0x84
 5217                                   DC8     'TAS'
 5218                                   DC8     'K'+0x80
 5219                            ALIGNROM 2,0xFFFFFFFF
 5220                           //      TASK Is top of dictionary until new definitionsa added
 5221                           //      PATCH CONTEXT or LATEST else LFA in TASK FROM SYM TABLE
 5222                           //      To debug dictionary searches - see - PFIND & DFIND
 5223                           //      DC32    ZEQU_NFA        // 4 (no match) bombing at +
 5224                           //      DC32    NOOP_NFA        // Patch here to shorten test of PFIND
 5225                           //      DC32    CAT_NFA         // C@ before @
 5226                           //      DC32    LESS_NFA        // < before =
 5227                           //       DC32   SoCinit_NFA     //XON_NFA               // FULL DICT SEARCH
 5228                                   DC32    MS_NFA
 5229                           TASK:
 5230                                   DC32    DOCOL
 5231                                   DC32    SEMIS
 5232                           */
 5233                           
 5234                           //------------------------------------------------------------------------------
 5235                           //:NONAME SECTION:
 5236                           // THESE STAY HERE (INSTEAD OF SLLIB) BECAUSE THEY ARE CONDITIONALLY INCLUDED
 5237                           // HI-LEVEL THEM ASM SECTIONS
 5238                           #ifdef IO2TP
 5247                           #endif
 5248                           
 5249                           #ifdef IO2TP
 5258                           #endif
 5259                           
 5260                           #ifdef USE_CMAIN
 5261                           //:NONAME RET2c:      ( -- ) POP main.c saved lr saved in STM32Fx_COLD_FISH
 5262                            SECTION .text : CONST (2)
 5263                            ALIGNROM 2,0xFFFFFFFF
 5264                           RET2c:
 5265    00000000 ........              DC32    .+5
 5266                            SECTION .text : CODE (2)
 5267    00000000 0098                  LDR     t, [sp]
 5268    00000002 01B0                  ADD     sp, sp, #4
 5269    00000004 8746                  MOV     pc, t
 5270                           #endif
 5271                           
 5272                           #ifdef TESTRAM
 5378                           #endif  // TESTRAM
 5379                           //------------------------------------------------------------------------------
 5380                           // Placing blocks that can change at end of link map
 5381                           // Place :NONAME for static Library first in FISH_STM_M3_SLIB.s
 5382                           
 5383                           $FISH_STM32F4_MSGS.h
 5384                           
 5385                           // SYSTEMCLOCK #define set in FISH_M0_EQUATES.s for SYSCLOCK value.
 5386                           // THIS IS A :NONAME WORDSET
 5387                           
 5388                           $FISH_STM32F4_SOC_INIT.s
 5389                           
 5390                            END
##############################
#           CRC:0            #
#        Errors:   0         #
#        Warnings: 0         #
#        Bytes: 83245        #
##############################



